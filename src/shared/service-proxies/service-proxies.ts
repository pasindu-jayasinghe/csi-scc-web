//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AppControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getHello(): Observable<string> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHello(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHello(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetHello(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deloy(): Observable<boolean> {
        let url_ = this.baseUrl + "/deloy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeloy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeloy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeloy(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    seedAll(): Observable<void> {
        let url_ = this.baseUrl + "/seed-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeedAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeedAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSeedAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    test(): Observable<void> {
        let url_ = this.baseUrl + "/test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    testLog(): Observable<boolean> {
        let url_ = this.baseUrl + "/test-log";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestLog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTestLog(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EquationLibControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEquation(source: string): Observable<any> {
        let url_ = this.baseUrl + "/equation-lib/get-equation?";
        if (source === undefined || source === null)
            throw new Error("The parameter 'source' must be defined and cannot be null.");
        else
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEquation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEquation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetEquation(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DocumentControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    uploadFile(): Observable<any> {
        let url_ = this.baseUrl + "/document/upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteDoc(docId: number): Observable<void> {
        let url_ = this.baseUrl + "/document/delete/{docId}";
        if (docId === undefined || docId === null)
            throw new Error("The parameter 'docId' must be defined.");
        url_ = url_.replace("{docId}", encodeURIComponent("" + docId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDoc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDocuments(oid: number, owner: number): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/getDocument/{oid}/{owner}";
        if (oid === undefined || oid === null)
            throw new Error("The parameter 'oid' must be defined.");
        url_ = url_.replace("{oid}", encodeURIComponent("" + oid));
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents[]>;
        }));
    }

    protected processGetDocuments(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Documents.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDocumentsForViweCountry(oid: number): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/getDocumentsForViweCountry?";
        if (oid === undefined || oid === null)
            throw new Error("The parameter 'oid' must be defined and cannot be null.");
        else
            url_ += "oid=" + encodeURIComponent("" + oid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentsForViweCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentsForViweCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents[]>;
        }));
    }

    protected processGetDocumentsForViweCountry(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Documents.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadDocuments(did: number, state: string): Observable<void> {
        let url_ = this.baseUrl + "/document/downloadDocument/{state}/{did}";
        if (did === undefined || did === null)
            throw new Error("The parameter 'did' must be defined.");
        url_ = url_.replace("{did}", encodeURIComponent("" + did));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined.");
        url_ = url_.replace("{state}", encodeURIComponent("" + state));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownloadDocuments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieve a single Documents
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseDocumentControllerDocuments(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents>;
        }));
    }

    protected processGetOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Documents
     * @return Response
     */
    updateOneBaseDocumentControllerDocuments(id: number, body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents>;
        }));
    }

    protected processUpdateOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Documents
     * @return Response
     */
    replaceOneBaseDocumentControllerDocuments(id: number, body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents>;
        }));
    }

    protected processReplaceOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Documents
     * @return Delete one base response
     */
    deleteOneBaseDocumentControllerDocuments(id: number): Observable<void> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Documents
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseDocumentControllerDocuments(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyDocumentsResponseDto> {
        let url_ = this.baseUrl + "/document?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyDocumentsResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyDocumentsResponseDto>;
        }));
    }

    protected processGetManyBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<GetManyDocumentsResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyDocumentsResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Documents
     * @return Get create one base response
     */
    createOneBaseDocumentControllerDocuments(body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents>;
        }));
    }

    protected processCreateOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Documents.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Documents
     * @return Get create many base response
     */
    createManyBaseDocumentControllerDocuments(body: CreateManyDocumentsDto): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents[]>;
        }));
    }

    protected processCreateManyBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Documents.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single User
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUsersControllerUser(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single User
     * @return Response
     */
    updateOneBaseUsersControllerUser(id: number, body: User): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUpdateOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single User
     * @return Response
     */
    replaceOneBaseUsersControllerUser(id: number, body: User): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processReplaceOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single User
     * @return Delete one base response
     */
    deleteOneBaseUsersControllerUser(id: number): Observable<void> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseUsersControllerUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Users
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUsersControllerUser(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUserResponseDto> {
        let url_ = this.baseUrl + "/users?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyUserResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyUserResponseDto>;
        }));
    }

    protected processGetManyBaseUsersControllerUser(response: HttpResponseBase): Observable<GetManyUserResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUserResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single User
     * @return Get create one base response
     */
    createOneBaseUsersControllerUser(body: User): Observable<User> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processCreateOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = User.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Users
     * @return Get create many base response
     */
    createManyBaseUsersControllerUser(body: CreateManyUserDto): Observable<User[]> {
        let url_ = this.baseUrl + "/users/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User[]>;
        }));
    }

    protected processCreateManyBaseUsersControllerUser(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(User.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single AssignedES
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseAssignedESsControllerAssignedES(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<AssignedES> {
        let url_ = this.baseUrl + "/assigned-ES/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseAssignedESsControllerAssignedES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssignedES>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssignedES>;
        }));
    }

    protected processGetOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssignedES.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single AssignedES
     * @return Response
     */
    updateOneBaseAssignedESsControllerAssignedES(id: number, body: AssignedES): Observable<AssignedES> {
        let url_ = this.baseUrl + "/assigned-ES/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseAssignedESsControllerAssignedES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssignedES>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssignedES>;
        }));
    }

    protected processUpdateOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssignedES.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single AssignedES
     * @return Response
     */
    replaceOneBaseAssignedESsControllerAssignedES(id: number, body: AssignedES): Observable<AssignedES> {
        let url_ = this.baseUrl + "/assigned-ES/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseAssignedESsControllerAssignedES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssignedES>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssignedES>;
        }));
    }

    protected processReplaceOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssignedES.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single AssignedES
     * @return Delete one base response
     */
    deleteOneBaseAssignedESsControllerAssignedES(id: number): Observable<void> {
        let url_ = this.baseUrl + "/assigned-ES/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseAssignedESsControllerAssignedES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple AssignedES
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseAssignedESsControllerAssignedES(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyAssignedESResponseDto> {
        let url_ = this.baseUrl + "/assigned-ES?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseAssignedESsControllerAssignedES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyAssignedESResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyAssignedESResponseDto>;
        }));
    }

    protected processGetManyBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<GetManyAssignedESResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyAssignedESResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single AssignedES
     * @return Get create one base response
     */
    createOneBaseAssignedESsControllerAssignedES(body: AssignedES): Observable<AssignedES> {
        let url_ = this.baseUrl + "/assigned-ES";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseAssignedESsControllerAssignedES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssignedES>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssignedES>;
        }));
    }

    protected processCreateOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AssignedES.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple AssignedES
     * @return Get create many base response
     */
    createManyBaseAssignedESsControllerAssignedES(body: CreateManyAssignedESDto): Observable<AssignedES[]> {
        let url_ = this.baseUrl + "/assigned-ES/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseAssignedESsControllerAssignedES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssignedES[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssignedES[]>;
        }));
    }

    protected processCreateManyBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(AssignedES.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Unit
     * @return Get create one base response
     */
    createOneBaseUnitControllerUnit(body: Unit): Observable<Unit> {
        let url_ = this.baseUrl + "/unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUnitControllerUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUnitControllerUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCreateOneBaseUnitControllerUnit(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Unit.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Units
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUnitControllerUnit(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUnitResponseDto> {
        let url_ = this.baseUrl + "/unit?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUnitControllerUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUnitControllerUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyUnitResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyUnitResponseDto>;
        }));
    }

    protected processGetManyBaseUnitControllerUnit(response: HttpResponseBase): Observable<GetManyUnitResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUnitResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Unit
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUnitControllerUnit(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/unit/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUnitControllerUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUnitControllerUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processGetOneBaseUnitControllerUnit(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Unit
     * @return Response
     */
    updateOneBaseUnitControllerUnit(id: number, body: Unit): Observable<Unit> {
        let url_ = this.baseUrl + "/unit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUnitControllerUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUnitControllerUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUpdateOneBaseUnitControllerUnit(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Unit
     * @return Response
     */
    replaceOneBaseUnitControllerUnit(id: number, body: Unit): Observable<Unit> {
        let url_ = this.baseUrl + "/unit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUnitControllerUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUnitControllerUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processReplaceOneBaseUnitControllerUnit(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Unit
     * @return Delete one base response
     */
    deleteOneBaseUnitControllerUnit(id: number): Observable<void> {
        let url_ = this.baseUrl + "/unit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUnitControllerUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUnitControllerUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseUnitControllerUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Units
     * @return Get create many base response
     */
    createManyBaseUnitControllerUnit(body: CreateManyUnitDto): Observable<Unit[]> {
        let url_ = this.baseUrl + "/unit/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUnitControllerUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUnitControllerUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit[]>;
        }));
    }

    protected processCreateManyBaseUnitControllerUnit(response: HttpResponseBase): Observable<Unit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Unit.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Level
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseLevelControllerLevel(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Level> {
        let url_ = this.baseUrl + "/level/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseLevelControllerLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseLevelControllerLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Level>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Level>;
        }));
    }

    protected processGetOneBaseLevelControllerLevel(response: HttpResponseBase): Observable<Level> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Level.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Level
     * @return Response
     */
    updateOneBaseLevelControllerLevel(id: number, body: Level): Observable<Level> {
        let url_ = this.baseUrl + "/level/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseLevelControllerLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseLevelControllerLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Level>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Level>;
        }));
    }

    protected processUpdateOneBaseLevelControllerLevel(response: HttpResponseBase): Observable<Level> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Level.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Level
     * @return Response
     */
    replaceOneBaseLevelControllerLevel(id: number, body: Level): Observable<Level> {
        let url_ = this.baseUrl + "/level/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseLevelControllerLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseLevelControllerLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Level>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Level>;
        }));
    }

    protected processReplaceOneBaseLevelControllerLevel(response: HttpResponseBase): Observable<Level> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Level.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Level
     * @return Delete one base response
     */
    deleteOneBaseLevelControllerLevel(id: number): Observable<void> {
        let url_ = this.baseUrl + "/level/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseLevelControllerLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseLevelControllerLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseLevelControllerLevel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Levels
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseLevelControllerLevel(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyLevelResponseDto> {
        let url_ = this.baseUrl + "/level?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseLevelControllerLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseLevelControllerLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyLevelResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyLevelResponseDto>;
        }));
    }

    protected processGetManyBaseLevelControllerLevel(response: HttpResponseBase): Observable<GetManyLevelResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyLevelResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Level
     * @return Get create one base response
     */
    createOneBaseLevelControllerLevel(body: Level): Observable<Level> {
        let url_ = this.baseUrl + "/level";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseLevelControllerLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseLevelControllerLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Level>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Level>;
        }));
    }

    protected processCreateOneBaseLevelControllerLevel(response: HttpResponseBase): Observable<Level> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Level.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Levels
     * @return Get create many base response
     */
    createManyBaseLevelControllerLevel(body: CreateManyLevelDto): Observable<Level[]> {
        let url_ = this.baseUrl + "/level/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseLevelControllerLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseLevelControllerLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Level[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Level[]>;
        }));
    }

    protected processCreateManyBaseLevelControllerLevel(response: HttpResponseBase): Observable<Level[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Level.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single UnitDetails
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUnitDetailsControllerUnitDetails(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<UnitDetails> {
        let url_ = this.baseUrl + "/unit-details/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUnitDetailsControllerUnitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUnitDetailsControllerUnitDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetails>;
        }));
    }

    protected processGetOneBaseUnitDetailsControllerUnitDetails(response: HttpResponseBase): Observable<UnitDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single UnitDetails
     * @return Response
     */
    updateOneBaseUnitDetailsControllerUnitDetails(id: number, body: UnitDetails): Observable<UnitDetails> {
        let url_ = this.baseUrl + "/unit-details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUnitDetailsControllerUnitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUnitDetailsControllerUnitDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetails>;
        }));
    }

    protected processUpdateOneBaseUnitDetailsControllerUnitDetails(response: HttpResponseBase): Observable<UnitDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single UnitDetails
     * @return Response
     */
    replaceOneBaseUnitDetailsControllerUnitDetails(id: number, body: UnitDetails): Observable<UnitDetails> {
        let url_ = this.baseUrl + "/unit-details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUnitDetailsControllerUnitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUnitDetailsControllerUnitDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetails>;
        }));
    }

    protected processReplaceOneBaseUnitDetailsControllerUnitDetails(response: HttpResponseBase): Observable<UnitDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single UnitDetails
     * @return Delete one base response
     */
    deleteOneBaseUnitDetailsControllerUnitDetails(id: number): Observable<void> {
        let url_ = this.baseUrl + "/unit-details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUnitDetailsControllerUnitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUnitDetailsControllerUnitDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseUnitDetailsControllerUnitDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple UnitDetails
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUnitDetailsControllerUnitDetails(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUnitDetailsResponseDto> {
        let url_ = this.baseUrl + "/unit-details?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUnitDetailsControllerUnitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUnitDetailsControllerUnitDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyUnitDetailsResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyUnitDetailsResponseDto>;
        }));
    }

    protected processGetManyBaseUnitDetailsControllerUnitDetails(response: HttpResponseBase): Observable<GetManyUnitDetailsResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUnitDetailsResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single UnitDetails
     * @return Get create one base response
     */
    createOneBaseUnitDetailsControllerUnitDetails(body: UnitDetails): Observable<UnitDetails> {
        let url_ = this.baseUrl + "/unit-details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUnitDetailsControllerUnitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUnitDetailsControllerUnitDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetails>;
        }));
    }

    protected processCreateOneBaseUnitDetailsControllerUnitDetails(response: HttpResponseBase): Observable<UnitDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UnitDetails.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple UnitDetails
     * @return Get create many base response
     */
    createManyBaseUnitDetailsControllerUnitDetails(body: CreateManyUnitDetailsDto): Observable<UnitDetails[]> {
        let url_ = this.baseUrl + "/unit-details/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUnitDetailsControllerUnitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUnitDetailsControllerUnitDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetails[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetails[]>;
        }));
    }

    protected processCreateManyBaseUnitDetailsControllerUnitDetails(response: HttpResponseBase): Observable<UnitDetails[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(UnitDetails.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Industry
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseIndustryControllerIndustry(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Industry> {
        let url_ = this.baseUrl + "/industry/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseIndustryControllerIndustry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseIndustryControllerIndustry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Industry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Industry>;
        }));
    }

    protected processGetOneBaseIndustryControllerIndustry(response: HttpResponseBase): Observable<Industry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Industry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Industry
     * @return Response
     */
    updateOneBaseIndustryControllerIndustry(id: number, body: Industry): Observable<Industry> {
        let url_ = this.baseUrl + "/industry/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseIndustryControllerIndustry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseIndustryControllerIndustry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Industry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Industry>;
        }));
    }

    protected processUpdateOneBaseIndustryControllerIndustry(response: HttpResponseBase): Observable<Industry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Industry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Industry
     * @return Response
     */
    replaceOneBaseIndustryControllerIndustry(id: number, body: Industry): Observable<Industry> {
        let url_ = this.baseUrl + "/industry/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseIndustryControllerIndustry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseIndustryControllerIndustry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Industry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Industry>;
        }));
    }

    protected processReplaceOneBaseIndustryControllerIndustry(response: HttpResponseBase): Observable<Industry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Industry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Industry
     * @return Delete one base response
     */
    deleteOneBaseIndustryControllerIndustry(id: number): Observable<void> {
        let url_ = this.baseUrl + "/industry/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseIndustryControllerIndustry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseIndustryControllerIndustry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseIndustryControllerIndustry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Industries
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseIndustryControllerIndustry(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyIndustryResponseDto> {
        let url_ = this.baseUrl + "/industry?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseIndustryControllerIndustry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseIndustryControllerIndustry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyIndustryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyIndustryResponseDto>;
        }));
    }

    protected processGetManyBaseIndustryControllerIndustry(response: HttpResponseBase): Observable<GetManyIndustryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyIndustryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Industry
     * @return Get create one base response
     */
    createOneBaseIndustryControllerIndustry(body: Industry): Observable<Industry> {
        let url_ = this.baseUrl + "/industry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseIndustryControllerIndustry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseIndustryControllerIndustry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Industry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Industry>;
        }));
    }

    protected processCreateOneBaseIndustryControllerIndustry(response: HttpResponseBase): Observable<Industry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Industry.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Industries
     * @return Get create many base response
     */
    createManyBaseIndustryControllerIndustry(body: CreateManyIndustryDto): Observable<Industry[]> {
        let url_ = this.baseUrl + "/industry/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseIndustryControllerIndustry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseIndustryControllerIndustry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Industry[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Industry[]>;
        }));
    }

    protected processCreateManyBaseIndustryControllerIndustry(response: HttpResponseBase): Observable<Industry[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Industry.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single NumEmployee
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseNumEmployeesControllerNumEmployee(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<NumEmployee> {
        let url_ = this.baseUrl + "/num-employees/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseNumEmployeesControllerNumEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseNumEmployeesControllerNumEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NumEmployee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NumEmployee>;
        }));
    }

    protected processGetOneBaseNumEmployeesControllerNumEmployee(response: HttpResponseBase): Observable<NumEmployee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NumEmployee.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single NumEmployee
     * @return Response
     */
    updateOneBaseNumEmployeesControllerNumEmployee(id: number, body: NumEmployee): Observable<NumEmployee> {
        let url_ = this.baseUrl + "/num-employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseNumEmployeesControllerNumEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseNumEmployeesControllerNumEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NumEmployee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NumEmployee>;
        }));
    }

    protected processUpdateOneBaseNumEmployeesControllerNumEmployee(response: HttpResponseBase): Observable<NumEmployee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NumEmployee.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single NumEmployee
     * @return Response
     */
    replaceOneBaseNumEmployeesControllerNumEmployee(id: number, body: NumEmployee): Observable<NumEmployee> {
        let url_ = this.baseUrl + "/num-employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseNumEmployeesControllerNumEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseNumEmployeesControllerNumEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NumEmployee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NumEmployee>;
        }));
    }

    protected processReplaceOneBaseNumEmployeesControllerNumEmployee(response: HttpResponseBase): Observable<NumEmployee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NumEmployee.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single NumEmployee
     * @return Delete one base response
     */
    deleteOneBaseNumEmployeesControllerNumEmployee(id: number): Observable<void> {
        let url_ = this.baseUrl + "/num-employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseNumEmployeesControllerNumEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseNumEmployeesControllerNumEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseNumEmployeesControllerNumEmployee(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple NumEmployees
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseNumEmployeesControllerNumEmployee(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyNumEmployeeResponseDto> {
        let url_ = this.baseUrl + "/num-employees?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseNumEmployeesControllerNumEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseNumEmployeesControllerNumEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyNumEmployeeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyNumEmployeeResponseDto>;
        }));
    }

    protected processGetManyBaseNumEmployeesControllerNumEmployee(response: HttpResponseBase): Observable<GetManyNumEmployeeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyNumEmployeeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single NumEmployee
     * @return Get create one base response
     */
    createOneBaseNumEmployeesControllerNumEmployee(body: NumEmployee): Observable<NumEmployee> {
        let url_ = this.baseUrl + "/num-employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseNumEmployeesControllerNumEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseNumEmployeesControllerNumEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NumEmployee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NumEmployee>;
        }));
    }

    protected processCreateOneBaseNumEmployeesControllerNumEmployee(response: HttpResponseBase): Observable<NumEmployee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NumEmployee.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple NumEmployees
     * @return Get create many base response
     */
    createManyBaseNumEmployeesControllerNumEmployee(body: CreateManyNumEmployeeDto): Observable<NumEmployee[]> {
        let url_ = this.baseUrl + "/num-employees/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseNumEmployeesControllerNumEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseNumEmployeesControllerNumEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NumEmployee[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NumEmployee[]>;
        }));
    }

    protected processCreateManyBaseNumEmployeesControllerNumEmployee(response: HttpResponseBase): Observable<NumEmployee[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(NumEmployee.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single PrevReport
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePrevReportsControllerPrevReport(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PrevReport> {
        let url_ = this.baseUrl + "/prev-reports/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePrevReportsControllerPrevReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePrevReportsControllerPrevReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevReport>;
        }));
    }

    protected processGetOneBasePrevReportsControllerPrevReport(response: HttpResponseBase): Observable<PrevReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrevReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single PrevReport
     * @return Response
     */
    updateOneBasePrevReportsControllerPrevReport(id: number, body: PrevReport): Observable<PrevReport> {
        let url_ = this.baseUrl + "/prev-reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePrevReportsControllerPrevReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePrevReportsControllerPrevReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevReport>;
        }));
    }

    protected processUpdateOneBasePrevReportsControllerPrevReport(response: HttpResponseBase): Observable<PrevReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrevReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single PrevReport
     * @return Response
     */
    replaceOneBasePrevReportsControllerPrevReport(id: number, body: PrevReport): Observable<PrevReport> {
        let url_ = this.baseUrl + "/prev-reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePrevReportsControllerPrevReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePrevReportsControllerPrevReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevReport>;
        }));
    }

    protected processReplaceOneBasePrevReportsControllerPrevReport(response: HttpResponseBase): Observable<PrevReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrevReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single PrevReport
     * @return Delete one base response
     */
    deleteOneBasePrevReportsControllerPrevReport(id: number): Observable<void> {
        let url_ = this.baseUrl + "/prev-reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePrevReportsControllerPrevReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePrevReportsControllerPrevReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBasePrevReportsControllerPrevReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple PrevReports
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePrevReportsControllerPrevReport(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPrevReportResponseDto> {
        let url_ = this.baseUrl + "/prev-reports?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePrevReportsControllerPrevReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePrevReportsControllerPrevReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyPrevReportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyPrevReportResponseDto>;
        }));
    }

    protected processGetManyBasePrevReportsControllerPrevReport(response: HttpResponseBase): Observable<GetManyPrevReportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPrevReportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single PrevReport
     * @return Get create one base response
     */
    createOneBasePrevReportsControllerPrevReport(body: PrevReport): Observable<PrevReport> {
        let url_ = this.baseUrl + "/prev-reports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePrevReportsControllerPrevReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePrevReportsControllerPrevReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevReport>;
        }));
    }

    protected processCreateOneBasePrevReportsControllerPrevReport(response: HttpResponseBase): Observable<PrevReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PrevReport.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple PrevReports
     * @return Get create many base response
     */
    createManyBasePrevReportsControllerPrevReport(body: CreateManyPrevReportDto): Observable<PrevReport[]> {
        let url_ = this.baseUrl + "/prev-reports/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePrevReportsControllerPrevReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePrevReportsControllerPrevReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevReport[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevReport[]>;
        }));
    }

    protected processCreateManyBasePrevReportsControllerPrevReport(response: HttpResponseBase): Observable<PrevReport[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PrevReport.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single PrevEmission
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePrevEmissionControllerPrevEmission(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PrevEmission> {
        let url_ = this.baseUrl + "/prev-emission/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePrevEmissionControllerPrevEmission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePrevEmissionControllerPrevEmission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevEmission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevEmission>;
        }));
    }

    protected processGetOneBasePrevEmissionControllerPrevEmission(response: HttpResponseBase): Observable<PrevEmission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrevEmission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single PrevEmission
     * @return Response
     */
    updateOneBasePrevEmissionControllerPrevEmission(id: number, body: PrevEmission): Observable<PrevEmission> {
        let url_ = this.baseUrl + "/prev-emission/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePrevEmissionControllerPrevEmission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePrevEmissionControllerPrevEmission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevEmission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevEmission>;
        }));
    }

    protected processUpdateOneBasePrevEmissionControllerPrevEmission(response: HttpResponseBase): Observable<PrevEmission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrevEmission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single PrevEmission
     * @return Response
     */
    replaceOneBasePrevEmissionControllerPrevEmission(id: number, body: PrevEmission): Observable<PrevEmission> {
        let url_ = this.baseUrl + "/prev-emission/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePrevEmissionControllerPrevEmission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePrevEmissionControllerPrevEmission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevEmission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevEmission>;
        }));
    }

    protected processReplaceOneBasePrevEmissionControllerPrevEmission(response: HttpResponseBase): Observable<PrevEmission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrevEmission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single PrevEmission
     * @return Delete one base response
     */
    deleteOneBasePrevEmissionControllerPrevEmission(id: number): Observable<void> {
        let url_ = this.baseUrl + "/prev-emission/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePrevEmissionControllerPrevEmission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePrevEmissionControllerPrevEmission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBasePrevEmissionControllerPrevEmission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple PrevEmissions
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePrevEmissionControllerPrevEmission(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPrevEmissionResponseDto> {
        let url_ = this.baseUrl + "/prev-emission?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePrevEmissionControllerPrevEmission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePrevEmissionControllerPrevEmission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyPrevEmissionResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyPrevEmissionResponseDto>;
        }));
    }

    protected processGetManyBasePrevEmissionControllerPrevEmission(response: HttpResponseBase): Observable<GetManyPrevEmissionResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPrevEmissionResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single PrevEmission
     * @return Get create one base response
     */
    createOneBasePrevEmissionControllerPrevEmission(body: PrevEmission): Observable<PrevEmission> {
        let url_ = this.baseUrl + "/prev-emission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePrevEmissionControllerPrevEmission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePrevEmissionControllerPrevEmission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevEmission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevEmission>;
        }));
    }

    protected processCreateOneBasePrevEmissionControllerPrevEmission(response: HttpResponseBase): Observable<PrevEmission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PrevEmission.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple PrevEmissions
     * @return Get create many base response
     */
    createManyBasePrevEmissionControllerPrevEmission(body: CreateManyPrevEmissionDto): Observable<PrevEmission[]> {
        let url_ = this.baseUrl + "/prev-emission/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePrevEmissionControllerPrevEmission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePrevEmissionControllerPrevEmission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrevEmission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrevEmission[]>;
        }));
    }

    protected processCreateManyBasePrevEmissionControllerPrevEmission(response: HttpResponseBase): Observable<PrevEmission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PrevEmission.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single UnitDetailMessage
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUnitDetailMessageControllerUnitDetailMessage(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<UnitDetailMessage> {
        let url_ = this.baseUrl + "/unit-detail-message/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUnitDetailMessageControllerUnitDetailMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUnitDetailMessageControllerUnitDetailMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetailMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetailMessage>;
        }));
    }

    protected processGetOneBaseUnitDetailMessageControllerUnitDetailMessage(response: HttpResponseBase): Observable<UnitDetailMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitDetailMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single UnitDetailMessage
     * @return Response
     */
    updateOneBaseUnitDetailMessageControllerUnitDetailMessage(id: number, body: UnitDetailMessage): Observable<UnitDetailMessage> {
        let url_ = this.baseUrl + "/unit-detail-message/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUnitDetailMessageControllerUnitDetailMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUnitDetailMessageControllerUnitDetailMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetailMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetailMessage>;
        }));
    }

    protected processUpdateOneBaseUnitDetailMessageControllerUnitDetailMessage(response: HttpResponseBase): Observable<UnitDetailMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitDetailMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single UnitDetailMessage
     * @return Response
     */
    replaceOneBaseUnitDetailMessageControllerUnitDetailMessage(id: number, body: UnitDetailMessage): Observable<UnitDetailMessage> {
        let url_ = this.baseUrl + "/unit-detail-message/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUnitDetailMessageControllerUnitDetailMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUnitDetailMessageControllerUnitDetailMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetailMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetailMessage>;
        }));
    }

    protected processReplaceOneBaseUnitDetailMessageControllerUnitDetailMessage(response: HttpResponseBase): Observable<UnitDetailMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitDetailMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single UnitDetailMessage
     * @return Delete one base response
     */
    deleteOneBaseUnitDetailMessageControllerUnitDetailMessage(id: number): Observable<void> {
        let url_ = this.baseUrl + "/unit-detail-message/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUnitDetailMessageControllerUnitDetailMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUnitDetailMessageControllerUnitDetailMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseUnitDetailMessageControllerUnitDetailMessage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple UnitDetailMessages
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUnitDetailMessageControllerUnitDetailMessage(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUnitDetailMessageResponseDto> {
        let url_ = this.baseUrl + "/unit-detail-message?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUnitDetailMessageControllerUnitDetailMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUnitDetailMessageControllerUnitDetailMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyUnitDetailMessageResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyUnitDetailMessageResponseDto>;
        }));
    }

    protected processGetManyBaseUnitDetailMessageControllerUnitDetailMessage(response: HttpResponseBase): Observable<GetManyUnitDetailMessageResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUnitDetailMessageResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single UnitDetailMessage
     * @return Get create one base response
     */
    createOneBaseUnitDetailMessageControllerUnitDetailMessage(body: UnitDetailMessage): Observable<UnitDetailMessage> {
        let url_ = this.baseUrl + "/unit-detail-message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUnitDetailMessageControllerUnitDetailMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUnitDetailMessageControllerUnitDetailMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetailMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetailMessage>;
        }));
    }

    protected processCreateOneBaseUnitDetailMessageControllerUnitDetailMessage(response: HttpResponseBase): Observable<UnitDetailMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UnitDetailMessage.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple UnitDetailMessages
     * @return Get create many base response
     */
    createManyBaseUnitDetailMessageControllerUnitDetailMessage(body: CreateManyUnitDetailMessageDto): Observable<UnitDetailMessage[]> {
        let url_ = this.baseUrl + "/unit-detail-message/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUnitDetailMessageControllerUnitDetailMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUnitDetailMessageControllerUnitDetailMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetailMessage[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetailMessage[]>;
        }));
    }

    protected processCreateManyBaseUnitDetailMessageControllerUnitDetailMessage(response: HttpResponseBase): Observable<UnitDetailMessage[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(UnitDetailMessage.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Country
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseCountryControllerCountry(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Country> {
        let url_ = this.baseUrl + "/country/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country>;
        }));
    }

    protected processGetOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Country
     * @return Response
     */
    updateOneBaseCountryControllerCountry(id: number, body: Country): Observable<Country> {
        let url_ = this.baseUrl + "/country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country>;
        }));
    }

    protected processUpdateOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Country
     * @return Response
     */
    replaceOneBaseCountryControllerCountry(id: number, body: Country): Observable<Country> {
        let url_ = this.baseUrl + "/country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country>;
        }));
    }

    protected processReplaceOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Country
     * @return Delete one base response
     */
    deleteOneBaseCountryControllerCountry(id: number): Observable<void> {
        let url_ = this.baseUrl + "/country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Countries
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseCountryControllerCountry(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyCountryResponseDto> {
        let url_ = this.baseUrl + "/country?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyCountryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyCountryResponseDto>;
        }));
    }

    protected processGetManyBaseCountryControllerCountry(response: HttpResponseBase): Observable<GetManyCountryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyCountryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Country
     * @return Get create one base response
     */
    createOneBaseCountryControllerCountry(body: Country): Observable<Country> {
        let url_ = this.baseUrl + "/country";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country>;
        }));
    }

    protected processCreateOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Country.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Countries
     * @return Get create many base response
     */
    createManyBaseCountryControllerCountry(body: CreateManyCountryDto): Observable<Country[]> {
        let url_ = this.baseUrl + "/country/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country[]>;
        }));
    }

    protected processCreateManyBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Country.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ElectricityActivityData
     * @return Get create one base response
     */
    createOneBaseElectricityActivityDataControllerElectricityActivityData(body: ElectricityActivityData): Observable<ElectricityActivityData> {
        let url_ = this.baseUrl + "/electricity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseElectricityActivityDataControllerElectricityActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseElectricityActivityDataControllerElectricityActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElectricityActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElectricityActivityData>;
        }));
    }

    protected processCreateOneBaseElectricityActivityDataControllerElectricityActivityData(response: HttpResponseBase): Observable<ElectricityActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ElectricityActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ElectricityActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseElectricityActivityDataControllerElectricityActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyElectricityActivityDataResponseDto> {
        let url_ = this.baseUrl + "/electricity?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseElectricityActivityDataControllerElectricityActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseElectricityActivityDataControllerElectricityActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyElectricityActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyElectricityActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseElectricityActivityDataControllerElectricityActivityData(response: HttpResponseBase): Observable<GetManyElectricityActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyElectricityActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ElectricityActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseElectricityActivityDataControllerElectricityActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ElectricityActivityData> {
        let url_ = this.baseUrl + "/electricity/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseElectricityActivityDataControllerElectricityActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseElectricityActivityDataControllerElectricityActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElectricityActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElectricityActivityData>;
        }));
    }

    protected processGetOneBaseElectricityActivityDataControllerElectricityActivityData(response: HttpResponseBase): Observable<ElectricityActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElectricityActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ElectricityActivityData
     * @return Response
     */
    updateOneBaseElectricityActivityDataControllerElectricityActivityData(id: number, body: ElectricityActivityData): Observable<ElectricityActivityData> {
        let url_ = this.baseUrl + "/electricity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseElectricityActivityDataControllerElectricityActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseElectricityActivityDataControllerElectricityActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElectricityActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElectricityActivityData>;
        }));
    }

    protected processUpdateOneBaseElectricityActivityDataControllerElectricityActivityData(response: HttpResponseBase): Observable<ElectricityActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElectricityActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ElectricityActivityData
     */
    deleteOneBaseElectricityActivityDataControllerElectricityActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/electricity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseElectricityActivityDataControllerElectricityActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseElectricityActivityDataControllerElectricityActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseElectricityActivityDataControllerElectricityActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ElectricityActivityData
     * @return Response
     */
    replaceOneBaseElectricityActivityDataControllerElectricityActivityData(id: number, body: ElectricityActivityData): Observable<ElectricityActivityData> {
        let url_ = this.baseUrl + "/electricity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseElectricityActivityDataControllerElectricityActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseElectricityActivityDataControllerElectricityActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElectricityActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElectricityActivityData>;
        }));
    }

    protected processReplaceOneBaseElectricityActivityDataControllerElectricityActivityData(response: HttpResponseBase): Observable<ElectricityActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElectricityActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ElectricityActivityData
     * @return Get create many base response
     */
    createManyBaseElectricityActivityDataControllerElectricityActivityData(body: CreateManyElectricityActivityDataDto): Observable<ElectricityActivityData[]> {
        let url_ = this.baseUrl + "/electricity/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseElectricityActivityDataControllerElectricityActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseElectricityActivityDataControllerElectricityActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElectricityActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElectricityActivityData[]>;
        }));
    }

    protected processCreateManyBaseElectricityActivityDataControllerElectricityActivityData(response: HttpResponseBase): Observable<ElectricityActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ElectricityActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Project
     * @return Get create one base response
     */
    createOneBaseProjectControllerProject(body: Project): Observable<Project> {
        let url_ = this.baseUrl + "/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project>;
        }));
    }

    protected processCreateOneBaseProjectControllerProject(response: HttpResponseBase): Observable<Project> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Project.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Projects
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectControllerProject(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectResponseDto> {
        let url_ = this.baseUrl + "/project?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProjectResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProjectResponseDto>;
        }));
    }

    protected processGetManyBaseProjectControllerProject(response: HttpResponseBase): Observable<GetManyProjectResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Project
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectControllerProject(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Project> {
        let url_ = this.baseUrl + "/project/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project>;
        }));
    }

    protected processGetOneBaseProjectControllerProject(response: HttpResponseBase): Observable<Project> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Project
     * @return Response
     */
    updateOneBaseProjectControllerProject(id: number, body: Project): Observable<Project> {
        let url_ = this.baseUrl + "/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project>;
        }));
    }

    protected processUpdateOneBaseProjectControllerProject(response: HttpResponseBase): Observable<Project> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Project
     * @return Response
     */
    replaceOneBaseProjectControllerProject(id: number, body: Project): Observable<Project> {
        let url_ = this.baseUrl + "/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project>;
        }));
    }

    protected processReplaceOneBaseProjectControllerProject(response: HttpResponseBase): Observable<Project> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Project
     * @return Delete one base response
     */
    deleteOneBaseProjectControllerProject(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProjectControllerProject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Projects
     * @return Get create many base response
     */
    createManyBaseProjectControllerProject(body: CreateManyProjectDto): Observable<Project[]> {
        let url_ = this.baseUrl + "/project/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project[]>;
        }));
    }

    protected processCreateManyBaseProjectControllerProject(response: HttpResponseBase): Observable<Project[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Project.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ProjectType
     * @return Get create one base response
     */
    createOneBaseProjectTypeControllerProjectType(body: ProjectType): Observable<ProjectType> {
        let url_ = this.baseUrl + "/Project-type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectTypeControllerProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectTypeControllerProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectType>;
        }));
    }

    protected processCreateOneBaseProjectTypeControllerProjectType(response: HttpResponseBase): Observable<ProjectType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectType.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ProjectTypes
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectTypeControllerProjectType(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectTypeResponseDto> {
        let url_ = this.baseUrl + "/Project-type?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectTypeControllerProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectTypeControllerProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProjectTypeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProjectTypeResponseDto>;
        }));
    }

    protected processGetManyBaseProjectTypeControllerProjectType(response: HttpResponseBase): Observable<GetManyProjectTypeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectTypeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ProjectType
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectTypeControllerProjectType(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectType> {
        let url_ = this.baseUrl + "/Project-type/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectTypeControllerProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectTypeControllerProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectType>;
        }));
    }

    protected processGetOneBaseProjectTypeControllerProjectType(response: HttpResponseBase): Observable<ProjectType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ProjectType
     * @return Response
     */
    updateOneBaseProjectTypeControllerProjectType(id: number, body: ProjectType): Observable<ProjectType> {
        let url_ = this.baseUrl + "/Project-type/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectTypeControllerProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectTypeControllerProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectType>;
        }));
    }

    protected processUpdateOneBaseProjectTypeControllerProjectType(response: HttpResponseBase): Observable<ProjectType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ProjectType
     * @return Response
     */
    replaceOneBaseProjectTypeControllerProjectType(id: number, body: ProjectType): Observable<ProjectType> {
        let url_ = this.baseUrl + "/Project-type/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectTypeControllerProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectTypeControllerProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectType>;
        }));
    }

    protected processReplaceOneBaseProjectTypeControllerProjectType(response: HttpResponseBase): Observable<ProjectType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ProjectType
     * @return Delete one base response
     */
    deleteOneBaseProjectTypeControllerProjectType(id: number): Observable<void> {
        let url_ = this.baseUrl + "/Project-type/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectTypeControllerProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectTypeControllerProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProjectTypeControllerProjectType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ProjectTypes
     * @return Get create many base response
     */
    createManyBaseProjectTypeControllerProjectType(body: CreateManyProjectTypeDto): Observable<ProjectType[]> {
        let url_ = this.baseUrl + "/Project-type/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectTypeControllerProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectTypeControllerProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectType[]>;
        }));
    }

    protected processCreateManyBaseProjectTypeControllerProjectType(response: HttpResponseBase): Observable<ProjectType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectType.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Methodology
     * @return Get create one base response
     */
    createOneBaseMethodologyControllerMethodology(body: Methodology): Observable<Methodology> {
        let url_ = this.baseUrl + "/methodology";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology>;
        }));
    }

    protected processCreateOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Methodology.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Methodologies
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseMethodologyControllerMethodology(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyMethodologyResponseDto> {
        let url_ = this.baseUrl + "/methodology?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyMethodologyResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyMethodologyResponseDto>;
        }));
    }

    protected processGetManyBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<GetManyMethodologyResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyMethodologyResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Methodology
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseMethodologyControllerMethodology(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Methodology> {
        let url_ = this.baseUrl + "/methodology/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology>;
        }));
    }

    protected processGetOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Methodology.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Methodology
     * @return Response
     */
    updateOneBaseMethodologyControllerMethodology(id: number, body: Methodology): Observable<Methodology> {
        let url_ = this.baseUrl + "/methodology/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology>;
        }));
    }

    protected processUpdateOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Methodology.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Methodology
     * @return Response
     */
    replaceOneBaseMethodologyControllerMethodology(id: number, body: Methodology): Observable<Methodology> {
        let url_ = this.baseUrl + "/methodology/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology>;
        }));
    }

    protected processReplaceOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Methodology.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Methodology
     * @return Delete one base response
     */
    deleteOneBaseMethodologyControllerMethodology(id: number): Observable<void> {
        let url_ = this.baseUrl + "/methodology/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Methodologies
     * @return Get create many base response
     */
    createManyBaseMethodologyControllerMethodology(body: CreateManyMethodologyDto): Observable<Methodology[]> {
        let url_ = this.baseUrl + "/methodology/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology[]>;
        }));
    }

    protected processCreateManyBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Methodology.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ProjectUnit
     * @return Get create one base response
     */
    createOneBaseProjectUnitControllerProjectUnit(body: ProjectUnit): Observable<ProjectUnit> {
        let url_ = this.baseUrl + "/project-unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectUnitControllerProjectUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectUnitControllerProjectUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnit>;
        }));
    }

    protected processCreateOneBaseProjectUnitControllerProjectUnit(response: HttpResponseBase): Observable<ProjectUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectUnit.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ProjectUnits
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectUnitControllerProjectUnit(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectUnitResponseDto> {
        let url_ = this.baseUrl + "/project-unit?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectUnitControllerProjectUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectUnitControllerProjectUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProjectUnitResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProjectUnitResponseDto>;
        }));
    }

    protected processGetManyBaseProjectUnitControllerProjectUnit(response: HttpResponseBase): Observable<GetManyProjectUnitResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectUnitResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ProjectUnit
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectUnitControllerProjectUnit(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectUnit> {
        let url_ = this.baseUrl + "/project-unit/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectUnitControllerProjectUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectUnitControllerProjectUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnit>;
        }));
    }

    protected processGetOneBaseProjectUnitControllerProjectUnit(response: HttpResponseBase): Observable<ProjectUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ProjectUnit
     * @return Response
     */
    updateOneBaseProjectUnitControllerProjectUnit(id: number, body: ProjectUnit): Observable<ProjectUnit> {
        let url_ = this.baseUrl + "/project-unit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectUnitControllerProjectUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectUnitControllerProjectUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnit>;
        }));
    }

    protected processUpdateOneBaseProjectUnitControllerProjectUnit(response: HttpResponseBase): Observable<ProjectUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ProjectUnit
     * @return Response
     */
    replaceOneBaseProjectUnitControllerProjectUnit(id: number, body: ProjectUnit): Observable<ProjectUnit> {
        let url_ = this.baseUrl + "/project-unit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectUnitControllerProjectUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectUnitControllerProjectUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnit>;
        }));
    }

    protected processReplaceOneBaseProjectUnitControllerProjectUnit(response: HttpResponseBase): Observable<ProjectUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ProjectUnit
     * @return Delete one base response
     */
    deleteOneBaseProjectUnitControllerProjectUnit(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-unit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectUnitControllerProjectUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectUnitControllerProjectUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProjectUnitControllerProjectUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ProjectUnits
     * @return Get create many base response
     */
    createManyBaseProjectUnitControllerProjectUnit(body: CreateManyProjectUnitDto): Observable<ProjectUnit[]> {
        let url_ = this.baseUrl + "/project-unit/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectUnitControllerProjectUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectUnitControllerProjectUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnit[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnit[]>;
        }));
    }

    protected processCreateManyBaseProjectUnitControllerProjectUnit(response: HttpResponseBase): Observable<ProjectUnit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectUnit.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ProjectUnitEmissionSource
     * @return Get create one base response
     */
    createOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(body: ProjectUnitEmissionSource): Observable<ProjectUnitEmissionSource> {
        let url_ = this.baseUrl + "/project-unit-emission-source";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnitEmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnitEmissionSource>;
        }));
    }

    protected processCreateOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response: HttpResponseBase): Observable<ProjectUnitEmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectUnitEmissionSource.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ProjectUnitEmissionSources
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectUnitEmissionSourceResponseDto> {
        let url_ = this.baseUrl + "/project-unit-emission-source?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProjectUnitEmissionSourceResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProjectUnitEmissionSourceResponseDto>;
        }));
    }

    protected processGetManyBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response: HttpResponseBase): Observable<GetManyProjectUnitEmissionSourceResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectUnitEmissionSourceResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ProjectUnitEmissionSource
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectUnitEmissionSource> {
        let url_ = this.baseUrl + "/project-unit-emission-source/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnitEmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnitEmissionSource>;
        }));
    }

    protected processGetOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response: HttpResponseBase): Observable<ProjectUnitEmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUnitEmissionSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ProjectUnitEmissionSource
     * @return Response
     */
    updateOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(id: number, body: ProjectUnitEmissionSource): Observable<ProjectUnitEmissionSource> {
        let url_ = this.baseUrl + "/project-unit-emission-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnitEmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnitEmissionSource>;
        }));
    }

    protected processUpdateOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response: HttpResponseBase): Observable<ProjectUnitEmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUnitEmissionSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ProjectUnitEmissionSource
     * @return Response
     */
    replaceOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(id: number, body: ProjectUnitEmissionSource): Observable<ProjectUnitEmissionSource> {
        let url_ = this.baseUrl + "/project-unit-emission-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnitEmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnitEmissionSource>;
        }));
    }

    protected processReplaceOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response: HttpResponseBase): Observable<ProjectUnitEmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUnitEmissionSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ProjectUnitEmissionSource
     * @return Delete one base response
     */
    deleteOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-unit-emission-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ProjectUnitEmissionSources
     * @return Get create many base response
     */
    createManyBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(body: CreateManyProjectUnitEmissionSourceDto): Observable<ProjectUnitEmissionSource[]> {
        let url_ = this.baseUrl + "/project-unit-emission-source/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnitEmissionSource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnitEmissionSource[]>;
        }));
    }

    protected processCreateManyBaseProjectUnitEmissionSourceControllerProjectUnitEmissionSource(response: HttpResponseBase): Observable<ProjectUnitEmissionSource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectUnitEmissionSource.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single EmissionSource
     * @return Get create one base response
     */
    createOneBaseEmissionSourceControllerEmissionSource(body: EmissionSource): Observable<EmissionSource> {
        let url_ = this.baseUrl + "/emission-source";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseEmissionSourceControllerEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseEmissionSourceControllerEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionSource>;
        }));
    }

    protected processCreateOneBaseEmissionSourceControllerEmissionSource(response: HttpResponseBase): Observable<EmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EmissionSource.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple EmissionSources
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseEmissionSourceControllerEmissionSource(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyEmissionSourceResponseDto> {
        let url_ = this.baseUrl + "/emission-source?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseEmissionSourceControllerEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseEmissionSourceControllerEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyEmissionSourceResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyEmissionSourceResponseDto>;
        }));
    }

    protected processGetManyBaseEmissionSourceControllerEmissionSource(response: HttpResponseBase): Observable<GetManyEmissionSourceResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyEmissionSourceResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single EmissionSource
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseEmissionSourceControllerEmissionSource(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<EmissionSource> {
        let url_ = this.baseUrl + "/emission-source/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseEmissionSourceControllerEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseEmissionSourceControllerEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionSource>;
        }));
    }

    protected processGetOneBaseEmissionSourceControllerEmissionSource(response: HttpResponseBase): Observable<EmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmissionSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single EmissionSource
     * @return Response
     */
    updateOneBaseEmissionSourceControllerEmissionSource(id: number, body: EmissionSource): Observable<EmissionSource> {
        let url_ = this.baseUrl + "/emission-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseEmissionSourceControllerEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseEmissionSourceControllerEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionSource>;
        }));
    }

    protected processUpdateOneBaseEmissionSourceControllerEmissionSource(response: HttpResponseBase): Observable<EmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmissionSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single EmissionSource
     * @return Delete one base response
     */
    deleteOneBaseEmissionSourceControllerEmissionSource(id: number): Observable<void> {
        let url_ = this.baseUrl + "/emission-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseEmissionSourceControllerEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseEmissionSourceControllerEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseEmissionSourceControllerEmissionSource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single EmissionSource
     * @return Response
     */
    replaceOneBaseEmissionSourceControllerEmissionSource(id: number, body: EmissionSource): Observable<EmissionSource> {
        let url_ = this.baseUrl + "/emission-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseEmissionSourceControllerEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseEmissionSourceControllerEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionSource>;
        }));
    }

    protected processReplaceOneBaseEmissionSourceControllerEmissionSource(response: HttpResponseBase): Observable<EmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmissionSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple EmissionSources
     * @return Get create many base response
     */
    createManyBaseEmissionSourceControllerEmissionSource(body: CreateManyEmissionSourceDto): Observable<EmissionSource[]> {
        let url_ = this.baseUrl + "/emission-source/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseEmissionSourceControllerEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseEmissionSourceControllerEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionSource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionSource[]>;
        }));
    }

    protected processCreateManyBaseEmissionSourceControllerEmissionSource(response: HttpResponseBase): Observable<EmissionSource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(EmissionSource.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ProjectEmissionSource
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectEmissionSourceControllerProjectEmissionSource(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectEmissionSource> {
        let url_ = this.baseUrl + "/project-emission-source/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectEmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectEmissionSource>;
        }));
    }

    protected processGetOneBaseProjectEmissionSourceControllerProjectEmissionSource(response: HttpResponseBase): Observable<ProjectEmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectEmissionSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ProjectEmissionSource
     * @return Response
     */
    updateOneBaseProjectEmissionSourceControllerProjectEmissionSource(id: number, body: ProjectEmissionSource): Observable<ProjectEmissionSource> {
        let url_ = this.baseUrl + "/project-emission-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectEmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectEmissionSource>;
        }));
    }

    protected processUpdateOneBaseProjectEmissionSourceControllerProjectEmissionSource(response: HttpResponseBase): Observable<ProjectEmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectEmissionSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ProjectEmissionSource
     * @return Response
     */
    replaceOneBaseProjectEmissionSourceControllerProjectEmissionSource(id: number, body: ProjectEmissionSource): Observable<ProjectEmissionSource> {
        let url_ = this.baseUrl + "/project-emission-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectEmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectEmissionSource>;
        }));
    }

    protected processReplaceOneBaseProjectEmissionSourceControllerProjectEmissionSource(response: HttpResponseBase): Observable<ProjectEmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectEmissionSource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ProjectEmissionSource
     * @return Delete one base response
     */
    deleteOneBaseProjectEmissionSourceControllerProjectEmissionSource(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-emission-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProjectEmissionSourceControllerProjectEmissionSource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ProjectEmissionSources
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectEmissionSourceControllerProjectEmissionSource(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectEmissionSourceResponseDto> {
        let url_ = this.baseUrl + "/project-emission-source?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectEmissionSourceControllerProjectEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectEmissionSourceControllerProjectEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProjectEmissionSourceResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProjectEmissionSourceResponseDto>;
        }));
    }

    protected processGetManyBaseProjectEmissionSourceControllerProjectEmissionSource(response: HttpResponseBase): Observable<GetManyProjectEmissionSourceResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectEmissionSourceResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ProjectEmissionSource
     * @return Get create one base response
     */
    createOneBaseProjectEmissionSourceControllerProjectEmissionSource(body: ProjectEmissionSource): Observable<ProjectEmissionSource> {
        let url_ = this.baseUrl + "/project-emission-source";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectEmissionSourceControllerProjectEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectEmissionSource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectEmissionSource>;
        }));
    }

    protected processCreateOneBaseProjectEmissionSourceControllerProjectEmissionSource(response: HttpResponseBase): Observable<ProjectEmissionSource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectEmissionSource.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ProjectEmissionSources
     * @return Get create many base response
     */
    createManyBaseProjectEmissionSourceControllerProjectEmissionSource(body: CreateManyProjectEmissionSourceDto): Observable<ProjectEmissionSource[]> {
        let url_ = this.baseUrl + "/project-emission-source/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectEmissionSourceControllerProjectEmissionSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectEmissionSourceControllerProjectEmissionSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectEmissionSource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectEmissionSource[]>;
        }));
    }

    protected processCreateManyBaseProjectEmissionSourceControllerProjectEmissionSource(response: HttpResponseBase): Observable<ProjectEmissionSource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectEmissionSource.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single EsDatasource
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseEsDatasourceControllerEsDatasource(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<EsDatasource> {
        let url_ = this.baseUrl + "/es-datasource/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseEsDatasourceControllerEsDatasource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseEsDatasourceControllerEsDatasource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsDatasource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsDatasource>;
        }));
    }

    protected processGetOneBaseEsDatasourceControllerEsDatasource(response: HttpResponseBase): Observable<EsDatasource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsDatasource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single EsDatasource
     * @return Response
     */
    updateOneBaseEsDatasourceControllerEsDatasource(id: number, body: EsDatasource): Observable<EsDatasource> {
        let url_ = this.baseUrl + "/es-datasource/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseEsDatasourceControllerEsDatasource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseEsDatasourceControllerEsDatasource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsDatasource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsDatasource>;
        }));
    }

    protected processUpdateOneBaseEsDatasourceControllerEsDatasource(response: HttpResponseBase): Observable<EsDatasource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsDatasource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single EsDatasource
     * @return Response
     */
    replaceOneBaseEsDatasourceControllerEsDatasource(id: number, body: EsDatasource): Observable<EsDatasource> {
        let url_ = this.baseUrl + "/es-datasource/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseEsDatasourceControllerEsDatasource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseEsDatasourceControllerEsDatasource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsDatasource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsDatasource>;
        }));
    }

    protected processReplaceOneBaseEsDatasourceControllerEsDatasource(response: HttpResponseBase): Observable<EsDatasource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsDatasource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single EsDatasource
     * @return Delete one base response
     */
    deleteOneBaseEsDatasourceControllerEsDatasource(id: number): Observable<void> {
        let url_ = this.baseUrl + "/es-datasource/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseEsDatasourceControllerEsDatasource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseEsDatasourceControllerEsDatasource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseEsDatasourceControllerEsDatasource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple EsDatasources
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseEsDatasourceControllerEsDatasource(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyEsDatasourceResponseDto> {
        let url_ = this.baseUrl + "/es-datasource?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseEsDatasourceControllerEsDatasource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseEsDatasourceControllerEsDatasource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyEsDatasourceResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyEsDatasourceResponseDto>;
        }));
    }

    protected processGetManyBaseEsDatasourceControllerEsDatasource(response: HttpResponseBase): Observable<GetManyEsDatasourceResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyEsDatasourceResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single EsDatasource
     * @return Get create one base response
     */
    createOneBaseEsDatasourceControllerEsDatasource(body: EsDatasource): Observable<EsDatasource> {
        let url_ = this.baseUrl + "/es-datasource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseEsDatasourceControllerEsDatasource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseEsDatasourceControllerEsDatasource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsDatasource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsDatasource>;
        }));
    }

    protected processCreateOneBaseEsDatasourceControllerEsDatasource(response: HttpResponseBase): Observable<EsDatasource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EsDatasource.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple EsDatasources
     * @return Get create many base response
     */
    createManyBaseEsDatasourceControllerEsDatasource(body: CreateManyEsDatasourceDto): Observable<EsDatasource[]> {
        let url_ = this.baseUrl + "/es-datasource/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseEsDatasourceControllerEsDatasource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseEsDatasourceControllerEsDatasource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsDatasource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsDatasource[]>;
        }));
    }

    protected processCreateManyBaseEsDatasourceControllerEsDatasource(response: HttpResponseBase): Observable<EsDatasource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(EsDatasource.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single EsExcludeReason
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseEsExcludeReasonControllerEsExcludeReason(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<EsExcludeReason> {
        let url_ = this.baseUrl + "/es-exclude-reason/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseEsExcludeReasonControllerEsExcludeReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseEsExcludeReasonControllerEsExcludeReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsExcludeReason>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsExcludeReason>;
        }));
    }

    protected processGetOneBaseEsExcludeReasonControllerEsExcludeReason(response: HttpResponseBase): Observable<EsExcludeReason> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsExcludeReason.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single EsExcludeReason
     * @return Response
     */
    updateOneBaseEsExcludeReasonControllerEsExcludeReason(id: number, body: EsExcludeReason): Observable<EsExcludeReason> {
        let url_ = this.baseUrl + "/es-exclude-reason/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseEsExcludeReasonControllerEsExcludeReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseEsExcludeReasonControllerEsExcludeReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsExcludeReason>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsExcludeReason>;
        }));
    }

    protected processUpdateOneBaseEsExcludeReasonControllerEsExcludeReason(response: HttpResponseBase): Observable<EsExcludeReason> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsExcludeReason.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single EsExcludeReason
     * @return Response
     */
    replaceOneBaseEsExcludeReasonControllerEsExcludeReason(id: number, body: EsExcludeReason): Observable<EsExcludeReason> {
        let url_ = this.baseUrl + "/es-exclude-reason/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseEsExcludeReasonControllerEsExcludeReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseEsExcludeReasonControllerEsExcludeReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsExcludeReason>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsExcludeReason>;
        }));
    }

    protected processReplaceOneBaseEsExcludeReasonControllerEsExcludeReason(response: HttpResponseBase): Observable<EsExcludeReason> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsExcludeReason.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single EsExcludeReason
     * @return Delete one base response
     */
    deleteOneBaseEsExcludeReasonControllerEsExcludeReason(id: number): Observable<void> {
        let url_ = this.baseUrl + "/es-exclude-reason/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseEsExcludeReasonControllerEsExcludeReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseEsExcludeReasonControllerEsExcludeReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseEsExcludeReasonControllerEsExcludeReason(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple EsExcludeReasons
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseEsExcludeReasonControllerEsExcludeReason(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyEsExcludeReasonResponseDto> {
        let url_ = this.baseUrl + "/es-exclude-reason?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseEsExcludeReasonControllerEsExcludeReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseEsExcludeReasonControllerEsExcludeReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyEsExcludeReasonResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyEsExcludeReasonResponseDto>;
        }));
    }

    protected processGetManyBaseEsExcludeReasonControllerEsExcludeReason(response: HttpResponseBase): Observable<GetManyEsExcludeReasonResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyEsExcludeReasonResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single EsExcludeReason
     * @return Get create one base response
     */
    createOneBaseEsExcludeReasonControllerEsExcludeReason(body: EsExcludeReason): Observable<EsExcludeReason> {
        let url_ = this.baseUrl + "/es-exclude-reason";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseEsExcludeReasonControllerEsExcludeReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseEsExcludeReasonControllerEsExcludeReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsExcludeReason>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsExcludeReason>;
        }));
    }

    protected processCreateOneBaseEsExcludeReasonControllerEsExcludeReason(response: HttpResponseBase): Observable<EsExcludeReason> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EsExcludeReason.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple EsExcludeReasons
     * @return Get create many base response
     */
    createManyBaseEsExcludeReasonControllerEsExcludeReason(body: CreateManyEsExcludeReasonDto): Observable<EsExcludeReason[]> {
        let url_ = this.baseUrl + "/es-exclude-reason/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseEsExcludeReasonControllerEsExcludeReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseEsExcludeReasonControllerEsExcludeReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsExcludeReason[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsExcludeReason[]>;
        }));
    }

    protected processCreateManyBaseEsExcludeReasonControllerEsExcludeReason(response: HttpResponseBase): Observable<EsExcludeReason[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(EsExcludeReason.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single EmissionCategory
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseEmissionCategoryControllerEmissionCategory(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<EmissionCategory> {
        let url_ = this.baseUrl + "/emission-category/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseEmissionCategoryControllerEmissionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseEmissionCategoryControllerEmissionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionCategory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionCategory>;
        }));
    }

    protected processGetOneBaseEmissionCategoryControllerEmissionCategory(response: HttpResponseBase): Observable<EmissionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmissionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single EmissionCategory
     * @return Response
     */
    updateOneBaseEmissionCategoryControllerEmissionCategory(id: number, body: EmissionCategory): Observable<EmissionCategory> {
        let url_ = this.baseUrl + "/emission-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseEmissionCategoryControllerEmissionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseEmissionCategoryControllerEmissionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionCategory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionCategory>;
        }));
    }

    protected processUpdateOneBaseEmissionCategoryControllerEmissionCategory(response: HttpResponseBase): Observable<EmissionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmissionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single EmissionCategory
     * @return Response
     */
    replaceOneBaseEmissionCategoryControllerEmissionCategory(id: number, body: EmissionCategory): Observable<EmissionCategory> {
        let url_ = this.baseUrl + "/emission-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseEmissionCategoryControllerEmissionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseEmissionCategoryControllerEmissionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionCategory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionCategory>;
        }));
    }

    protected processReplaceOneBaseEmissionCategoryControllerEmissionCategory(response: HttpResponseBase): Observable<EmissionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmissionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single EmissionCategory
     * @return Delete one base response
     */
    deleteOneBaseEmissionCategoryControllerEmissionCategory(id: number): Observable<void> {
        let url_ = this.baseUrl + "/emission-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseEmissionCategoryControllerEmissionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseEmissionCategoryControllerEmissionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseEmissionCategoryControllerEmissionCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple EmissionCategories
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseEmissionCategoryControllerEmissionCategory(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyEmissionCategoryResponseDto> {
        let url_ = this.baseUrl + "/emission-category?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseEmissionCategoryControllerEmissionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseEmissionCategoryControllerEmissionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyEmissionCategoryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyEmissionCategoryResponseDto>;
        }));
    }

    protected processGetManyBaseEmissionCategoryControllerEmissionCategory(response: HttpResponseBase): Observable<GetManyEmissionCategoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyEmissionCategoryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single EmissionCategory
     * @return Get create one base response
     */
    createOneBaseEmissionCategoryControllerEmissionCategory(body: EmissionCategory): Observable<EmissionCategory> {
        let url_ = this.baseUrl + "/emission-category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseEmissionCategoryControllerEmissionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseEmissionCategoryControllerEmissionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionCategory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionCategory>;
        }));
    }

    protected processCreateOneBaseEmissionCategoryControllerEmissionCategory(response: HttpResponseBase): Observable<EmissionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EmissionCategory.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple EmissionCategories
     * @return Get create many base response
     */
    createManyBaseEmissionCategoryControllerEmissionCategory(body: CreateManyEmissionCategoryDto): Observable<EmissionCategory[]> {
        let url_ = this.baseUrl + "/emission-category/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseEmissionCategoryControllerEmissionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseEmissionCategoryControllerEmissionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionCategory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionCategory[]>;
        }));
    }

    protected processCreateManyBaseEmissionCategoryControllerEmissionCategory(response: HttpResponseBase): Observable<EmissionCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(EmissionCategory.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single TNDLossActivityData
     * @return Get create one base response
     */
    createOneBaseTNDLossActivityDataControllerTNDLossActivityData(body: TNDLossActivityData): Observable<TNDLossActivityData> {
        let url_ = this.baseUrl + "/t-n-d-loss";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TNDLossActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TNDLossActivityData>;
        }));
    }

    protected processCreateOneBaseTNDLossActivityDataControllerTNDLossActivityData(response: HttpResponseBase): Observable<TNDLossActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TNDLossActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple TNDLossActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseTNDLossActivityDataControllerTNDLossActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyTNDLossActivityDataResponseDto> {
        let url_ = this.baseUrl + "/t-n-d-loss?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseTNDLossActivityDataControllerTNDLossActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseTNDLossActivityDataControllerTNDLossActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyTNDLossActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyTNDLossActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseTNDLossActivityDataControllerTNDLossActivityData(response: HttpResponseBase): Observable<GetManyTNDLossActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyTNDLossActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single TNDLossActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseTNDLossActivityDataControllerTNDLossActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<TNDLossActivityData> {
        let url_ = this.baseUrl + "/t-n-d-loss/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TNDLossActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TNDLossActivityData>;
        }));
    }

    protected processGetOneBaseTNDLossActivityDataControllerTNDLossActivityData(response: HttpResponseBase): Observable<TNDLossActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TNDLossActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single TNDLossActivityData
     * @return Response
     */
    updateOneBaseTNDLossActivityDataControllerTNDLossActivityData(id: number, body: TNDLossActivityData): Observable<TNDLossActivityData> {
        let url_ = this.baseUrl + "/t-n-d-loss/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TNDLossActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TNDLossActivityData>;
        }));
    }

    protected processUpdateOneBaseTNDLossActivityDataControllerTNDLossActivityData(response: HttpResponseBase): Observable<TNDLossActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TNDLossActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single TNDLossActivityData
     */
    deleteOneBaseTNDLossActivityDataControllerTNDLossActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/t-n-d-loss/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseTNDLossActivityDataControllerTNDLossActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single TNDLossActivityData
     * @return Response
     */
    replaceOneBaseTNDLossActivityDataControllerTNDLossActivityData(id: number, body: TNDLossActivityData): Observable<TNDLossActivityData> {
        let url_ = this.baseUrl + "/t-n-d-loss/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseTNDLossActivityDataControllerTNDLossActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TNDLossActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TNDLossActivityData>;
        }));
    }

    protected processReplaceOneBaseTNDLossActivityDataControllerTNDLossActivityData(response: HttpResponseBase): Observable<TNDLossActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TNDLossActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple TNDLossActivityData
     * @return Get create many base response
     */
    createManyBaseTNDLossActivityDataControllerTNDLossActivityData(body: CreateManyTNDLossActivityDataDto): Observable<TNDLossActivityData[]> {
        let url_ = this.baseUrl + "/t-n-d-loss/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseTNDLossActivityDataControllerTNDLossActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseTNDLossActivityDataControllerTNDLossActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TNDLossActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TNDLossActivityData[]>;
        }));
    }

    protected processCreateManyBaseTNDLossActivityDataControllerTNDLossActivityData(response: HttpResponseBase): Observable<TNDLossActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(TNDLossActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single GeneratorActivityData
     * @return Get create one base response
     */
    createOneBaseGeneratorActivityDataControllerGeneratorActivityData(body: GeneratorActivityData): Observable<GeneratorActivityData> {
        let url_ = this.baseUrl + "/generator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneratorActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneratorActivityData>;
        }));
    }

    protected processCreateOneBaseGeneratorActivityDataControllerGeneratorActivityData(response: HttpResponseBase): Observable<GeneratorActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GeneratorActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple GeneratorActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseGeneratorActivityDataControllerGeneratorActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyGeneratorActivityDataResponseDto> {
        let url_ = this.baseUrl + "/generator?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseGeneratorActivityDataControllerGeneratorActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseGeneratorActivityDataControllerGeneratorActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyGeneratorActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyGeneratorActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseGeneratorActivityDataControllerGeneratorActivityData(response: HttpResponseBase): Observable<GetManyGeneratorActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyGeneratorActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single GeneratorActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseGeneratorActivityDataControllerGeneratorActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<GeneratorActivityData> {
        let url_ = this.baseUrl + "/generator/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneratorActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneratorActivityData>;
        }));
    }

    protected processGetOneBaseGeneratorActivityDataControllerGeneratorActivityData(response: HttpResponseBase): Observable<GeneratorActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneratorActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single GeneratorActivityData
     * @return Response
     */
    updateOneBaseGeneratorActivityDataControllerGeneratorActivityData(id: number, body: GeneratorActivityData): Observable<GeneratorActivityData> {
        let url_ = this.baseUrl + "/generator/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneratorActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneratorActivityData>;
        }));
    }

    protected processUpdateOneBaseGeneratorActivityDataControllerGeneratorActivityData(response: HttpResponseBase): Observable<GeneratorActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneratorActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single GeneratorActivityData
     */
    deleteOneBaseGeneratorActivityDataControllerGeneratorActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/generator/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseGeneratorActivityDataControllerGeneratorActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single GeneratorActivityData
     * @return Response
     */
    replaceOneBaseGeneratorActivityDataControllerGeneratorActivityData(id: number, body: GeneratorActivityData): Observable<GeneratorActivityData> {
        let url_ = this.baseUrl + "/generator/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseGeneratorActivityDataControllerGeneratorActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneratorActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneratorActivityData>;
        }));
    }

    protected processReplaceOneBaseGeneratorActivityDataControllerGeneratorActivityData(response: HttpResponseBase): Observable<GeneratorActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneratorActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple GeneratorActivityData
     * @return Get create many base response
     */
    createManyBaseGeneratorActivityDataControllerGeneratorActivityData(body: CreateManyGeneratorActivityDataDto): Observable<GeneratorActivityData[]> {
        let url_ = this.baseUrl + "/generator/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseGeneratorActivityDataControllerGeneratorActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseGeneratorActivityDataControllerGeneratorActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneratorActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneratorActivityData[]>;
        }));
    }

    protected processCreateManyBaseGeneratorActivityDataControllerGeneratorActivityData(response: HttpResponseBase): Observable<GeneratorActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(GeneratorActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single FireExtinguisherActivityData
     * @return Get create one base response
     */
    createOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(body: FireExtinguisherActivityData): Observable<FireExtinguisherActivityData> {
        let url_ = this.baseUrl + "/fire-extinguisher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FireExtinguisherActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FireExtinguisherActivityData>;
        }));
    }

    protected processCreateOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response: HttpResponseBase): Observable<FireExtinguisherActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FireExtinguisherActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple FireExtinguisherActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFireExtinguisherActivityDataResponseDto> {
        let url_ = this.baseUrl + "/fire-extinguisher?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyFireExtinguisherActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyFireExtinguisherActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response: HttpResponseBase): Observable<GetManyFireExtinguisherActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFireExtinguisherActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single FireExtinguisherActivityData
     * @return Response
     */
    updateOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(id: number, body: FireExtinguisherActivityData): Observable<FireExtinguisherActivityData> {
        let url_ = this.baseUrl + "/fire-extinguisher/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FireExtinguisherActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FireExtinguisherActivityData>;
        }));
    }

    protected processUpdateOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response: HttpResponseBase): Observable<FireExtinguisherActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FireExtinguisherActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single FireExtinguisherActivityData
     */
    deleteOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/fire-extinguisher/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single FireExtinguisherActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FireExtinguisherActivityData> {
        let url_ = this.baseUrl + "/fire-extinguisher/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FireExtinguisherActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FireExtinguisherActivityData>;
        }));
    }

    protected processGetOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response: HttpResponseBase): Observable<FireExtinguisherActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FireExtinguisherActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single FireExtinguisherActivityData
     * @return Response
     */
    replaceOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(id: number, body: FireExtinguisherActivityData): Observable<FireExtinguisherActivityData> {
        let url_ = this.baseUrl + "/fire-extinguisher/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FireExtinguisherActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FireExtinguisherActivityData>;
        }));
    }

    protected processReplaceOneBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response: HttpResponseBase): Observable<FireExtinguisherActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FireExtinguisherActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple FireExtinguisherActivityData
     * @return Get create many base response
     */
    createManyBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(body: CreateManyFireExtinguisherActivityDataDto): Observable<FireExtinguisherActivityData[]> {
        let url_ = this.baseUrl + "/fire-extinguisher/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FireExtinguisherActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FireExtinguisherActivityData[]>;
        }));
    }

    protected processCreateManyBaseFireExtinguisherActivityDataControllerFireExtinguisherActivityData(response: HttpResponseBase): Observable<FireExtinguisherActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FireExtinguisherActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single RefrigerantActivityData
     * @return Get create one base response
     */
    createOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(body: RefrigerantActivityData): Observable<RefrigerantActivityData> {
        let url_ = this.baseUrl + "/refrigerant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefrigerantActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefrigerantActivityData>;
        }));
    }

    protected processCreateOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response: HttpResponseBase): Observable<RefrigerantActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RefrigerantActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple RefrigerantActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseRefrigerantActivityDataControllerRefrigerantActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyRefrigerantActivityDataResponseDto> {
        let url_ = this.baseUrl + "/refrigerant?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyRefrigerantActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyRefrigerantActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseRefrigerantActivityDataControllerRefrigerantActivityData(response: HttpResponseBase): Observable<GetManyRefrigerantActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyRefrigerantActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single RefrigerantActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<RefrigerantActivityData> {
        let url_ = this.baseUrl + "/refrigerant/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefrigerantActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefrigerantActivityData>;
        }));
    }

    protected processGetOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response: HttpResponseBase): Observable<RefrigerantActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefrigerantActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single RefrigerantActivityData
     * @return Response
     */
    updateOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(id: number, body: RefrigerantActivityData): Observable<RefrigerantActivityData> {
        let url_ = this.baseUrl + "/refrigerant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefrigerantActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefrigerantActivityData>;
        }));
    }

    protected processUpdateOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response: HttpResponseBase): Observable<RefrigerantActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefrigerantActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single RefrigerantActivityData
     * @return Response
     */
    replaceOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(id: number, body: RefrigerantActivityData): Observable<RefrigerantActivityData> {
        let url_ = this.baseUrl + "/refrigerant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefrigerantActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefrigerantActivityData>;
        }));
    }

    protected processReplaceOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response: HttpResponseBase): Observable<RefrigerantActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefrigerantActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single RefrigerantActivityData
     */
    deleteOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/refrigerant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseRefrigerantActivityDataControllerRefrigerantActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple RefrigerantActivityData
     * @return Get create many base response
     */
    createManyBaseRefrigerantActivityDataControllerRefrigerantActivityData(body: CreateManyRefrigerantActivityDataDto): Observable<RefrigerantActivityData[]> {
        let url_ = this.baseUrl + "/refrigerant/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseRefrigerantActivityDataControllerRefrigerantActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefrigerantActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefrigerantActivityData[]>;
        }));
    }

    protected processCreateManyBaseRefrigerantActivityDataControllerRefrigerantActivityData(response: HttpResponseBase): Observable<RefrigerantActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(RefrigerantActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single WeldingEsActivityData
     * @return Get create one base response
     */
    createOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(body: WeldingEsActivityData): Observable<WeldingEsActivityData> {
        let url_ = this.baseUrl + "/welding-es";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeldingEsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeldingEsActivityData>;
        }));
    }

    protected processCreateOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response: HttpResponseBase): Observable<WeldingEsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WeldingEsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple WeldingEsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseWeldingEsActivityDataControllerWeldingEsActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyWeldingEsActivityDataResponseDto> {
        let url_ = this.baseUrl + "/welding-es?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyWeldingEsActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyWeldingEsActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseWeldingEsActivityDataControllerWeldingEsActivityData(response: HttpResponseBase): Observable<GetManyWeldingEsActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyWeldingEsActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single WeldingEsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<WeldingEsActivityData> {
        let url_ = this.baseUrl + "/welding-es/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeldingEsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeldingEsActivityData>;
        }));
    }

    protected processGetOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response: HttpResponseBase): Observable<WeldingEsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeldingEsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single WeldingEsActivityData
     * @return Response
     */
    updateOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(id: number, body: WeldingEsActivityData): Observable<WeldingEsActivityData> {
        let url_ = this.baseUrl + "/welding-es/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeldingEsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeldingEsActivityData>;
        }));
    }

    protected processUpdateOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response: HttpResponseBase): Observable<WeldingEsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeldingEsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single WeldingEsActivityData
     */
    deleteOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/welding-es/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single WeldingEsActivityData
     * @return Response
     */
    replaceOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(id: number, body: WeldingEsActivityData): Observable<WeldingEsActivityData> {
        let url_ = this.baseUrl + "/welding-es/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeldingEsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeldingEsActivityData>;
        }));
    }

    protected processReplaceOneBaseWeldingEsActivityDataControllerWeldingEsActivityData(response: HttpResponseBase): Observable<WeldingEsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeldingEsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple WeldingEsActivityData
     * @return Get create many base response
     */
    createManyBaseWeldingEsActivityDataControllerWeldingEsActivityData(body: CreateManyWeldingEsActivityDataDto): Observable<WeldingEsActivityData[]> {
        let url_ = this.baseUrl + "/welding-es/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseWeldingEsActivityDataControllerWeldingEsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeldingEsActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeldingEsActivityData[]>;
        }));
    }

    protected processCreateManyBaseWeldingEsActivityDataControllerWeldingEsActivityData(response: HttpResponseBase): Observable<WeldingEsActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(WeldingEsActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ForkliftsActivityData
     * @return Get create one base response
     */
    createOneBaseForkliftsActivityDataControllerForkliftsActivityData(body: ForkliftsActivityData): Observable<ForkliftsActivityData> {
        let url_ = this.baseUrl + "/forklifts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForkliftsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForkliftsActivityData>;
        }));
    }

    protected processCreateOneBaseForkliftsActivityDataControllerForkliftsActivityData(response: HttpResponseBase): Observable<ForkliftsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ForkliftsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ForkliftsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseForkliftsActivityDataControllerForkliftsActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyForkliftsActivityDataResponseDto> {
        let url_ = this.baseUrl + "/forklifts?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseForkliftsActivityDataControllerForkliftsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseForkliftsActivityDataControllerForkliftsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyForkliftsActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyForkliftsActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseForkliftsActivityDataControllerForkliftsActivityData(response: HttpResponseBase): Observable<GetManyForkliftsActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyForkliftsActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ForkliftsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseForkliftsActivityDataControllerForkliftsActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ForkliftsActivityData> {
        let url_ = this.baseUrl + "/forklifts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForkliftsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForkliftsActivityData>;
        }));
    }

    protected processGetOneBaseForkliftsActivityDataControllerForkliftsActivityData(response: HttpResponseBase): Observable<ForkliftsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForkliftsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ForkliftsActivityData
     * @return Response
     */
    updateOneBaseForkliftsActivityDataControllerForkliftsActivityData(id: number, body: ForkliftsActivityData): Observable<ForkliftsActivityData> {
        let url_ = this.baseUrl + "/forklifts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForkliftsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForkliftsActivityData>;
        }));
    }

    protected processUpdateOneBaseForkliftsActivityDataControllerForkliftsActivityData(response: HttpResponseBase): Observable<ForkliftsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForkliftsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ForkliftsActivityData
     * @return Response
     */
    replaceOneBaseForkliftsActivityDataControllerForkliftsActivityData(id: number, body: ForkliftsActivityData): Observable<ForkliftsActivityData> {
        let url_ = this.baseUrl + "/forklifts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForkliftsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForkliftsActivityData>;
        }));
    }

    protected processReplaceOneBaseForkliftsActivityDataControllerForkliftsActivityData(response: HttpResponseBase): Observable<ForkliftsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForkliftsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ForkliftsActivityData
     * @return Delete one base response
     */
    deleteOneBaseForkliftsActivityDataControllerForkliftsActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/forklifts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseForkliftsActivityDataControllerForkliftsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseForkliftsActivityDataControllerForkliftsActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ForkliftsActivityData
     * @return Get create many base response
     */
    createManyBaseForkliftsActivityDataControllerForkliftsActivityData(body: CreateManyForkliftsActivityDataDto): Observable<ForkliftsActivityData[]> {
        let url_ = this.baseUrl + "/forklifts/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseForkliftsActivityDataControllerForkliftsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseForkliftsActivityDataControllerForkliftsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForkliftsActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForkliftsActivityData[]>;
        }));
    }

    protected processCreateManyBaseForkliftsActivityDataControllerForkliftsActivityData(response: HttpResponseBase): Observable<ForkliftsActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ForkliftsActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single BoilerActivityData
     * @return Get create one base response
     */
    createOneBaseBoilerActivityDataControllerBoilerActivityData(body: BoilerActivityData): Observable<BoilerActivityData> {
        let url_ = this.baseUrl + "/boiler";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseBoilerActivityDataControllerBoilerActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseBoilerActivityDataControllerBoilerActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoilerActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoilerActivityData>;
        }));
    }

    protected processCreateOneBaseBoilerActivityDataControllerBoilerActivityData(response: HttpResponseBase): Observable<BoilerActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = BoilerActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple BoilerActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseBoilerActivityDataControllerBoilerActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyBoilerActivityDataResponseDto> {
        let url_ = this.baseUrl + "/boiler?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseBoilerActivityDataControllerBoilerActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseBoilerActivityDataControllerBoilerActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyBoilerActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyBoilerActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseBoilerActivityDataControllerBoilerActivityData(response: HttpResponseBase): Observable<GetManyBoilerActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyBoilerActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single BoilerActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseBoilerActivityDataControllerBoilerActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<BoilerActivityData> {
        let url_ = this.baseUrl + "/boiler/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseBoilerActivityDataControllerBoilerActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseBoilerActivityDataControllerBoilerActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoilerActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoilerActivityData>;
        }));
    }

    protected processGetOneBaseBoilerActivityDataControllerBoilerActivityData(response: HttpResponseBase): Observable<BoilerActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoilerActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single BoilerActivityData
     * @return Response
     */
    updateOneBaseBoilerActivityDataControllerBoilerActivityData(id: number, body: BoilerActivityData): Observable<BoilerActivityData> {
        let url_ = this.baseUrl + "/boiler/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseBoilerActivityDataControllerBoilerActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseBoilerActivityDataControllerBoilerActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoilerActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoilerActivityData>;
        }));
    }

    protected processUpdateOneBaseBoilerActivityDataControllerBoilerActivityData(response: HttpResponseBase): Observable<BoilerActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoilerActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single BoilerActivityData
     */
    deleteOneBaseBoilerActivityDataControllerBoilerActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/boiler/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseBoilerActivityDataControllerBoilerActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseBoilerActivityDataControllerBoilerActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseBoilerActivityDataControllerBoilerActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single BoilerActivityData
     * @return Response
     */
    replaceOneBaseBoilerActivityDataControllerBoilerActivityData(id: number, body: BoilerActivityData): Observable<BoilerActivityData> {
        let url_ = this.baseUrl + "/boiler/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseBoilerActivityDataControllerBoilerActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseBoilerActivityDataControllerBoilerActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoilerActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoilerActivityData>;
        }));
    }

    protected processReplaceOneBaseBoilerActivityDataControllerBoilerActivityData(response: HttpResponseBase): Observable<BoilerActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoilerActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple BoilerActivityData
     * @return Get create many base response
     */
    createManyBaseBoilerActivityDataControllerBoilerActivityData(body: CreateManyBoilerActivityDataDto): Observable<BoilerActivityData[]> {
        let url_ = this.baseUrl + "/boiler/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseBoilerActivityDataControllerBoilerActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseBoilerActivityDataControllerBoilerActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoilerActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoilerActivityData[]>;
        }));
    }

    protected processCreateManyBaseBoilerActivityDataControllerBoilerActivityData(response: HttpResponseBase): Observable<BoilerActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(BoilerActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single WasteWaterTreatmentActivityData
     * @return Get create one base response
     */
    createOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(body: WasteWaterTreatmentActivityData): Observable<WasteWaterTreatmentActivityData> {
        let url_ = this.baseUrl + "/waste-water-treatment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteWaterTreatmentActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteWaterTreatmentActivityData>;
        }));
    }

    protected processCreateOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response: HttpResponseBase): Observable<WasteWaterTreatmentActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WasteWaterTreatmentActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple WasteWaterTreatmentActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyWasteWaterTreatmentActivityDataResponseDto> {
        let url_ = this.baseUrl + "/waste-water-treatment?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyWasteWaterTreatmentActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyWasteWaterTreatmentActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response: HttpResponseBase): Observable<GetManyWasteWaterTreatmentActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyWasteWaterTreatmentActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single WasteWaterTreatmentActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<WasteWaterTreatmentActivityData> {
        let url_ = this.baseUrl + "/waste-water-treatment/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteWaterTreatmentActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteWaterTreatmentActivityData>;
        }));
    }

    protected processGetOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response: HttpResponseBase): Observable<WasteWaterTreatmentActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WasteWaterTreatmentActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single WasteWaterTreatmentActivityData
     * @return Response
     */
    updateOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(id: number, body: WasteWaterTreatmentActivityData): Observable<WasteWaterTreatmentActivityData> {
        let url_ = this.baseUrl + "/waste-water-treatment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteWaterTreatmentActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteWaterTreatmentActivityData>;
        }));
    }

    protected processUpdateOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response: HttpResponseBase): Observable<WasteWaterTreatmentActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WasteWaterTreatmentActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single WasteWaterTreatmentActivityData
     */
    deleteOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/waste-water-treatment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single WasteWaterTreatmentActivityData
     * @return Response
     */
    replaceOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(id: number, body: WasteWaterTreatmentActivityData): Observable<WasteWaterTreatmentActivityData> {
        let url_ = this.baseUrl + "/waste-water-treatment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteWaterTreatmentActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteWaterTreatmentActivityData>;
        }));
    }

    protected processReplaceOneBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response: HttpResponseBase): Observable<WasteWaterTreatmentActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WasteWaterTreatmentActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple WasteWaterTreatmentActivityData
     * @return Get create many base response
     */
    createManyBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(body: CreateManyWasteWaterTreatmentActivityDataDto): Observable<WasteWaterTreatmentActivityData[]> {
        let url_ = this.baseUrl + "/waste-water-treatment/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteWaterTreatmentActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteWaterTreatmentActivityData[]>;
        }));
    }

    protected processCreateManyBaseWasteWaterTreatmentActivityDataControllerWasteWaterTreatmentActivityData(response: HttpResponseBase): Observable<WasteWaterTreatmentActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(WasteWaterTreatmentActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single MunicipalWaterActivityData
     * @return Get create one base response
     */
    createOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(body: MunicipalWaterActivityData): Observable<MunicipalWaterActivityData> {
        let url_ = this.baseUrl + "/municipal-water";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MunicipalWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MunicipalWaterActivityData>;
        }));
    }

    protected processCreateOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response: HttpResponseBase): Observable<MunicipalWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MunicipalWaterActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple MunicipalWaterActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyMunicipalWaterActivityDataResponseDto> {
        let url_ = this.baseUrl + "/municipal-water?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyMunicipalWaterActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyMunicipalWaterActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response: HttpResponseBase): Observable<GetManyMunicipalWaterActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyMunicipalWaterActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single MunicipalWaterActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<MunicipalWaterActivityData> {
        let url_ = this.baseUrl + "/municipal-water/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MunicipalWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MunicipalWaterActivityData>;
        }));
    }

    protected processGetOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response: HttpResponseBase): Observable<MunicipalWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MunicipalWaterActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single MunicipalWaterActivityData
     * @return Response
     */
    updateOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(id: number, body: MunicipalWaterActivityData): Observable<MunicipalWaterActivityData> {
        let url_ = this.baseUrl + "/municipal-water/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MunicipalWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MunicipalWaterActivityData>;
        }));
    }

    protected processUpdateOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response: HttpResponseBase): Observable<MunicipalWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MunicipalWaterActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single MunicipalWaterActivityData
     */
    deleteOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/municipal-water/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single MunicipalWaterActivityData
     * @return Response
     */
    replaceOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(id: number, body: MunicipalWaterActivityData): Observable<MunicipalWaterActivityData> {
        let url_ = this.baseUrl + "/municipal-water/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MunicipalWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MunicipalWaterActivityData>;
        }));
    }

    protected processReplaceOneBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response: HttpResponseBase): Observable<MunicipalWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MunicipalWaterActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple MunicipalWaterActivityData
     * @return Get create many base response
     */
    createManyBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(body: CreateManyMunicipalWaterActivityDataDto): Observable<MunicipalWaterActivityData[]> {
        let url_ = this.baseUrl + "/municipal-water/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MunicipalWaterActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MunicipalWaterActivityData[]>;
        }));
    }

    protected processCreateManyBaseMunicipalWaterActivityDataControllerMunicipalWaterActivityData(response: HttpResponseBase): Observable<MunicipalWaterActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(MunicipalWaterActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single EvidenceRequest
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseEvidenceRequestControllerEvidenceRequest(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<EvidenceRequest> {
        let url_ = this.baseUrl + "/evidence-request/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseEvidenceRequestControllerEvidenceRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseEvidenceRequestControllerEvidenceRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceRequest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceRequest>;
        }));
    }

    protected processGetOneBaseEvidenceRequestControllerEvidenceRequest(response: HttpResponseBase): Observable<EvidenceRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvidenceRequest.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single EvidenceRequest
     * @return Response
     */
    updateOneBaseEvidenceRequestControllerEvidenceRequest(id: number, body: EvidenceRequest): Observable<EvidenceRequest> {
        let url_ = this.baseUrl + "/evidence-request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseEvidenceRequestControllerEvidenceRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseEvidenceRequestControllerEvidenceRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceRequest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceRequest>;
        }));
    }

    protected processUpdateOneBaseEvidenceRequestControllerEvidenceRequest(response: HttpResponseBase): Observable<EvidenceRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvidenceRequest.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single EvidenceRequest
     * @return Response
     */
    replaceOneBaseEvidenceRequestControllerEvidenceRequest(id: number, body: EvidenceRequest): Observable<EvidenceRequest> {
        let url_ = this.baseUrl + "/evidence-request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseEvidenceRequestControllerEvidenceRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseEvidenceRequestControllerEvidenceRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceRequest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceRequest>;
        }));
    }

    protected processReplaceOneBaseEvidenceRequestControllerEvidenceRequest(response: HttpResponseBase): Observable<EvidenceRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvidenceRequest.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single EvidenceRequest
     * @return Delete one base response
     */
    deleteOneBaseEvidenceRequestControllerEvidenceRequest(id: number): Observable<void> {
        let url_ = this.baseUrl + "/evidence-request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseEvidenceRequestControllerEvidenceRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseEvidenceRequestControllerEvidenceRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseEvidenceRequestControllerEvidenceRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple EvidenceRequests
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseEvidenceRequestControllerEvidenceRequest(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyEvidenceRequestResponseDto> {
        let url_ = this.baseUrl + "/evidence-request?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseEvidenceRequestControllerEvidenceRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseEvidenceRequestControllerEvidenceRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyEvidenceRequestResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyEvidenceRequestResponseDto>;
        }));
    }

    protected processGetManyBaseEvidenceRequestControllerEvidenceRequest(response: HttpResponseBase): Observable<GetManyEvidenceRequestResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyEvidenceRequestResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single EvidenceRequest
     * @return Get create one base response
     */
    createOneBaseEvidenceRequestControllerEvidenceRequest(body: EvidenceRequest): Observable<EvidenceRequest> {
        let url_ = this.baseUrl + "/evidence-request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseEvidenceRequestControllerEvidenceRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseEvidenceRequestControllerEvidenceRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceRequest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceRequest>;
        }));
    }

    protected processCreateOneBaseEvidenceRequestControllerEvidenceRequest(response: HttpResponseBase): Observable<EvidenceRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EvidenceRequest.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple EvidenceRequests
     * @return Get create many base response
     */
    createManyBaseEvidenceRequestControllerEvidenceRequest(body: CreateManyEvidenceRequestDto): Observable<EvidenceRequest[]> {
        let url_ = this.baseUrl + "/evidence-request/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseEvidenceRequestControllerEvidenceRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseEvidenceRequestControllerEvidenceRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceRequest[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceRequest[]>;
        }));
    }

    protected processCreateManyBaseEvidenceRequestControllerEvidenceRequest(response: HttpResponseBase): Observable<EvidenceRequest[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(EvidenceRequest.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single EvidenceDocument
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseEvidenceDocumentControllerEvidenceDocument(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<EvidenceDocument> {
        let url_ = this.baseUrl + "/evidence-document/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseEvidenceDocumentControllerEvidenceDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseEvidenceDocumentControllerEvidenceDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceDocument>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceDocument>;
        }));
    }

    protected processGetOneBaseEvidenceDocumentControllerEvidenceDocument(response: HttpResponseBase): Observable<EvidenceDocument> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvidenceDocument.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single EvidenceDocument
     * @return Response
     */
    updateOneBaseEvidenceDocumentControllerEvidenceDocument(id: number, body: EvidenceDocument): Observable<EvidenceDocument> {
        let url_ = this.baseUrl + "/evidence-document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseEvidenceDocumentControllerEvidenceDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseEvidenceDocumentControllerEvidenceDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceDocument>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceDocument>;
        }));
    }

    protected processUpdateOneBaseEvidenceDocumentControllerEvidenceDocument(response: HttpResponseBase): Observable<EvidenceDocument> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvidenceDocument.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single EvidenceDocument
     * @return Response
     */
    replaceOneBaseEvidenceDocumentControllerEvidenceDocument(id: number, body: EvidenceDocument): Observable<EvidenceDocument> {
        let url_ = this.baseUrl + "/evidence-document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseEvidenceDocumentControllerEvidenceDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseEvidenceDocumentControllerEvidenceDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceDocument>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceDocument>;
        }));
    }

    protected processReplaceOneBaseEvidenceDocumentControllerEvidenceDocument(response: HttpResponseBase): Observable<EvidenceDocument> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvidenceDocument.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single EvidenceDocument
     * @return Delete one base response
     */
    deleteOneBaseEvidenceDocumentControllerEvidenceDocument(id: number): Observable<void> {
        let url_ = this.baseUrl + "/evidence-document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseEvidenceDocumentControllerEvidenceDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseEvidenceDocumentControllerEvidenceDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseEvidenceDocumentControllerEvidenceDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple EvidenceDocuments
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseEvidenceDocumentControllerEvidenceDocument(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyEvidenceDocumentResponseDto> {
        let url_ = this.baseUrl + "/evidence-document?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseEvidenceDocumentControllerEvidenceDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseEvidenceDocumentControllerEvidenceDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyEvidenceDocumentResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyEvidenceDocumentResponseDto>;
        }));
    }

    protected processGetManyBaseEvidenceDocumentControllerEvidenceDocument(response: HttpResponseBase): Observable<GetManyEvidenceDocumentResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyEvidenceDocumentResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single EvidenceDocument
     * @return Get create one base response
     */
    createOneBaseEvidenceDocumentControllerEvidenceDocument(body: EvidenceDocument): Observable<EvidenceDocument> {
        let url_ = this.baseUrl + "/evidence-document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseEvidenceDocumentControllerEvidenceDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseEvidenceDocumentControllerEvidenceDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceDocument>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceDocument>;
        }));
    }

    protected processCreateOneBaseEvidenceDocumentControllerEvidenceDocument(response: HttpResponseBase): Observable<EvidenceDocument> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EvidenceDocument.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple EvidenceDocuments
     * @return Get create many base response
     */
    createManyBaseEvidenceDocumentControllerEvidenceDocument(body: CreateManyEvidenceDocumentDto): Observable<EvidenceDocument[]> {
        let url_ = this.baseUrl + "/evidence-document/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseEvidenceDocumentControllerEvidenceDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseEvidenceDocumentControllerEvidenceDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceDocument[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceDocument[]>;
        }));
    }

    protected processCreateManyBaseEvidenceDocumentControllerEvidenceDocument(response: HttpResponseBase): Observable<EvidenceDocument[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(EvidenceDocument.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single WasteDisposalActivityData
     * @return Get create one base response
     */
    createOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(body: WasteDisposalActivityData): Observable<WasteDisposalActivityData> {
        let url_ = this.baseUrl + "/waste-disposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteDisposalActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteDisposalActivityData>;
        }));
    }

    protected processCreateOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response: HttpResponseBase): Observable<WasteDisposalActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WasteDisposalActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple WasteDisposalActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyWasteDisposalActivityDataResponseDto> {
        let url_ = this.baseUrl + "/waste-disposal?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyWasteDisposalActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyWasteDisposalActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response: HttpResponseBase): Observable<GetManyWasteDisposalActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyWasteDisposalActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single WasteDisposalActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<WasteDisposalActivityData> {
        let url_ = this.baseUrl + "/waste-disposal/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteDisposalActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteDisposalActivityData>;
        }));
    }

    protected processGetOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response: HttpResponseBase): Observable<WasteDisposalActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WasteDisposalActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single WasteDisposalActivityData
     * @return Response
     */
    updateOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(id: number, body: WasteDisposalActivityData): Observable<WasteDisposalActivityData> {
        let url_ = this.baseUrl + "/waste-disposal/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteDisposalActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteDisposalActivityData>;
        }));
    }

    protected processUpdateOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response: HttpResponseBase): Observable<WasteDisposalActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WasteDisposalActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single WasteDisposalActivityData
     */
    deleteOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/waste-disposal/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single WasteDisposalActivityData
     * @return Response
     */
    replaceOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(id: number, body: WasteDisposalActivityData): Observable<WasteDisposalActivityData> {
        let url_ = this.baseUrl + "/waste-disposal/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteDisposalActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteDisposalActivityData>;
        }));
    }

    protected processReplaceOneBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response: HttpResponseBase): Observable<WasteDisposalActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WasteDisposalActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple WasteDisposalActivityData
     * @return Get create many base response
     */
    createManyBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(body: CreateManyWasteDisposalActivityDataDto): Observable<WasteDisposalActivityData[]> {
        let url_ = this.baseUrl + "/waste-disposal/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteDisposalActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteDisposalActivityData[]>;
        }));
    }

    protected processCreateManyBaseWasteDisposalActivityDataControllerWasteDisposalActivityData(response: HttpResponseBase): Observable<WasteDisposalActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(WasteDisposalActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single CookingGasActivityData
     * @return Get create one base response
     */
    createOneBaseCookingGasActivityDataControllerCookingGasActivityData(body: CookingGasActivityData): Observable<CookingGasActivityData> {
        let url_ = this.baseUrl + "/cooking-gas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookingGasActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookingGasActivityData>;
        }));
    }

    protected processCreateOneBaseCookingGasActivityDataControllerCookingGasActivityData(response: HttpResponseBase): Observable<CookingGasActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CookingGasActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple CookingGasActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseCookingGasActivityDataControllerCookingGasActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyCookingGasActivityDataResponseDto> {
        let url_ = this.baseUrl + "/cooking-gas?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseCookingGasActivityDataControllerCookingGasActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseCookingGasActivityDataControllerCookingGasActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyCookingGasActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyCookingGasActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseCookingGasActivityDataControllerCookingGasActivityData(response: HttpResponseBase): Observable<GetManyCookingGasActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyCookingGasActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single CookingGasActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseCookingGasActivityDataControllerCookingGasActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<CookingGasActivityData> {
        let url_ = this.baseUrl + "/cooking-gas/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookingGasActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookingGasActivityData>;
        }));
    }

    protected processGetOneBaseCookingGasActivityDataControllerCookingGasActivityData(response: HttpResponseBase): Observable<CookingGasActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CookingGasActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single CookingGasActivityData
     * @return Response
     */
    updateOneBaseCookingGasActivityDataControllerCookingGasActivityData(id: number, body: CookingGasActivityData): Observable<CookingGasActivityData> {
        let url_ = this.baseUrl + "/cooking-gas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookingGasActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookingGasActivityData>;
        }));
    }

    protected processUpdateOneBaseCookingGasActivityDataControllerCookingGasActivityData(response: HttpResponseBase): Observable<CookingGasActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CookingGasActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single CookingGasActivityData
     */
    deleteOneBaseCookingGasActivityDataControllerCookingGasActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/cooking-gas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseCookingGasActivityDataControllerCookingGasActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single CookingGasActivityData
     * @return Response
     */
    replaceOneBaseCookingGasActivityDataControllerCookingGasActivityData(id: number, body: CookingGasActivityData): Observable<CookingGasActivityData> {
        let url_ = this.baseUrl + "/cooking-gas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseCookingGasActivityDataControllerCookingGasActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookingGasActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookingGasActivityData>;
        }));
    }

    protected processReplaceOneBaseCookingGasActivityDataControllerCookingGasActivityData(response: HttpResponseBase): Observable<CookingGasActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CookingGasActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple CookingGasActivityData
     * @return Get create many base response
     */
    createManyBaseCookingGasActivityDataControllerCookingGasActivityData(body: CreateManyCookingGasActivityDataDto): Observable<CookingGasActivityData[]> {
        let url_ = this.baseUrl + "/cooking-gas/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseCookingGasActivityDataControllerCookingGasActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseCookingGasActivityDataControllerCookingGasActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookingGasActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookingGasActivityData[]>;
        }));
    }

    protected processCreateManyBaseCookingGasActivityDataControllerCookingGasActivityData(response: HttpResponseBase): Observable<CookingGasActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(CookingGasActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single FreightAirActivityData
     * @return Get create one base response
     */
    createOneBaseFreightAirActivityDataControllerFreightAirActivityData(body: FreightAirActivityData): Observable<FreightAirActivityData> {
        let url_ = this.baseUrl + "/freight-air";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightAirActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightAirActivityData>;
        }));
    }

    protected processCreateOneBaseFreightAirActivityDataControllerFreightAirActivityData(response: HttpResponseBase): Observable<FreightAirActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FreightAirActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple FreightAirActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFreightAirActivityDataControllerFreightAirActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFreightAirActivityDataResponseDto> {
        let url_ = this.baseUrl + "/freight-air?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFreightAirActivityDataControllerFreightAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFreightAirActivityDataControllerFreightAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyFreightAirActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyFreightAirActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseFreightAirActivityDataControllerFreightAirActivityData(response: HttpResponseBase): Observable<GetManyFreightAirActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFreightAirActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single FreightAirActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFreightAirActivityDataControllerFreightAirActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FreightAirActivityData> {
        let url_ = this.baseUrl + "/freight-air/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightAirActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightAirActivityData>;
        }));
    }

    protected processGetOneBaseFreightAirActivityDataControllerFreightAirActivityData(response: HttpResponseBase): Observable<FreightAirActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightAirActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single FreightAirActivityData
     * @return Response
     */
    updateOneBaseFreightAirActivityDataControllerFreightAirActivityData(id: number, body: FreightAirActivityData): Observable<FreightAirActivityData> {
        let url_ = this.baseUrl + "/freight-air/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightAirActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightAirActivityData>;
        }));
    }

    protected processUpdateOneBaseFreightAirActivityDataControllerFreightAirActivityData(response: HttpResponseBase): Observable<FreightAirActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightAirActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single FreightAirActivityData
     */
    deleteOneBaseFreightAirActivityDataControllerFreightAirActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/freight-air/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseFreightAirActivityDataControllerFreightAirActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single FreightAirActivityData
     * @return Response
     */
    replaceOneBaseFreightAirActivityDataControllerFreightAirActivityData(id: number, body: FreightAirActivityData): Observable<FreightAirActivityData> {
        let url_ = this.baseUrl + "/freight-air/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFreightAirActivityDataControllerFreightAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightAirActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightAirActivityData>;
        }));
    }

    protected processReplaceOneBaseFreightAirActivityDataControllerFreightAirActivityData(response: HttpResponseBase): Observable<FreightAirActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightAirActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple FreightAirActivityData
     * @return Get create many base response
     */
    createManyBaseFreightAirActivityDataControllerFreightAirActivityData(body: CreateManyFreightAirActivityDataDto): Observable<FreightAirActivityData[]> {
        let url_ = this.baseUrl + "/freight-air/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFreightAirActivityDataControllerFreightAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFreightAirActivityDataControllerFreightAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightAirActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightAirActivityData[]>;
        }));
    }

    protected processCreateManyBaseFreightAirActivityDataControllerFreightAirActivityData(response: HttpResponseBase): Observable<FreightAirActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FreightAirActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single FreightRailActivityData
     * @return Get create one base response
     */
    createOneBaseFreightRailActivityDataControllerFreightRailActivityData(body: FreightRailActivityData): Observable<FreightRailActivityData> {
        let url_ = this.baseUrl + "/freight-rail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRailActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRailActivityData>;
        }));
    }

    protected processCreateOneBaseFreightRailActivityDataControllerFreightRailActivityData(response: HttpResponseBase): Observable<FreightRailActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FreightRailActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple FreightRailActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFreightRailActivityDataControllerFreightRailActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFreightRailActivityDataResponseDto> {
        let url_ = this.baseUrl + "/freight-rail?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFreightRailActivityDataControllerFreightRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFreightRailActivityDataControllerFreightRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyFreightRailActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyFreightRailActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseFreightRailActivityDataControllerFreightRailActivityData(response: HttpResponseBase): Observable<GetManyFreightRailActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFreightRailActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single FreightRailActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFreightRailActivityDataControllerFreightRailActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FreightRailActivityData> {
        let url_ = this.baseUrl + "/freight-rail/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRailActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRailActivityData>;
        }));
    }

    protected processGetOneBaseFreightRailActivityDataControllerFreightRailActivityData(response: HttpResponseBase): Observable<FreightRailActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightRailActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single FreightRailActivityData
     * @return Response
     */
    updateOneBaseFreightRailActivityDataControllerFreightRailActivityData(id: number, body: FreightRailActivityData): Observable<FreightRailActivityData> {
        let url_ = this.baseUrl + "/freight-rail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRailActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRailActivityData>;
        }));
    }

    protected processUpdateOneBaseFreightRailActivityDataControllerFreightRailActivityData(response: HttpResponseBase): Observable<FreightRailActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightRailActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single FreightRailActivityData
     */
    deleteOneBaseFreightRailActivityDataControllerFreightRailActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/freight-rail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseFreightRailActivityDataControllerFreightRailActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single FreightRailActivityData
     * @return Response
     */
    replaceOneBaseFreightRailActivityDataControllerFreightRailActivityData(id: number, body: FreightRailActivityData): Observable<FreightRailActivityData> {
        let url_ = this.baseUrl + "/freight-rail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFreightRailActivityDataControllerFreightRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRailActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRailActivityData>;
        }));
    }

    protected processReplaceOneBaseFreightRailActivityDataControllerFreightRailActivityData(response: HttpResponseBase): Observable<FreightRailActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightRailActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple FreightRailActivityData
     * @return Get create many base response
     */
    createManyBaseFreightRailActivityDataControllerFreightRailActivityData(body: CreateManyFreightRailActivityDataDto): Observable<FreightRailActivityData[]> {
        let url_ = this.baseUrl + "/freight-rail/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFreightRailActivityDataControllerFreightRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFreightRailActivityDataControllerFreightRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRailActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRailActivityData[]>;
        }));
    }

    protected processCreateManyBaseFreightRailActivityDataControllerFreightRailActivityData(response: HttpResponseBase): Observable<FreightRailActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FreightRailActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single FreightRoadActivityData
     * @return Get create one base response
     */
    createOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(body: FreightRoadActivityData): Observable<FreightRoadActivityData> {
        let url_ = this.baseUrl + "/freight-road";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRoadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRoadActivityData>;
        }));
    }

    protected processCreateOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response: HttpResponseBase): Observable<FreightRoadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FreightRoadActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple FreightRoadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFreightRoadActivityDataControllerFreightRoadActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFreightRoadActivityDataResponseDto> {
        let url_ = this.baseUrl + "/freight-road?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyFreightRoadActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyFreightRoadActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseFreightRoadActivityDataControllerFreightRoadActivityData(response: HttpResponseBase): Observable<GetManyFreightRoadActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFreightRoadActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single FreightRoadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FreightRoadActivityData> {
        let url_ = this.baseUrl + "/freight-road/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRoadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRoadActivityData>;
        }));
    }

    protected processGetOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response: HttpResponseBase): Observable<FreightRoadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightRoadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single FreightRoadActivityData
     * @return Response
     */
    updateOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(id: number, body: FreightRoadActivityData): Observable<FreightRoadActivityData> {
        let url_ = this.baseUrl + "/freight-road/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRoadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRoadActivityData>;
        }));
    }

    protected processUpdateOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response: HttpResponseBase): Observable<FreightRoadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightRoadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single FreightRoadActivityData
     */
    deleteOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/freight-road/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single FreightRoadActivityData
     * @return Response
     */
    replaceOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(id: number, body: FreightRoadActivityData): Observable<FreightRoadActivityData> {
        let url_ = this.baseUrl + "/freight-road/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRoadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRoadActivityData>;
        }));
    }

    protected processReplaceOneBaseFreightRoadActivityDataControllerFreightRoadActivityData(response: HttpResponseBase): Observable<FreightRoadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightRoadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple FreightRoadActivityData
     * @return Get create many base response
     */
    createManyBaseFreightRoadActivityDataControllerFreightRoadActivityData(body: CreateManyFreightRoadActivityDataDto): Observable<FreightRoadActivityData[]> {
        let url_ = this.baseUrl + "/freight-road/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFreightRoadActivityDataControllerFreightRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightRoadActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightRoadActivityData[]>;
        }));
    }

    protected processCreateManyBaseFreightRoadActivityDataControllerFreightRoadActivityData(response: HttpResponseBase): Observable<FreightRoadActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FreightRoadActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single FreightWaterActivityData
     * @return Get create one base response
     */
    createOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(body: FreightWaterActivityData): Observable<FreightWaterActivityData> {
        let url_ = this.baseUrl + "/freight-water";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightWaterActivityData>;
        }));
    }

    protected processCreateOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response: HttpResponseBase): Observable<FreightWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FreightWaterActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple FreightWaterActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFreightWaterActivityDataControllerFreightWaterActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFreightWaterActivityDataResponseDto> {
        let url_ = this.baseUrl + "/freight-water?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyFreightWaterActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyFreightWaterActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseFreightWaterActivityDataControllerFreightWaterActivityData(response: HttpResponseBase): Observable<GetManyFreightWaterActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFreightWaterActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single FreightWaterActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FreightWaterActivityData> {
        let url_ = this.baseUrl + "/freight-water/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightWaterActivityData>;
        }));
    }

    protected processGetOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response: HttpResponseBase): Observable<FreightWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightWaterActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single FreightWaterActivityData
     * @return Response
     */
    updateOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(id: number, body: FreightWaterActivityData): Observable<FreightWaterActivityData> {
        let url_ = this.baseUrl + "/freight-water/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightWaterActivityData>;
        }));
    }

    protected processUpdateOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response: HttpResponseBase): Observable<FreightWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightWaterActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single FreightWaterActivityData
     */
    deleteOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/freight-water/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single FreightWaterActivityData
     * @return Response
     */
    replaceOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(id: number, body: FreightWaterActivityData): Observable<FreightWaterActivityData> {
        let url_ = this.baseUrl + "/freight-water/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightWaterActivityData>;
        }));
    }

    protected processReplaceOneBaseFreightWaterActivityDataControllerFreightWaterActivityData(response: HttpResponseBase): Observable<FreightWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightWaterActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple FreightWaterActivityData
     * @return Get create many base response
     */
    createManyBaseFreightWaterActivityDataControllerFreightWaterActivityData(body: CreateManyFreightWaterActivityDataDto): Observable<FreightWaterActivityData[]> {
        let url_ = this.baseUrl + "/freight-water/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFreightWaterActivityDataControllerFreightWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightWaterActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightWaterActivityData[]>;
        }));
    }

    protected processCreateManyBaseFreightWaterActivityDataControllerFreightWaterActivityData(response: HttpResponseBase): Observable<FreightWaterActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FreightWaterActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single FreightOffroadActivityData
     * @return Get create one base response
     */
    createOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(body: FreightOffroadActivityData): Observable<FreightOffroadActivityData> {
        let url_ = this.baseUrl + "/freight-offroad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightOffroadActivityData>;
        }));
    }

    protected processCreateOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response: HttpResponseBase): Observable<FreightOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FreightOffroadActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple FreightOffroadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFreightOffroadActivityDataResponseDto> {
        let url_ = this.baseUrl + "/freight-offroad?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyFreightOffroadActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyFreightOffroadActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response: HttpResponseBase): Observable<GetManyFreightOffroadActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFreightOffroadActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single FreightOffroadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FreightOffroadActivityData> {
        let url_ = this.baseUrl + "/freight-offroad/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightOffroadActivityData>;
        }));
    }

    protected processGetOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response: HttpResponseBase): Observable<FreightOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightOffroadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single FreightOffroadActivityData
     * @return Response
     */
    updateOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(id: number, body: FreightOffroadActivityData): Observable<FreightOffroadActivityData> {
        let url_ = this.baseUrl + "/freight-offroad/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightOffroadActivityData>;
        }));
    }

    protected processUpdateOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response: HttpResponseBase): Observable<FreightOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightOffroadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single FreightOffroadActivityData
     */
    deleteOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/freight-offroad/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single FreightOffroadActivityData
     * @return Response
     */
    replaceOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(id: number, body: FreightOffroadActivityData): Observable<FreightOffroadActivityData> {
        let url_ = this.baseUrl + "/freight-offroad/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightOffroadActivityData>;
        }));
    }

    protected processReplaceOneBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response: HttpResponseBase): Observable<FreightOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FreightOffroadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple FreightOffroadActivityData
     * @return Get create many base response
     */
    createManyBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(body: CreateManyFreightOffroadActivityDataDto): Observable<FreightOffroadActivityData[]> {
        let url_ = this.baseUrl + "/freight-offroad/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FreightOffroadActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FreightOffroadActivityData[]>;
        }));
    }

    protected processCreateManyBaseFreightOffroadActivityDataControllerFreightOffroadActivityData(response: HttpResponseBase): Observable<FreightOffroadActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FreightOffroadActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single PassengerRoadActivityData
     * @return Get create one base response
     */
    createOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(body: PassengerRoadActivityData): Observable<PassengerRoadActivityData> {
        let url_ = this.baseUrl + "/passenger-road";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRoadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRoadActivityData>;
        }));
    }

    protected processCreateOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response: HttpResponseBase): Observable<PassengerRoadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PassengerRoadActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple PassengerRoadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePassengerRoadActivityDataControllerPassengerRoadActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPassengerRoadActivityDataResponseDto> {
        let url_ = this.baseUrl + "/passenger-road?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyPassengerRoadActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyPassengerRoadActivityDataResponseDto>;
        }));
    }

    protected processGetManyBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response: HttpResponseBase): Observable<GetManyPassengerRoadActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPassengerRoadActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single PassengerRoadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PassengerRoadActivityData> {
        let url_ = this.baseUrl + "/passenger-road/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRoadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRoadActivityData>;
        }));
    }

    protected processGetOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response: HttpResponseBase): Observable<PassengerRoadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerRoadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single PassengerRoadActivityData
     * @return Response
     */
    updateOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(id: number, body: PassengerRoadActivityData): Observable<PassengerRoadActivityData> {
        let url_ = this.baseUrl + "/passenger-road/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRoadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRoadActivityData>;
        }));
    }

    protected processUpdateOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response: HttpResponseBase): Observable<PassengerRoadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerRoadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single PassengerRoadActivityData
     */
    deleteOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(id: number): Observable<any> {
        let url_ = this.baseUrl + "/passenger-road/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single PassengerRoadActivityData
     * @return Response
     */
    replaceOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(id: number, body: PassengerRoadActivityData): Observable<PassengerRoadActivityData> {
        let url_ = this.baseUrl + "/passenger-road/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRoadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRoadActivityData>;
        }));
    }

    protected processReplaceOneBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response: HttpResponseBase): Observable<PassengerRoadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerRoadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple PassengerRoadActivityData
     * @return Get create many base response
     */
    createManyBasePassengerRoadActivityDataControllerPassengerRoadActivityData(body: CreateManyPassengerRoadActivityDataDto): Observable<PassengerRoadActivityData[]> {
        let url_ = this.baseUrl + "/passenger-road/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRoadActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRoadActivityData[]>;
        }));
    }

    protected processCreateManyBasePassengerRoadActivityDataControllerPassengerRoadActivityData(response: HttpResponseBase): Observable<PassengerRoadActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PassengerRoadActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single EmployeeName
     * @return Get create one base response
     */
    createOneBaseEmployeeNameControllerEmployeeName(body: EmployeeName): Observable<EmployeeName> {
        let url_ = this.baseUrl + "/employee-name";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseEmployeeNameControllerEmployeeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseEmployeeNameControllerEmployeeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeName>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeName>;
        }));
    }

    protected processCreateOneBaseEmployeeNameControllerEmployeeName(response: HttpResponseBase): Observable<EmployeeName> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EmployeeName.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple EmployeeNames
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseEmployeeNameControllerEmployeeName(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyEmployeeNameResponseDto> {
        let url_ = this.baseUrl + "/employee-name?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseEmployeeNameControllerEmployeeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseEmployeeNameControllerEmployeeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyEmployeeNameResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyEmployeeNameResponseDto>;
        }));
    }

    protected processGetManyBaseEmployeeNameControllerEmployeeName(response: HttpResponseBase): Observable<GetManyEmployeeNameResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyEmployeeNameResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single EmployeeName
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseEmployeeNameControllerEmployeeName(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<EmployeeName> {
        let url_ = this.baseUrl + "/employee-name/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseEmployeeNameControllerEmployeeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseEmployeeNameControllerEmployeeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeName>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeName>;
        }));
    }

    protected processGetOneBaseEmployeeNameControllerEmployeeName(response: HttpResponseBase): Observable<EmployeeName> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeName.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single EmployeeName
     * @return Response
     */
    updateOneBaseEmployeeNameControllerEmployeeName(id: number, body: EmployeeName): Observable<EmployeeName> {
        let url_ = this.baseUrl + "/employee-name/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseEmployeeNameControllerEmployeeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseEmployeeNameControllerEmployeeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeName>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeName>;
        }));
    }

    protected processUpdateOneBaseEmployeeNameControllerEmployeeName(response: HttpResponseBase): Observable<EmployeeName> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeName.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single EmployeeName
     * @return Response
     */
    replaceOneBaseEmployeeNameControllerEmployeeName(id: number, body: EmployeeName): Observable<EmployeeName> {
        let url_ = this.baseUrl + "/employee-name/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseEmployeeNameControllerEmployeeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseEmployeeNameControllerEmployeeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeName>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeName>;
        }));
    }

    protected processReplaceOneBaseEmployeeNameControllerEmployeeName(response: HttpResponseBase): Observable<EmployeeName> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeName.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single EmployeeName
     * @return Delete one base response
     */
    deleteOneBaseEmployeeNameControllerEmployeeName(id: number): Observable<void> {
        let url_ = this.baseUrl + "/employee-name/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseEmployeeNameControllerEmployeeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseEmployeeNameControllerEmployeeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseEmployeeNameControllerEmployeeName(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple EmployeeNames
     * @return Get create many base response
     */
    createManyBaseEmployeeNameControllerEmployeeName(body: CreateManyEmployeeNameDto): Observable<EmployeeName[]> {
        let url_ = this.baseUrl + "/employee-name/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseEmployeeNameControllerEmployeeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseEmployeeNameControllerEmployeeName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeName[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeName[]>;
        }));
    }

    protected processCreateManyBaseEmployeeNameControllerEmployeeName(response: HttpResponseBase): Observable<EmployeeName[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(EmployeeName.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single PassengerOffroadActivityData
     * @return Get create one base response
     */
    createOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(body: PassengerOffroadActivityData): Observable<PassengerOffroadActivityData> {
        let url_ = this.baseUrl + "/passenger-offroad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerOffroadActivityData>;
        }));
    }

    protected processCreateOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response: HttpResponseBase): Observable<PassengerOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PassengerOffroadActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple PassengerOffroadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPassengerOffroadActivityDataResponseDto> {
        let url_ = this.baseUrl + "/passenger-offroad?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyPassengerOffroadActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyPassengerOffroadActivityDataResponseDto>;
        }));
    }

    protected processGetManyBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response: HttpResponseBase): Observable<GetManyPassengerOffroadActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPassengerOffroadActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single PassengerOffroadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PassengerOffroadActivityData> {
        let url_ = this.baseUrl + "/passenger-offroad/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerOffroadActivityData>;
        }));
    }

    protected processGetOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response: HttpResponseBase): Observable<PassengerOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerOffroadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single PassengerOffroadActivityData
     * @return Response
     */
    updateOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(id: number, body: PassengerOffroadActivityData): Observable<PassengerOffroadActivityData> {
        let url_ = this.baseUrl + "/passenger-offroad/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerOffroadActivityData>;
        }));
    }

    protected processUpdateOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response: HttpResponseBase): Observable<PassengerOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerOffroadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single PassengerOffroadActivityData
     */
    deleteOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/passenger-offroad/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single PassengerOffroadActivityData
     * @return Response
     */
    replaceOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(id: number, body: PassengerOffroadActivityData): Observable<PassengerOffroadActivityData> {
        let url_ = this.baseUrl + "/passenger-offroad/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerOffroadActivityData>;
        }));
    }

    protected processReplaceOneBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response: HttpResponseBase): Observable<PassengerOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerOffroadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple PassengerOffroadActivityData
     * @return Get create many base response
     */
    createManyBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(body: CreateManyPassengerOffroadActivityDataDto): Observable<PassengerOffroadActivityData[]> {
        let url_ = this.baseUrl + "/passenger-offroad/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerOffroadActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerOffroadActivityData[]>;
        }));
    }

    protected processCreateManyBasePassengerOffroadActivityDataControllerPassengerOffroadActivityData(response: HttpResponseBase): Observable<PassengerOffroadActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PassengerOffroadActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single PassengerRailActivityData
     * @return Get create one base response
     */
    createOneBasePassengerRailActivityDataControllerPassengerRailActivityData(body: PassengerRailActivityData): Observable<PassengerRailActivityData> {
        let url_ = this.baseUrl + "/passenger-rail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRailActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRailActivityData>;
        }));
    }

    protected processCreateOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response: HttpResponseBase): Observable<PassengerRailActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PassengerRailActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple PassengerRailActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePassengerRailActivityDataControllerPassengerRailActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPassengerRailActivityDataResponseDto> {
        let url_ = this.baseUrl + "/passenger-rail?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePassengerRailActivityDataControllerPassengerRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePassengerRailActivityDataControllerPassengerRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyPassengerRailActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyPassengerRailActivityDataResponseDto>;
        }));
    }

    protected processGetManyBasePassengerRailActivityDataControllerPassengerRailActivityData(response: HttpResponseBase): Observable<GetManyPassengerRailActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPassengerRailActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single PassengerRailActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePassengerRailActivityDataControllerPassengerRailActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PassengerRailActivityData> {
        let url_ = this.baseUrl + "/passenger-rail/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRailActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRailActivityData>;
        }));
    }

    protected processGetOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response: HttpResponseBase): Observable<PassengerRailActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerRailActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single PassengerRailActivityData
     * @return Response
     */
    updateOneBasePassengerRailActivityDataControllerPassengerRailActivityData(id: number, body: PassengerRailActivityData): Observable<PassengerRailActivityData> {
        let url_ = this.baseUrl + "/passenger-rail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRailActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRailActivityData>;
        }));
    }

    protected processUpdateOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response: HttpResponseBase): Observable<PassengerRailActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerRailActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single PassengerRailActivityData
     */
    deleteOneBasePassengerRailActivityDataControllerPassengerRailActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/passenger-rail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single PassengerRailActivityData
     * @return Response
     */
    replaceOneBasePassengerRailActivityDataControllerPassengerRailActivityData(id: number, body: PassengerRailActivityData): Observable<PassengerRailActivityData> {
        let url_ = this.baseUrl + "/passenger-rail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRailActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRailActivityData>;
        }));
    }

    protected processReplaceOneBasePassengerRailActivityDataControllerPassengerRailActivityData(response: HttpResponseBase): Observable<PassengerRailActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerRailActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple PassengerRailActivityData
     * @return Get create many base response
     */
    createManyBasePassengerRailActivityDataControllerPassengerRailActivityData(body: CreateManyPassengerRailActivityDataDto): Observable<PassengerRailActivityData[]> {
        let url_ = this.baseUrl + "/passenger-rail/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePassengerRailActivityDataControllerPassengerRailActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePassengerRailActivityDataControllerPassengerRailActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerRailActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerRailActivityData[]>;
        }));
    }

    protected processCreateManyBasePassengerRailActivityDataControllerPassengerRailActivityData(response: HttpResponseBase): Observable<PassengerRailActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PassengerRailActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single PassengerAirActivityData
     * @return Get create one base response
     */
    createOneBasePassengerAirActivityDataControllerPassengerAirActivityData(body: PassengerAirActivityData): Observable<PassengerAirActivityData> {
        let url_ = this.baseUrl + "/passenger-air";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirActivityData>;
        }));
    }

    protected processCreateOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response: HttpResponseBase): Observable<PassengerAirActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PassengerAirActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple PassengerAirActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePassengerAirActivityDataControllerPassengerAirActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPassengerAirActivityDataResponseDto> {
        let url_ = this.baseUrl + "/passenger-air?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePassengerAirActivityDataControllerPassengerAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePassengerAirActivityDataControllerPassengerAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyPassengerAirActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyPassengerAirActivityDataResponseDto>;
        }));
    }

    protected processGetManyBasePassengerAirActivityDataControllerPassengerAirActivityData(response: HttpResponseBase): Observable<GetManyPassengerAirActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPassengerAirActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single PassengerAirActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePassengerAirActivityDataControllerPassengerAirActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PassengerAirActivityData> {
        let url_ = this.baseUrl + "/passenger-air/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirActivityData>;
        }));
    }

    protected processGetOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response: HttpResponseBase): Observable<PassengerAirActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerAirActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single PassengerAirActivityData
     * @return Response
     */
    updateOneBasePassengerAirActivityDataControllerPassengerAirActivityData(id: number, body: PassengerAirActivityData): Observable<PassengerAirActivityData> {
        let url_ = this.baseUrl + "/passenger-air/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirActivityData>;
        }));
    }

    protected processUpdateOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response: HttpResponseBase): Observable<PassengerAirActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerAirActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single PassengerAirActivityData
     */
    deleteOneBasePassengerAirActivityDataControllerPassengerAirActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/passenger-air/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single PassengerAirActivityData
     * @return Response
     */
    replaceOneBasePassengerAirActivityDataControllerPassengerAirActivityData(id: number, body: PassengerAirActivityData): Observable<PassengerAirActivityData> {
        let url_ = this.baseUrl + "/passenger-air/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirActivityData>;
        }));
    }

    protected processReplaceOneBasePassengerAirActivityDataControllerPassengerAirActivityData(response: HttpResponseBase): Observable<PassengerAirActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerAirActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple PassengerAirActivityData
     * @return Get create many base response
     */
    createManyBasePassengerAirActivityDataControllerPassengerAirActivityData(body: CreateManyPassengerAirActivityDataDto): Observable<PassengerAirActivityData[]> {
        let url_ = this.baseUrl + "/passenger-air/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePassengerAirActivityDataControllerPassengerAirActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePassengerAirActivityDataControllerPassengerAirActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirActivityData[]>;
        }));
    }

    protected processCreateManyBasePassengerAirActivityDataControllerPassengerAirActivityData(response: HttpResponseBase): Observable<PassengerAirActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PassengerAirActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single PassengerWaterActivityData
     * @return Get create one base response
     */
    createOneBasePassengerWaterControllerPassengerWaterActivityData(body: PassengerWaterActivityData): Observable<PassengerWaterActivityData> {
        let url_ = this.baseUrl + "/passenger-water";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePassengerWaterControllerPassengerWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePassengerWaterControllerPassengerWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerWaterActivityData>;
        }));
    }

    protected processCreateOneBasePassengerWaterControllerPassengerWaterActivityData(response: HttpResponseBase): Observable<PassengerWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PassengerWaterActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple PassengerWaterActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePassengerWaterControllerPassengerWaterActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPassengerWaterActivityDataResponseDto> {
        let url_ = this.baseUrl + "/passenger-water?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePassengerWaterControllerPassengerWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePassengerWaterControllerPassengerWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyPassengerWaterActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyPassengerWaterActivityDataResponseDto>;
        }));
    }

    protected processGetManyBasePassengerWaterControllerPassengerWaterActivityData(response: HttpResponseBase): Observable<GetManyPassengerWaterActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPassengerWaterActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single PassengerWaterActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePassengerWaterControllerPassengerWaterActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PassengerWaterActivityData> {
        let url_ = this.baseUrl + "/passenger-water/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePassengerWaterControllerPassengerWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePassengerWaterControllerPassengerWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerWaterActivityData>;
        }));
    }

    protected processGetOneBasePassengerWaterControllerPassengerWaterActivityData(response: HttpResponseBase): Observable<PassengerWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerWaterActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single PassengerWaterActivityData
     * @return Response
     */
    updateOneBasePassengerWaterControllerPassengerWaterActivityData(id: number, body: PassengerWaterActivityData): Observable<PassengerWaterActivityData> {
        let url_ = this.baseUrl + "/passenger-water/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePassengerWaterControllerPassengerWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePassengerWaterControllerPassengerWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerWaterActivityData>;
        }));
    }

    protected processUpdateOneBasePassengerWaterControllerPassengerWaterActivityData(response: HttpResponseBase): Observable<PassengerWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerWaterActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single PassengerWaterActivityData
     */
    deleteOneBasePassengerWaterControllerPassengerWaterActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/passenger-water/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePassengerWaterControllerPassengerWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePassengerWaterControllerPassengerWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBasePassengerWaterControllerPassengerWaterActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single PassengerWaterActivityData
     * @return Response
     */
    replaceOneBasePassengerWaterControllerPassengerWaterActivityData(id: number, body: PassengerWaterActivityData): Observable<PassengerWaterActivityData> {
        let url_ = this.baseUrl + "/passenger-water/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePassengerWaterControllerPassengerWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePassengerWaterControllerPassengerWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerWaterActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerWaterActivityData>;
        }));
    }

    protected processReplaceOneBasePassengerWaterControllerPassengerWaterActivityData(response: HttpResponseBase): Observable<PassengerWaterActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerWaterActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple PassengerWaterActivityData
     * @return Get create many base response
     */
    createManyBasePassengerWaterControllerPassengerWaterActivityData(body: CreateManyPassengerWaterActivityDataDto): Observable<PassengerWaterActivityData[]> {
        let url_ = this.baseUrl + "/passenger-water/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePassengerWaterControllerPassengerWaterActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePassengerWaterControllerPassengerWaterActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerWaterActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerWaterActivityData[]>;
        }));
    }

    protected processCreateManyBasePassengerWaterControllerPassengerWaterActivityData(response: HttpResponseBase): Observable<PassengerWaterActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PassengerWaterActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single BusinessTravelActivityData
     * @return Get create one base response
     */
    createOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(body: BusinessTravelActivityData): Observable<BusinessTravelActivityData> {
        let url_ = this.baseUrl + "/business-travel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessTravelActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessTravelActivityData>;
        }));
    }

    protected processCreateOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response: HttpResponseBase): Observable<BusinessTravelActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = BusinessTravelActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple BusinessTravelActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyBusinessTravelActivityDataResponseDto> {
        let url_ = this.baseUrl + "/business-travel?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyBusinessTravelActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyBusinessTravelActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response: HttpResponseBase): Observable<GetManyBusinessTravelActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyBusinessTravelActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single BusinessTravelActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<BusinessTravelActivityData> {
        let url_ = this.baseUrl + "/business-travel/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessTravelActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessTravelActivityData>;
        }));
    }

    protected processGetOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response: HttpResponseBase): Observable<BusinessTravelActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessTravelActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single BusinessTravelActivityData
     * @return Response
     */
    updateOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(id: number, body: BusinessTravelActivityData): Observable<BusinessTravelActivityData> {
        let url_ = this.baseUrl + "/business-travel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessTravelActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessTravelActivityData>;
        }));
    }

    protected processUpdateOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response: HttpResponseBase): Observable<BusinessTravelActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessTravelActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single BusinessTravelActivityData
     */
    deleteOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/business-travel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single BusinessTravelActivityData
     * @return Response
     */
    replaceOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(id: number, body: BusinessTravelActivityData): Observable<BusinessTravelActivityData> {
        let url_ = this.baseUrl + "/business-travel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessTravelActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessTravelActivityData>;
        }));
    }

    protected processReplaceOneBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response: HttpResponseBase): Observable<BusinessTravelActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessTravelActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple BusinessTravelActivityData
     * @return Get create many base response
     */
    createManyBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(body: CreateManyBusinessTravelActivityDataDto): Observable<BusinessTravelActivityData[]> {
        let url_ = this.baseUrl + "/business-travel/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessTravelActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessTravelActivityData[]>;
        }));
    }

    protected processCreateManyBaseBusinessTravelActivityDataControllerBusinessTravelActivityData(response: HttpResponseBase): Observable<BusinessTravelActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(BusinessTravelActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single OffroadMachineryOffroadActivityData
     * @return Get create one base response
     */
    createOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(body: OffroadMachineryOffroadActivityData): Observable<OffroadMachineryOffroadActivityData> {
        let url_ = this.baseUrl + "/offroad-machinery-offroad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OffroadMachineryOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OffroadMachineryOffroadActivityData>;
        }));
    }

    protected processCreateOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response: HttpResponseBase): Observable<OffroadMachineryOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OffroadMachineryOffroadActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple OffroadMachineryOffroadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyOffroadMachineryOffroadActivityDataResponseDto> {
        let url_ = this.baseUrl + "/offroad-machinery-offroad?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyOffroadMachineryOffroadActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyOffroadMachineryOffroadActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response: HttpResponseBase): Observable<GetManyOffroadMachineryOffroadActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyOffroadMachineryOffroadActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single OffroadMachineryOffroadActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<OffroadMachineryOffroadActivityData> {
        let url_ = this.baseUrl + "/offroad-machinery-offroad/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OffroadMachineryOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OffroadMachineryOffroadActivityData>;
        }));
    }

    protected processGetOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response: HttpResponseBase): Observable<OffroadMachineryOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OffroadMachineryOffroadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single OffroadMachineryOffroadActivityData
     * @return Response
     */
    updateOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(id: number, body: OffroadMachineryOffroadActivityData): Observable<OffroadMachineryOffroadActivityData> {
        let url_ = this.baseUrl + "/offroad-machinery-offroad/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OffroadMachineryOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OffroadMachineryOffroadActivityData>;
        }));
    }

    protected processUpdateOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response: HttpResponseBase): Observable<OffroadMachineryOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OffroadMachineryOffroadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single OffroadMachineryOffroadActivityData
     */
    deleteOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/offroad-machinery-offroad/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single OffroadMachineryOffroadActivityData
     * @return Response
     */
    replaceOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(id: number, body: OffroadMachineryOffroadActivityData): Observable<OffroadMachineryOffroadActivityData> {
        let url_ = this.baseUrl + "/offroad-machinery-offroad/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OffroadMachineryOffroadActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OffroadMachineryOffroadActivityData>;
        }));
    }

    protected processReplaceOneBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response: HttpResponseBase): Observable<OffroadMachineryOffroadActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OffroadMachineryOffroadActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple OffroadMachineryOffroadActivityData
     * @return Get create many base response
     */
    createManyBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(body: CreateManyOffroadMachineryOffroadActivityDataDto): Observable<OffroadMachineryOffroadActivityData[]> {
        let url_ = this.baseUrl + "/offroad-machinery-offroad/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OffroadMachineryOffroadActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OffroadMachineryOffroadActivityData[]>;
        }));
    }

    protected processCreateManyBaseOffroadMachineryOffroadActivityDataControllerOffroadMachineryOffroadActivityData(response: HttpResponseBase): Observable<OffroadMachineryOffroadActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(OffroadMachineryOffroadActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single PurchasedGoodsAndServicesActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PurchasedGoodsAndServicesActivityData> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchasedGoodsAndServicesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchasedGoodsAndServicesActivityData>;
        }));
    }

    protected processGetOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response: HttpResponseBase): Observable<PurchasedGoodsAndServicesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchasedGoodsAndServicesActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single PurchasedGoodsAndServicesActivityData
     * @return Response
     */
    updateOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(id: number, body: PurchasedGoodsAndServicesActivityData): Observable<PurchasedGoodsAndServicesActivityData> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchasedGoodsAndServicesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchasedGoodsAndServicesActivityData>;
        }));
    }

    protected processUpdateOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response: HttpResponseBase): Observable<PurchasedGoodsAndServicesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchasedGoodsAndServicesActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single PurchasedGoodsAndServicesActivityData
     * @return Response
     */
    replaceOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(id: number, body: PurchasedGoodsAndServicesActivityData): Observable<PurchasedGoodsAndServicesActivityData> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchasedGoodsAndServicesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchasedGoodsAndServicesActivityData>;
        }));
    }

    protected processReplaceOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response: HttpResponseBase): Observable<PurchasedGoodsAndServicesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchasedGoodsAndServicesActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single PurchasedGoodsAndServicesActivityData
     * @return Delete one base response
     */
    deleteOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple PurchasedGoodsAndServicesActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPurchasedGoodsAndServicesActivityDataResponseDto> {
        let url_ = this.baseUrl + "/purchased-goods-and-services?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyPurchasedGoodsAndServicesActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyPurchasedGoodsAndServicesActivityDataResponseDto>;
        }));
    }

    protected processGetManyBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response: HttpResponseBase): Observable<GetManyPurchasedGoodsAndServicesActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPurchasedGoodsAndServicesActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single PurchasedGoodsAndServicesActivityData
     * @return Get create one base response
     */
    createOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(body: PurchasedGoodsAndServicesActivityData): Observable<PurchasedGoodsAndServicesActivityData> {
        let url_ = this.baseUrl + "/purchased-goods-and-services";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchasedGoodsAndServicesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchasedGoodsAndServicesActivityData>;
        }));
    }

    protected processCreateOneBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response: HttpResponseBase): Observable<PurchasedGoodsAndServicesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PurchasedGoodsAndServicesActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple PurchasedGoodsAndServicesActivityData
     * @return Get create many base response
     */
    createManyBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(body: CreateManyPurchasedGoodsAndServicesActivityDataDto): Observable<PurchasedGoodsAndServicesActivityData[]> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchasedGoodsAndServicesActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchasedGoodsAndServicesActivityData[]>;
        }));
    }

    protected processCreateManyBasePurchasedGoodsAndServicesActivityDataControllerPurchasedGoodsAndServicesActivityData(response: HttpResponseBase): Observable<PurchasedGoodsAndServicesActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PurchasedGoodsAndServicesActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single DownstreamLeasedAssetsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<DownstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamLeasedAssetsActivityData>;
        }));
    }

    protected processGetOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<DownstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownstreamLeasedAssetsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single DownstreamLeasedAssetsActivityData
     * @return Response
     */
    updateOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(id: number, body: DownstreamLeasedAssetsActivityData): Observable<DownstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamLeasedAssetsActivityData>;
        }));
    }

    protected processUpdateOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<DownstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownstreamLeasedAssetsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single DownstreamLeasedAssetsActivityData
     * @return Response
     */
    replaceOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(id: number, body: DownstreamLeasedAssetsActivityData): Observable<DownstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamLeasedAssetsActivityData>;
        }));
    }

    protected processReplaceOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<DownstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownstreamLeasedAssetsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single DownstreamLeasedAssetsActivityData
     * @return Delete one base response
     */
    deleteOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple DownstreamLeasedAssetsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyDownstreamLeasedAssetsActivityDataResponseDto> {
        let url_ = this.baseUrl + "/waste_generated_in_operations?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyDownstreamLeasedAssetsActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyDownstreamLeasedAssetsActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<GetManyDownstreamLeasedAssetsActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyDownstreamLeasedAssetsActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single DownstreamLeasedAssetsActivityData
     * @return Get create one base response
     */
    createOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(body: DownstreamLeasedAssetsActivityData): Observable<DownstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/waste_generated_in_operations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamLeasedAssetsActivityData>;
        }));
    }

    protected processCreateOneBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<DownstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DownstreamLeasedAssetsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple DownstreamLeasedAssetsActivityData
     * @return Get create many base response
     */
    createManyBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(body: CreateManyDownstreamLeasedAssetsActivityDataDto): Observable<DownstreamLeasedAssetsActivityData[]> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamLeasedAssetsActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamLeasedAssetsActivityData[]>;
        }));
    }

    protected processCreateManyBaseDownstreamLeasedAssetsActivityDataControllerDownstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<DownstreamLeasedAssetsActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(DownstreamLeasedAssetsActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single FuelEnergyRelatedActivitiesActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FuelEnergyRelatedActivitiesActivityData> {
        let url_ = this.baseUrl + "/fuelandenergy/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
        }));
    }

    protected processGetOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response: HttpResponseBase): Observable<FuelEnergyRelatedActivitiesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelEnergyRelatedActivitiesActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single FuelEnergyRelatedActivitiesActivityData
     * @return Response
     */
    updateOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(id: number, body: FuelEnergyRelatedActivitiesActivityData): Observable<FuelEnergyRelatedActivitiesActivityData> {
        let url_ = this.baseUrl + "/fuelandenergy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
        }));
    }

    protected processUpdateOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response: HttpResponseBase): Observable<FuelEnergyRelatedActivitiesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelEnergyRelatedActivitiesActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single FuelEnergyRelatedActivitiesActivityData
     * @return Response
     */
    replaceOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(id: number, body: FuelEnergyRelatedActivitiesActivityData): Observable<FuelEnergyRelatedActivitiesActivityData> {
        let url_ = this.baseUrl + "/fuelandenergy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
        }));
    }

    protected processReplaceOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response: HttpResponseBase): Observable<FuelEnergyRelatedActivitiesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelEnergyRelatedActivitiesActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single FuelEnergyRelatedActivitiesActivityData
     * @return Delete one base response
     */
    deleteOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/fuelandenergy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple FuelEnergyRelatedActivitiesActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto> {
        let url_ = this.baseUrl + "/fuelandenergy?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response: HttpResponseBase): Observable<GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single FuelEnergyRelatedActivitiesActivityData
     * @return Get create one base response
     */
    createOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(body: FuelEnergyRelatedActivitiesActivityData): Observable<FuelEnergyRelatedActivitiesActivityData> {
        let url_ = this.baseUrl + "/fuelandenergy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
        }));
    }

    protected processCreateOneBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response: HttpResponseBase): Observable<FuelEnergyRelatedActivitiesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FuelEnergyRelatedActivitiesActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple FuelEnergyRelatedActivitiesActivityData
     * @return Get create many base response
     */
    createManyBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(body: CreateManyFuelEnergyRelatedActivitiesActivityDataDto): Observable<FuelEnergyRelatedActivitiesActivityData[]> {
        let url_ = this.baseUrl + "/fuelandenergy/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuelEnergyRelatedActivitiesActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuelEnergyRelatedActivitiesActivityData[]>;
        }));
    }

    protected processCreateManyBaseFuelEnergyRelatedActivitiesActivityDataControllerFuelEnergyRelatedActivitiesActivityData(response: HttpResponseBase): Observable<FuelEnergyRelatedActivitiesActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FuelEnergyRelatedActivitiesActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single InvestmentsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<InvestmentsActivityData> {
        let url_ = this.baseUrl + "/investments/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentsActivityData>;
        }));
    }

    protected processGetOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response: HttpResponseBase): Observable<InvestmentsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single InvestmentsActivityData
     * @return Response
     */
    updateOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(id: number, body: InvestmentsActivityData): Observable<InvestmentsActivityData> {
        let url_ = this.baseUrl + "/investments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentsActivityData>;
        }));
    }

    protected processUpdateOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response: HttpResponseBase): Observable<InvestmentsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single InvestmentsActivityData
     * @return Response
     */
    replaceOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(id: number, body: InvestmentsActivityData): Observable<InvestmentsActivityData> {
        let url_ = this.baseUrl + "/investments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentsActivityData>;
        }));
    }

    protected processReplaceOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response: HttpResponseBase): Observable<InvestmentsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single InvestmentsActivityData
     * @return Delete one base response
     */
    deleteOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/investments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple InvestmentsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseInvestmentsActivityDataControllerInvestmentsActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyInvestmentsActivityDataResponseDto> {
        let url_ = this.baseUrl + "/investments?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyInvestmentsActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyInvestmentsActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseInvestmentsActivityDataControllerInvestmentsActivityData(response: HttpResponseBase): Observable<GetManyInvestmentsActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyInvestmentsActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single InvestmentsActivityData
     * @return Get create one base response
     */
    createOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(body: InvestmentsActivityData): Observable<InvestmentsActivityData> {
        let url_ = this.baseUrl + "/investments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentsActivityData>;
        }));
    }

    protected processCreateOneBaseInvestmentsActivityDataControllerInvestmentsActivityData(response: HttpResponseBase): Observable<InvestmentsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = InvestmentsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple InvestmentsActivityData
     * @return Get create many base response
     */
    createManyBaseInvestmentsActivityDataControllerInvestmentsActivityData(body: CreateManyInvestmentsActivityDataDto): Observable<InvestmentsActivityData[]> {
        let url_ = this.baseUrl + "/investments/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseInvestmentsActivityDataControllerInvestmentsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentsActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentsActivityData[]>;
        }));
    }

    protected processCreateManyBaseInvestmentsActivityDataControllerInvestmentsActivityData(response: HttpResponseBase): Observable<InvestmentsActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(InvestmentsActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single NetZeroBusinessTravelActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<NetZeroBusinessTravelActivityData> {
        let url_ = this.baseUrl + "/net_zero_business_travel/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroBusinessTravelActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroBusinessTravelActivityData>;
        }));
    }

    protected processGetOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response: HttpResponseBase): Observable<NetZeroBusinessTravelActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetZeroBusinessTravelActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single NetZeroBusinessTravelActivityData
     * @return Response
     */
    updateOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(id: number, body: NetZeroBusinessTravelActivityData): Observable<NetZeroBusinessTravelActivityData> {
        let url_ = this.baseUrl + "/net_zero_business_travel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroBusinessTravelActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroBusinessTravelActivityData>;
        }));
    }

    protected processUpdateOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response: HttpResponseBase): Observable<NetZeroBusinessTravelActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetZeroBusinessTravelActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single NetZeroBusinessTravelActivityData
     * @return Response
     */
    replaceOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(id: number, body: NetZeroBusinessTravelActivityData): Observable<NetZeroBusinessTravelActivityData> {
        let url_ = this.baseUrl + "/net_zero_business_travel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroBusinessTravelActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroBusinessTravelActivityData>;
        }));
    }

    protected processReplaceOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response: HttpResponseBase): Observable<NetZeroBusinessTravelActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetZeroBusinessTravelActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single NetZeroBusinessTravelActivityData
     * @return Delete one base response
     */
    deleteOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/net_zero_business_travel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple NetZeroBusinessTravelActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyNetZeroBusinessTravelActivityDataResponseDto> {
        let url_ = this.baseUrl + "/net_zero_business_travel?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyNetZeroBusinessTravelActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyNetZeroBusinessTravelActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response: HttpResponseBase): Observable<GetManyNetZeroBusinessTravelActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyNetZeroBusinessTravelActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single NetZeroBusinessTravelActivityData
     * @return Get create one base response
     */
    createOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(body: NetZeroBusinessTravelActivityData): Observable<NetZeroBusinessTravelActivityData> {
        let url_ = this.baseUrl + "/net_zero_business_travel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroBusinessTravelActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroBusinessTravelActivityData>;
        }));
    }

    protected processCreateOneBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response: HttpResponseBase): Observable<NetZeroBusinessTravelActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NetZeroBusinessTravelActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple NetZeroBusinessTravelActivityData
     * @return Get create many base response
     */
    createManyBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(body: CreateManyNetZeroBusinessTravelActivityDataDto): Observable<NetZeroBusinessTravelActivityData[]> {
        let url_ = this.baseUrl + "/net_zero_business_travel/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroBusinessTravelActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroBusinessTravelActivityData[]>;
        }));
    }

    protected processCreateManyBaseNetZeroBusinessTravelActivityDataControllerNetZeroBusinessTravelActivityData(response: HttpResponseBase): Observable<NetZeroBusinessTravelActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(NetZeroBusinessTravelActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single NetZeroEmployeeCommutingActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<NetZeroEmployeeCommutingActivityData> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroEmployeeCommutingActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroEmployeeCommutingActivityData>;
        }));
    }

    protected processGetOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response: HttpResponseBase): Observable<NetZeroEmployeeCommutingActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetZeroEmployeeCommutingActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single NetZeroEmployeeCommutingActivityData
     * @return Response
     */
    updateOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(id: number, body: NetZeroEmployeeCommutingActivityData): Observable<NetZeroEmployeeCommutingActivityData> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroEmployeeCommutingActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroEmployeeCommutingActivityData>;
        }));
    }

    protected processUpdateOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response: HttpResponseBase): Observable<NetZeroEmployeeCommutingActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetZeroEmployeeCommutingActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single NetZeroEmployeeCommutingActivityData
     * @return Response
     */
    replaceOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(id: number, body: NetZeroEmployeeCommutingActivityData): Observable<NetZeroEmployeeCommutingActivityData> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroEmployeeCommutingActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroEmployeeCommutingActivityData>;
        }));
    }

    protected processReplaceOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response: HttpResponseBase): Observable<NetZeroEmployeeCommutingActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetZeroEmployeeCommutingActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single NetZeroEmployeeCommutingActivityData
     * @return Delete one base response
     */
    deleteOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple NetZeroEmployeeCommutingActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyNetZeroEmployeeCommutingActivityDataResponseDto> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyNetZeroEmployeeCommutingActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyNetZeroEmployeeCommutingActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response: HttpResponseBase): Observable<GetManyNetZeroEmployeeCommutingActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyNetZeroEmployeeCommutingActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single NetZeroEmployeeCommutingActivityData
     * @return Get create one base response
     */
    createOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(body: NetZeroEmployeeCommutingActivityData): Observable<NetZeroEmployeeCommutingActivityData> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroEmployeeCommutingActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroEmployeeCommutingActivityData>;
        }));
    }

    protected processCreateOneBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response: HttpResponseBase): Observable<NetZeroEmployeeCommutingActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NetZeroEmployeeCommutingActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple NetZeroEmployeeCommutingActivityData
     * @return Get create many base response
     */
    createManyBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(body: CreateManyNetZeroEmployeeCommutingActivityDataDto): Observable<NetZeroEmployeeCommutingActivityData[]> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroEmployeeCommutingActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroEmployeeCommutingActivityData[]>;
        }));
    }

    protected processCreateManyBaseNetZeroEmployeeCommutingActivityDataControllerNetZeroEmployeeCommutingActivityData(response: HttpResponseBase): Observable<NetZeroEmployeeCommutingActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(NetZeroEmployeeCommutingActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single EndOfLifeTreatmentOfSoldProductsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/eolt-sold-products/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
        }));
    }

    protected processGetOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response: HttpResponseBase): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EndOfLifeTreatmentOfSoldProductsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single EndOfLifeTreatmentOfSoldProductsActivityData
     * @return Response
     */
    updateOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(id: number, body: EndOfLifeTreatmentOfSoldProductsActivityData): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/eolt-sold-products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
        }));
    }

    protected processUpdateOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response: HttpResponseBase): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EndOfLifeTreatmentOfSoldProductsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single EndOfLifeTreatmentOfSoldProductsActivityData
     * @return Response
     */
    replaceOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(id: number, body: EndOfLifeTreatmentOfSoldProductsActivityData): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/eolt-sold-products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
        }));
    }

    protected processReplaceOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response: HttpResponseBase): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EndOfLifeTreatmentOfSoldProductsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single EndOfLifeTreatmentOfSoldProductsActivityData
     * @return Delete one base response
     */
    deleteOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/eolt-sold-products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple EndOfLifeTreatmentOfSoldProductsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto> {
        let url_ = this.baseUrl + "/eolt-sold-products?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response: HttpResponseBase): Observable<GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single EndOfLifeTreatmentOfSoldProductsActivityData
     * @return Get create one base response
     */
    createOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(body: EndOfLifeTreatmentOfSoldProductsActivityData): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/eolt-sold-products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
        }));
    }

    protected processCreateOneBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response: HttpResponseBase): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EndOfLifeTreatmentOfSoldProductsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple EndOfLifeTreatmentOfSoldProductsActivityData
     * @return Get create many base response
     */
    createManyBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(body: CreateManyEndOfLifeTreatmentOfSoldProductsActivityDataDto): Observable<EndOfLifeTreatmentOfSoldProductsActivityData[]> {
        let url_ = this.baseUrl + "/eolt-sold-products/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData[]>;
        }));
    }

    protected processCreateManyBaseEndOfLifeTreatmentOfSoldProductsActivityDataControllerEndOfLifeTreatmentOfSoldProductsActivityData(response: HttpResponseBase): Observable<EndOfLifeTreatmentOfSoldProductsActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(EndOfLifeTreatmentOfSoldProductsActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single UpstreamLeasedAssetsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<UpstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamLeasedAssetsActivityData>;
        }));
    }

    protected processGetOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<UpstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpstreamLeasedAssetsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single UpstreamLeasedAssetsActivityData
     * @return Response
     */
    updateOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(id: number, body: UpstreamLeasedAssetsActivityData): Observable<UpstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamLeasedAssetsActivityData>;
        }));
    }

    protected processUpdateOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<UpstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpstreamLeasedAssetsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single UpstreamLeasedAssetsActivityData
     * @return Response
     */
    replaceOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(id: number, body: UpstreamLeasedAssetsActivityData): Observable<UpstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamLeasedAssetsActivityData>;
        }));
    }

    protected processReplaceOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<UpstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpstreamLeasedAssetsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single UpstreamLeasedAssetsActivityData
     * @return Delete one base response
     */
    deleteOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple UpstreamLeasedAssetsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUpstreamLeasedAssetsActivityDataResponseDto> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyUpstreamLeasedAssetsActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyUpstreamLeasedAssetsActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<GetManyUpstreamLeasedAssetsActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUpstreamLeasedAssetsActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single UpstreamLeasedAssetsActivityData
     * @return Get create one base response
     */
    createOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(body: UpstreamLeasedAssetsActivityData): Observable<UpstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamLeasedAssetsActivityData>;
        }));
    }

    protected processCreateOneBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<UpstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UpstreamLeasedAssetsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple UpstreamLeasedAssetsActivityData
     * @return Get create many base response
     */
    createManyBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(body: CreateManyUpstreamLeasedAssetsActivityDataDto): Observable<UpstreamLeasedAssetsActivityData[]> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamLeasedAssetsActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamLeasedAssetsActivityData[]>;
        }));
    }

    protected processCreateManyBaseUpstreamLeasedAssetsActivityDataControllerUpstreamLeasedAssetsActivityData(response: HttpResponseBase): Observable<UpstreamLeasedAssetsActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(UpstreamLeasedAssetsActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ProcessingOfSoldProductsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProcessingOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessingOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessingOfSoldProductsActivityData>;
        }));
    }

    protected processGetOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response: HttpResponseBase): Observable<ProcessingOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessingOfSoldProductsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ProcessingOfSoldProductsActivityData
     * @return Response
     */
    updateOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(id: number, body: ProcessingOfSoldProductsActivityData): Observable<ProcessingOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessingOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessingOfSoldProductsActivityData>;
        }));
    }

    protected processUpdateOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response: HttpResponseBase): Observable<ProcessingOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessingOfSoldProductsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ProcessingOfSoldProductsActivityData
     * @return Response
     */
    replaceOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(id: number, body: ProcessingOfSoldProductsActivityData): Observable<ProcessingOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessingOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessingOfSoldProductsActivityData>;
        }));
    }

    protected processReplaceOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response: HttpResponseBase): Observable<ProcessingOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessingOfSoldProductsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ProcessingOfSoldProductsActivityData
     * @return Delete one base response
     */
    deleteOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ProcessingOfSoldProductsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProcessingOfSoldProductsActivityDataResponseDto> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProcessingOfSoldProductsActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProcessingOfSoldProductsActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response: HttpResponseBase): Observable<GetManyProcessingOfSoldProductsActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProcessingOfSoldProductsActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ProcessingOfSoldProductsActivityData
     * @return Get create one base response
     */
    createOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(body: ProcessingOfSoldProductsActivityData): Observable<ProcessingOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessingOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessingOfSoldProductsActivityData>;
        }));
    }

    protected processCreateOneBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response: HttpResponseBase): Observable<ProcessingOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProcessingOfSoldProductsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ProcessingOfSoldProductsActivityData
     * @return Get create many base response
     */
    createManyBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(body: CreateManyProcessingOfSoldProductsActivityDataDto): Observable<ProcessingOfSoldProductsActivityData[]> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessingOfSoldProductsActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessingOfSoldProductsActivityData[]>;
        }));
    }

    protected processCreateManyBaseProcessingOfSoldProductsActivityDataControllerProcessingOfSoldProductsActivityData(response: HttpResponseBase): Observable<ProcessingOfSoldProductsActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProcessingOfSoldProductsActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single FranchisesActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFranchisesActivityDataControllerFranchisesActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FranchisesActivityData> {
        let url_ = this.baseUrl + "/franchises/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FranchisesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FranchisesActivityData>;
        }));
    }

    protected processGetOneBaseFranchisesActivityDataControllerFranchisesActivityData(response: HttpResponseBase): Observable<FranchisesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FranchisesActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single FranchisesActivityData
     * @return Response
     */
    updateOneBaseFranchisesActivityDataControllerFranchisesActivityData(id: number, body: FranchisesActivityData): Observable<FranchisesActivityData> {
        let url_ = this.baseUrl + "/franchises/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FranchisesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FranchisesActivityData>;
        }));
    }

    protected processUpdateOneBaseFranchisesActivityDataControllerFranchisesActivityData(response: HttpResponseBase): Observable<FranchisesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FranchisesActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single FranchisesActivityData
     * @return Response
     */
    replaceOneBaseFranchisesActivityDataControllerFranchisesActivityData(id: number, body: FranchisesActivityData): Observable<FranchisesActivityData> {
        let url_ = this.baseUrl + "/franchises/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FranchisesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FranchisesActivityData>;
        }));
    }

    protected processReplaceOneBaseFranchisesActivityDataControllerFranchisesActivityData(response: HttpResponseBase): Observable<FranchisesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FranchisesActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single FranchisesActivityData
     * @return Delete one base response
     */
    deleteOneBaseFranchisesActivityDataControllerFranchisesActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/franchises/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseFranchisesActivityDataControllerFranchisesActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple FranchisesActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFranchisesActivityDataControllerFranchisesActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFranchisesActivityDataResponseDto> {
        let url_ = this.baseUrl + "/franchises?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFranchisesActivityDataControllerFranchisesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFranchisesActivityDataControllerFranchisesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyFranchisesActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyFranchisesActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseFranchisesActivityDataControllerFranchisesActivityData(response: HttpResponseBase): Observable<GetManyFranchisesActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFranchisesActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single FranchisesActivityData
     * @return Get create one base response
     */
    createOneBaseFranchisesActivityDataControllerFranchisesActivityData(body: FranchisesActivityData): Observable<FranchisesActivityData> {
        let url_ = this.baseUrl + "/franchises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFranchisesActivityDataControllerFranchisesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FranchisesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FranchisesActivityData>;
        }));
    }

    protected processCreateOneBaseFranchisesActivityDataControllerFranchisesActivityData(response: HttpResponseBase): Observable<FranchisesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FranchisesActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple FranchisesActivityData
     * @return Get create many base response
     */
    createManyBaseFranchisesActivityDataControllerFranchisesActivityData(body: CreateManyFranchisesActivityDataDto): Observable<FranchisesActivityData[]> {
        let url_ = this.baseUrl + "/franchises/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFranchisesActivityDataControllerFranchisesActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFranchisesActivityDataControllerFranchisesActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FranchisesActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FranchisesActivityData[]>;
        }));
    }

    protected processCreateManyBaseFranchisesActivityDataControllerFranchisesActivityData(response: HttpResponseBase): Observable<FranchisesActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FranchisesActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single DownstreamTransportationActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<DownstreamTransportationActivityData> {
        let url_ = this.baseUrl + "/downstream-transportation/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamTransportationActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamTransportationActivityData>;
        }));
    }

    protected processGetOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response: HttpResponseBase): Observable<DownstreamTransportationActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownstreamTransportationActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single DownstreamTransportationActivityData
     * @return Response
     */
    updateOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(id: number, body: DownstreamTransportationActivityData): Observable<DownstreamTransportationActivityData> {
        let url_ = this.baseUrl + "/downstream-transportation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamTransportationActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamTransportationActivityData>;
        }));
    }

    protected processUpdateOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response: HttpResponseBase): Observable<DownstreamTransportationActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownstreamTransportationActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single DownstreamTransportationActivityData
     * @return Response
     */
    replaceOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(id: number, body: DownstreamTransportationActivityData): Observable<DownstreamTransportationActivityData> {
        let url_ = this.baseUrl + "/downstream-transportation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamTransportationActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamTransportationActivityData>;
        }));
    }

    protected processReplaceOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response: HttpResponseBase): Observable<DownstreamTransportationActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownstreamTransportationActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single DownstreamTransportationActivityData
     * @return Delete one base response
     */
    deleteOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/downstream-transportation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple DownstreamTransportationActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyDownstreamTransportationActivityDataResponseDto> {
        let url_ = this.baseUrl + "/downstream-transportation?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyDownstreamTransportationActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyDownstreamTransportationActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response: HttpResponseBase): Observable<GetManyDownstreamTransportationActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyDownstreamTransportationActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single DownstreamTransportationActivityData
     * @return Get create one base response
     */
    createOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(body: DownstreamTransportationActivityData): Observable<DownstreamTransportationActivityData> {
        let url_ = this.baseUrl + "/downstream-transportation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamTransportationActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamTransportationActivityData>;
        }));
    }

    protected processCreateOneBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response: HttpResponseBase): Observable<DownstreamTransportationActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DownstreamTransportationActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple DownstreamTransportationActivityData
     * @return Get create many base response
     */
    createManyBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(body: CreateManyDownstreamTransportationActivityDataDto): Observable<DownstreamTransportationActivityData[]> {
        let url_ = this.baseUrl + "/downstream-transportation/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamTransportationActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamTransportationActivityData[]>;
        }));
    }

    protected processCreateManyBaseDownstreamTransportationActivityDataControllerDownstreamTransportationActivityData(response: HttpResponseBase): Observable<DownstreamTransportationActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(DownstreamTransportationActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single UpstreamTransportationActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<UpstreamTransportationActivityData> {
        let url_ = this.baseUrl + "/upstream-transportation/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamTransportationActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamTransportationActivityData>;
        }));
    }

    protected processGetOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response: HttpResponseBase): Observable<UpstreamTransportationActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpstreamTransportationActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single UpstreamTransportationActivityData
     * @return Response
     */
    updateOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(id: number, body: UpstreamTransportationActivityData): Observable<UpstreamTransportationActivityData> {
        let url_ = this.baseUrl + "/upstream-transportation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamTransportationActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamTransportationActivityData>;
        }));
    }

    protected processUpdateOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response: HttpResponseBase): Observable<UpstreamTransportationActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpstreamTransportationActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single UpstreamTransportationActivityData
     * @return Response
     */
    replaceOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(id: number, body: UpstreamTransportationActivityData): Observable<UpstreamTransportationActivityData> {
        let url_ = this.baseUrl + "/upstream-transportation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamTransportationActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamTransportationActivityData>;
        }));
    }

    protected processReplaceOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response: HttpResponseBase): Observable<UpstreamTransportationActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpstreamTransportationActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single UpstreamTransportationActivityData
     * @return Delete one base response
     */
    deleteOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/upstream-transportation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple UpstreamTransportationActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUpstreamTransportationActivityDataResponseDto> {
        let url_ = this.baseUrl + "/upstream-transportation?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyUpstreamTransportationActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyUpstreamTransportationActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response: HttpResponseBase): Observable<GetManyUpstreamTransportationActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUpstreamTransportationActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single UpstreamTransportationActivityData
     * @return Get create one base response
     */
    createOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(body: UpstreamTransportationActivityData): Observable<UpstreamTransportationActivityData> {
        let url_ = this.baseUrl + "/upstream-transportation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamTransportationActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamTransportationActivityData>;
        }));
    }

    protected processCreateOneBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response: HttpResponseBase): Observable<UpstreamTransportationActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UpstreamTransportationActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple UpstreamTransportationActivityData
     * @return Get create many base response
     */
    createManyBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(body: CreateManyUpstreamTransportationActivityDataDto): Observable<UpstreamTransportationActivityData[]> {
        let url_ = this.baseUrl + "/upstream-transportation/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamTransportationActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamTransportationActivityData[]>;
        }));
    }

    protected processCreateManyBaseUpstreamTransportationActivityDataControllerUpstreamTransportationActivityData(response: HttpResponseBase): Observable<UpstreamTransportationActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(UpstreamTransportationActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single NetZeroUseOfSoldProductActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<NetZeroUseOfSoldProductActivityData> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroUseOfSoldProductActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroUseOfSoldProductActivityData>;
        }));
    }

    protected processGetOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response: HttpResponseBase): Observable<NetZeroUseOfSoldProductActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetZeroUseOfSoldProductActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single NetZeroUseOfSoldProductActivityData
     * @return Response
     */
    updateOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(id: number, body: NetZeroUseOfSoldProductActivityData): Observable<NetZeroUseOfSoldProductActivityData> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroUseOfSoldProductActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroUseOfSoldProductActivityData>;
        }));
    }

    protected processUpdateOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response: HttpResponseBase): Observable<NetZeroUseOfSoldProductActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetZeroUseOfSoldProductActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single NetZeroUseOfSoldProductActivityData
     * @return Response
     */
    replaceOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(id: number, body: NetZeroUseOfSoldProductActivityData): Observable<NetZeroUseOfSoldProductActivityData> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroUseOfSoldProductActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroUseOfSoldProductActivityData>;
        }));
    }

    protected processReplaceOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response: HttpResponseBase): Observable<NetZeroUseOfSoldProductActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetZeroUseOfSoldProductActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single NetZeroUseOfSoldProductActivityData
     * @return Delete one base response
     */
    deleteOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple NetZeroUseOfSoldProductActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyNetZeroUseOfSoldProductActivityDataResponseDto> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyNetZeroUseOfSoldProductActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyNetZeroUseOfSoldProductActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response: HttpResponseBase): Observable<GetManyNetZeroUseOfSoldProductActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyNetZeroUseOfSoldProductActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single NetZeroUseOfSoldProductActivityData
     * @return Get create one base response
     */
    createOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(body: NetZeroUseOfSoldProductActivityData): Observable<NetZeroUseOfSoldProductActivityData> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroUseOfSoldProductActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroUseOfSoldProductActivityData>;
        }));
    }

    protected processCreateOneBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response: HttpResponseBase): Observable<NetZeroUseOfSoldProductActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NetZeroUseOfSoldProductActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple NetZeroUseOfSoldProductActivityData
     * @return Get create many base response
     */
    createManyBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(body: CreateManyNetZeroUseOfSoldProductActivityDataDto): Observable<NetZeroUseOfSoldProductActivityData[]> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroUseOfSoldProductActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroUseOfSoldProductActivityData[]>;
        }));
    }

    protected processCreateManyBaseNetZeroUseOfSoldProductsActivityDataControllerNetZeroUseOfSoldProductActivityData(response: HttpResponseBase): Observable<NetZeroUseOfSoldProductActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(NetZeroUseOfSoldProductActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single CapitalGoodsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<CapitalGoodsActivityData> {
        let url_ = this.baseUrl + "/capital-goods/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CapitalGoodsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CapitalGoodsActivityData>;
        }));
    }

    protected processGetOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response: HttpResponseBase): Observable<CapitalGoodsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CapitalGoodsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single CapitalGoodsActivityData
     * @return Response
     */
    updateOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(id: number, body: CapitalGoodsActivityData): Observable<CapitalGoodsActivityData> {
        let url_ = this.baseUrl + "/capital-goods/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CapitalGoodsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CapitalGoodsActivityData>;
        }));
    }

    protected processUpdateOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response: HttpResponseBase): Observable<CapitalGoodsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CapitalGoodsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single CapitalGoodsActivityData
     * @return Response
     */
    replaceOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(id: number, body: CapitalGoodsActivityData): Observable<CapitalGoodsActivityData> {
        let url_ = this.baseUrl + "/capital-goods/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CapitalGoodsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CapitalGoodsActivityData>;
        }));
    }

    protected processReplaceOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response: HttpResponseBase): Observable<CapitalGoodsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CapitalGoodsActivityData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single CapitalGoodsActivityData
     * @return Delete one base response
     */
    deleteOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/capital-goods/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple CapitalGoodsActivityData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyCapitalGoodsActivityDataResponseDto> {
        let url_ = this.baseUrl + "/capital-goods?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyCapitalGoodsActivityDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyCapitalGoodsActivityDataResponseDto>;
        }));
    }

    protected processGetManyBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response: HttpResponseBase): Observable<GetManyCapitalGoodsActivityDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyCapitalGoodsActivityDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single CapitalGoodsActivityData
     * @return Get create one base response
     */
    createOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(body: CapitalGoodsActivityData): Observable<CapitalGoodsActivityData> {
        let url_ = this.baseUrl + "/capital-goods";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CapitalGoodsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CapitalGoodsActivityData>;
        }));
    }

    protected processCreateOneBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response: HttpResponseBase): Observable<CapitalGoodsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CapitalGoodsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple CapitalGoodsActivityData
     * @return Get create many base response
     */
    createManyBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(body: CreateManyCapitalGoodsActivityDataDto): Observable<CapitalGoodsActivityData[]> {
        let url_ = this.baseUrl + "/capital-goods/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CapitalGoodsActivityData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CapitalGoodsActivityData[]>;
        }));
    }

    protected processCreateManyBaseCapitalGoodsActivityDataControllerCapitalGoodsActivityData(response: HttpResponseBase): Observable<CapitalGoodsActivityData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(CapitalGoodsActivityData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Parameter
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseParameterControllerParameter(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Parameter> {
        let url_ = this.baseUrl + "/parameter/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseParameterControllerParameter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Parameter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Parameter>;
        }));
    }

    protected processGetOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Parameter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Parameter
     * @return Response
     */
    updateOneBaseParameterControllerParameter(id: number, body: Parameter): Observable<Parameter> {
        let url_ = this.baseUrl + "/parameter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseParameterControllerParameter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Parameter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Parameter>;
        }));
    }

    protected processUpdateOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Parameter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Parameter
     * @return Response
     */
    replaceOneBaseParameterControllerParameter(id: number, body: Parameter): Observable<Parameter> {
        let url_ = this.baseUrl + "/parameter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseParameterControllerParameter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Parameter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Parameter>;
        }));
    }

    protected processReplaceOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Parameter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Parameter
     * @return Delete one base response
     */
    deleteOneBaseParameterControllerParameter(id: number): Observable<void> {
        let url_ = this.baseUrl + "/parameter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseParameterControllerParameter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Parameters
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseParameterControllerParameter(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyParameterResponseDto> {
        let url_ = this.baseUrl + "/parameter?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseParameterControllerParameter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyParameterResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyParameterResponseDto>;
        }));
    }

    protected processGetManyBaseParameterControllerParameter(response: HttpResponseBase): Observable<GetManyParameterResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyParameterResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Parameter
     * @return Get create one base response
     */
    createOneBaseParameterControllerParameter(body: Parameter): Observable<Parameter> {
        let url_ = this.baseUrl + "/parameter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseParameterControllerParameter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Parameter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Parameter>;
        }));
    }

    protected processCreateOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Parameter.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Parameters
     * @return Get create many base response
     */
    createManyBaseParameterControllerParameter(body: CreateManyParameterDto): Observable<Parameter[]> {
        let url_ = this.baseUrl + "/parameter/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseParameterControllerParameter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Parameter[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Parameter[]>;
        }));
    }

    protected processCreateManyBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Parameter.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Report
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseReportControllerReport(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Report> {
        let url_ = this.baseUrl + "/report/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report>;
        }));
    }

    protected processGetOneBaseReportControllerReport(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Report
     * @return Response
     */
    updateOneBaseReportControllerReport(id: number, body: Report): Observable<Report> {
        let url_ = this.baseUrl + "/report/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report>;
        }));
    }

    protected processUpdateOneBaseReportControllerReport(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Report
     * @return Response
     */
    replaceOneBaseReportControllerReport(id: number, body: Report): Observable<Report> {
        let url_ = this.baseUrl + "/report/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report>;
        }));
    }

    protected processReplaceOneBaseReportControllerReport(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Report
     * @return Delete one base response
     */
    deleteOneBaseReportControllerReport(id: number): Observable<void> {
        let url_ = this.baseUrl + "/report/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseReportControllerReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Reports
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseReportControllerReport(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyReportResponseDto> {
        let url_ = this.baseUrl + "/report?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyReportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyReportResponseDto>;
        }));
    }

    protected processGetManyBaseReportControllerReport(response: HttpResponseBase): Observable<GetManyReportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyReportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Report
     * @return Get create one base response
     */
    createOneBaseReportControllerReport(body: Report): Observable<Report> {
        let url_ = this.baseUrl + "/report";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report>;
        }));
    }

    protected processCreateOneBaseReportControllerReport(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Report.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Reports
     * @return Get create many base response
     */
    createManyBaseReportControllerReport(body: CreateManyReportDto): Observable<Report[]> {
        let url_ = this.baseUrl + "/report/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report[]>;
        }));
    }

    protected processCreateManyBaseReportControllerReport(response: HttpResponseBase): Observable<Report[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Report.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ReportHistory
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseReportHistoryControllerReportHistory(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ReportHistory> {
        let url_ = this.baseUrl + "/report-history/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseReportHistoryControllerReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseReportHistoryControllerReportHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportHistory>;
        }));
    }

    protected processGetOneBaseReportHistoryControllerReportHistory(response: HttpResponseBase): Observable<ReportHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ReportHistory
     * @return Response
     */
    updateOneBaseReportHistoryControllerReportHistory(id: number, body: ReportHistory): Observable<ReportHistory> {
        let url_ = this.baseUrl + "/report-history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseReportHistoryControllerReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseReportHistoryControllerReportHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportHistory>;
        }));
    }

    protected processUpdateOneBaseReportHistoryControllerReportHistory(response: HttpResponseBase): Observable<ReportHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ReportHistory
     * @return Response
     */
    replaceOneBaseReportHistoryControllerReportHistory(id: number, body: ReportHistory): Observable<ReportHistory> {
        let url_ = this.baseUrl + "/report-history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseReportHistoryControllerReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseReportHistoryControllerReportHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportHistory>;
        }));
    }

    protected processReplaceOneBaseReportHistoryControllerReportHistory(response: HttpResponseBase): Observable<ReportHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ReportHistory
     * @return Delete one base response
     */
    deleteOneBaseReportHistoryControllerReportHistory(id: number): Observable<void> {
        let url_ = this.baseUrl + "/report-history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseReportHistoryControllerReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseReportHistoryControllerReportHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseReportHistoryControllerReportHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ReportHistories
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseReportHistoryControllerReportHistory(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyReportHistoryResponseDto> {
        let url_ = this.baseUrl + "/report-history?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseReportHistoryControllerReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseReportHistoryControllerReportHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyReportHistoryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyReportHistoryResponseDto>;
        }));
    }

    protected processGetManyBaseReportHistoryControllerReportHistory(response: HttpResponseBase): Observable<GetManyReportHistoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyReportHistoryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ReportHistory
     * @return Get create one base response
     */
    createOneBaseReportHistoryControllerReportHistory(body: ReportHistory): Observable<ReportHistory> {
        let url_ = this.baseUrl + "/report-history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseReportHistoryControllerReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseReportHistoryControllerReportHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportHistory>;
        }));
    }

    protected processCreateOneBaseReportHistoryControllerReportHistory(response: HttpResponseBase): Observable<ReportHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ReportHistory.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ReportHistories
     * @return Get create many base response
     */
    createManyBaseReportHistoryControllerReportHistory(body: CreateManyReportHistoryDto): Observable<ReportHistory[]> {
        let url_ = this.baseUrl + "/report-history/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseReportHistoryControllerReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseReportHistoryControllerReportHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportHistory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportHistory[]>;
        }));
    }

    protected processCreateManyBaseReportHistoryControllerReportHistory(response: HttpResponseBase): Observable<ReportHistory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ReportHistory.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Uncertainty
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUncertaintyControllerUncertainty(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Uncertainty> {
        let url_ = this.baseUrl + "/uncertainty/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUncertaintyControllerUncertainty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUncertaintyControllerUncertainty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Uncertainty>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Uncertainty>;
        }));
    }

    protected processGetOneBaseUncertaintyControllerUncertainty(response: HttpResponseBase): Observable<Uncertainty> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Uncertainty.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Uncertainty
     * @return Response
     */
    updateOneBaseUncertaintyControllerUncertainty(id: number, body: Uncertainty): Observable<Uncertainty> {
        let url_ = this.baseUrl + "/uncertainty/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUncertaintyControllerUncertainty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUncertaintyControllerUncertainty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Uncertainty>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Uncertainty>;
        }));
    }

    protected processUpdateOneBaseUncertaintyControllerUncertainty(response: HttpResponseBase): Observable<Uncertainty> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Uncertainty.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Uncertainty
     * @return Response
     */
    replaceOneBaseUncertaintyControllerUncertainty(id: number, body: Uncertainty): Observable<Uncertainty> {
        let url_ = this.baseUrl + "/uncertainty/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUncertaintyControllerUncertainty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUncertaintyControllerUncertainty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Uncertainty>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Uncertainty>;
        }));
    }

    protected processReplaceOneBaseUncertaintyControllerUncertainty(response: HttpResponseBase): Observable<Uncertainty> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Uncertainty.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Uncertainty
     * @return Delete one base response
     */
    deleteOneBaseUncertaintyControllerUncertainty(id: number): Observable<void> {
        let url_ = this.baseUrl + "/uncertainty/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUncertaintyControllerUncertainty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUncertaintyControllerUncertainty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseUncertaintyControllerUncertainty(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Uncertainties
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUncertaintyControllerUncertainty(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUncertaintyResponseDto> {
        let url_ = this.baseUrl + "/uncertainty?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUncertaintyControllerUncertainty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUncertaintyControllerUncertainty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyUncertaintyResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyUncertaintyResponseDto>;
        }));
    }

    protected processGetManyBaseUncertaintyControllerUncertainty(response: HttpResponseBase): Observable<GetManyUncertaintyResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUncertaintyResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Uncertainty
     * @return Get create one base response
     */
    createOneBaseUncertaintyControllerUncertainty(body: Uncertainty): Observable<Uncertainty> {
        let url_ = this.baseUrl + "/uncertainty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUncertaintyControllerUncertainty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUncertaintyControllerUncertainty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Uncertainty>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Uncertainty>;
        }));
    }

    protected processCreateOneBaseUncertaintyControllerUncertainty(response: HttpResponseBase): Observable<Uncertainty> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Uncertainty.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Uncertainties
     * @return Get create many base response
     */
    createManyBaseUncertaintyControllerUncertainty(body: CreateManyUncertaintyDto): Observable<Uncertainty[]> {
        let url_ = this.baseUrl + "/uncertainty/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUncertaintyControllerUncertainty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUncertaintyControllerUncertainty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Uncertainty[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Uncertainty[]>;
        }));
    }

    protected processCreateManyBaseUncertaintyControllerUncertainty(response: HttpResponseBase): Observable<Uncertainty[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Uncertainty.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single AirPortsDis
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseAirPortDisControllerAirPortsDis(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<AirPortsDis> {
        let url_ = this.baseUrl + "/airdis/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseAirPortDisControllerAirPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseAirPortDisControllerAirPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPortsDis>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPortsDis>;
        }));
    }

    protected processGetOneBaseAirPortDisControllerAirPortsDis(response: HttpResponseBase): Observable<AirPortsDis> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AirPortsDis.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single AirPortsDis
     * @return Response
     */
    updateOneBaseAirPortDisControllerAirPortsDis(id: number, body: AirPortsDis): Observable<AirPortsDis> {
        let url_ = this.baseUrl + "/airdis/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseAirPortDisControllerAirPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseAirPortDisControllerAirPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPortsDis>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPortsDis>;
        }));
    }

    protected processUpdateOneBaseAirPortDisControllerAirPortsDis(response: HttpResponseBase): Observable<AirPortsDis> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AirPortsDis.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single AirPortsDis
     * @return Response
     */
    replaceOneBaseAirPortDisControllerAirPortsDis(id: number, body: AirPortsDis): Observable<AirPortsDis> {
        let url_ = this.baseUrl + "/airdis/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseAirPortDisControllerAirPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseAirPortDisControllerAirPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPortsDis>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPortsDis>;
        }));
    }

    protected processReplaceOneBaseAirPortDisControllerAirPortsDis(response: HttpResponseBase): Observable<AirPortsDis> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AirPortsDis.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single AirPortsDis
     * @return Delete one base response
     */
    deleteOneBaseAirPortDisControllerAirPortsDis(id: number): Observable<void> {
        let url_ = this.baseUrl + "/airdis/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseAirPortDisControllerAirPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseAirPortDisControllerAirPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseAirPortDisControllerAirPortsDis(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple AirPortsDis
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseAirPortDisControllerAirPortsDis(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyAirPortsDisResponseDto> {
        let url_ = this.baseUrl + "/airdis?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseAirPortDisControllerAirPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseAirPortDisControllerAirPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyAirPortsDisResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyAirPortsDisResponseDto>;
        }));
    }

    protected processGetManyBaseAirPortDisControllerAirPortsDis(response: HttpResponseBase): Observable<GetManyAirPortsDisResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyAirPortsDisResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single AirPortsDis
     * @return Get create one base response
     */
    createOneBaseAirPortDisControllerAirPortsDis(body: AirPortsDis): Observable<AirPortsDis> {
        let url_ = this.baseUrl + "/airdis";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseAirPortDisControllerAirPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseAirPortDisControllerAirPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPortsDis>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPortsDis>;
        }));
    }

    protected processCreateOneBaseAirPortDisControllerAirPortsDis(response: HttpResponseBase): Observable<AirPortsDis> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AirPortsDis.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple AirPortsDis
     * @return Get create many base response
     */
    createManyBaseAirPortDisControllerAirPortsDis(body: CreateManyAirPortsDisDto): Observable<AirPortsDis[]> {
        let url_ = this.baseUrl + "/airdis/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseAirPortDisControllerAirPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseAirPortDisControllerAirPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPortsDis[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPortsDis[]>;
        }));
    }

    protected processCreateManyBaseAirPortDisControllerAirPortsDis(response: HttpResponseBase): Observable<AirPortsDis[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(AirPortsDis.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single SeaPortsDis
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseSeaPortsDisControllerSeaPortsDis(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<SeaPortsDis> {
        let url_ = this.baseUrl + "/seaportsdis/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseSeaPortsDisControllerSeaPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseSeaPortsDisControllerSeaPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPortsDis>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPortsDis>;
        }));
    }

    protected processGetOneBaseSeaPortsDisControllerSeaPortsDis(response: HttpResponseBase): Observable<SeaPortsDis> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeaPortsDis.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single SeaPortsDis
     * @return Response
     */
    updateOneBaseSeaPortsDisControllerSeaPortsDis(id: number, body: SeaPortsDis): Observable<SeaPortsDis> {
        let url_ = this.baseUrl + "/seaportsdis/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseSeaPortsDisControllerSeaPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseSeaPortsDisControllerSeaPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPortsDis>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPortsDis>;
        }));
    }

    protected processUpdateOneBaseSeaPortsDisControllerSeaPortsDis(response: HttpResponseBase): Observable<SeaPortsDis> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeaPortsDis.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single SeaPortsDis
     * @return Response
     */
    replaceOneBaseSeaPortsDisControllerSeaPortsDis(id: number, body: SeaPortsDis): Observable<SeaPortsDis> {
        let url_ = this.baseUrl + "/seaportsdis/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseSeaPortsDisControllerSeaPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseSeaPortsDisControllerSeaPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPortsDis>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPortsDis>;
        }));
    }

    protected processReplaceOneBaseSeaPortsDisControllerSeaPortsDis(response: HttpResponseBase): Observable<SeaPortsDis> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeaPortsDis.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single SeaPortsDis
     * @return Delete one base response
     */
    deleteOneBaseSeaPortsDisControllerSeaPortsDis(id: number): Observable<void> {
        let url_ = this.baseUrl + "/seaportsdis/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseSeaPortsDisControllerSeaPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseSeaPortsDisControllerSeaPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseSeaPortsDisControllerSeaPortsDis(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple SeaPortsDis
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseSeaPortsDisControllerSeaPortsDis(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManySeaPortsDisResponseDto> {
        let url_ = this.baseUrl + "/seaportsdis?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseSeaPortsDisControllerSeaPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseSeaPortsDisControllerSeaPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManySeaPortsDisResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManySeaPortsDisResponseDto>;
        }));
    }

    protected processGetManyBaseSeaPortsDisControllerSeaPortsDis(response: HttpResponseBase): Observable<GetManySeaPortsDisResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManySeaPortsDisResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single SeaPortsDis
     * @return Get create one base response
     */
    createOneBaseSeaPortsDisControllerSeaPortsDis(body: SeaPortsDis): Observable<SeaPortsDis> {
        let url_ = this.baseUrl + "/seaportsdis";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseSeaPortsDisControllerSeaPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseSeaPortsDisControllerSeaPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPortsDis>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPortsDis>;
        }));
    }

    protected processCreateOneBaseSeaPortsDisControllerSeaPortsDis(response: HttpResponseBase): Observable<SeaPortsDis> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SeaPortsDis.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple SeaPortsDis
     * @return Get create many base response
     */
    createManyBaseSeaPortsDisControllerSeaPortsDis(body: CreateManySeaPortsDisDto): Observable<SeaPortsDis[]> {
        let url_ = this.baseUrl + "/seaportsdis/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseSeaPortsDisControllerSeaPortsDis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseSeaPortsDisControllerSeaPortsDis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPortsDis[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPortsDis[]>;
        }));
    }

    protected processCreateManyBaseSeaPortsDisControllerSeaPortsDis(response: HttpResponseBase): Observable<SeaPortsDis[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(SeaPortsDis.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single AirPort
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseAirPortControllerAirPort(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<AirPort> {
        let url_ = this.baseUrl + "/airports/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseAirPortControllerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseAirPortControllerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPort>;
        }));
    }

    protected processGetOneBaseAirPortControllerAirPort(response: HttpResponseBase): Observable<AirPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AirPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single AirPort
     * @return Response
     */
    updateOneBaseAirPortControllerAirPort(id: number, body: AirPort): Observable<AirPort> {
        let url_ = this.baseUrl + "/airports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseAirPortControllerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseAirPortControllerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPort>;
        }));
    }

    protected processUpdateOneBaseAirPortControllerAirPort(response: HttpResponseBase): Observable<AirPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AirPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single AirPort
     * @return Response
     */
    replaceOneBaseAirPortControllerAirPort(id: number, body: AirPort): Observable<AirPort> {
        let url_ = this.baseUrl + "/airports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseAirPortControllerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseAirPortControllerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPort>;
        }));
    }

    protected processReplaceOneBaseAirPortControllerAirPort(response: HttpResponseBase): Observable<AirPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AirPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single AirPort
     * @return Delete one base response
     */
    deleteOneBaseAirPortControllerAirPort(id: number): Observable<void> {
        let url_ = this.baseUrl + "/airports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseAirPortControllerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseAirPortControllerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseAirPortControllerAirPort(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple AirPorts
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseAirPortControllerAirPort(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyAirPortResponseDto> {
        let url_ = this.baseUrl + "/airports?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseAirPortControllerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseAirPortControllerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyAirPortResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyAirPortResponseDto>;
        }));
    }

    protected processGetManyBaseAirPortControllerAirPort(response: HttpResponseBase): Observable<GetManyAirPortResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyAirPortResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single AirPort
     * @return Get create one base response
     */
    createOneBaseAirPortControllerAirPort(body: AirPort): Observable<AirPort> {
        let url_ = this.baseUrl + "/airports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseAirPortControllerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseAirPortControllerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPort>;
        }));
    }

    protected processCreateOneBaseAirPortControllerAirPort(response: HttpResponseBase): Observable<AirPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AirPort.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple AirPorts
     * @return Get create many base response
     */
    createManyBaseAirPortControllerAirPort(body: CreateManyAirPortDto): Observable<AirPort[]> {
        let url_ = this.baseUrl + "/airports/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseAirPortControllerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseAirPortControllerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPort[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPort[]>;
        }));
    }

    protected processCreateManyBaseAirPortControllerAirPort(response: HttpResponseBase): Observable<AirPort[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(AirPort.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single SeaPort
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseSeaPortControllerSeaPort(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<SeaPort> {
        let url_ = this.baseUrl + "/seaports/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseSeaPortControllerSeaPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseSeaPortControllerSeaPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPort>;
        }));
    }

    protected processGetOneBaseSeaPortControllerSeaPort(response: HttpResponseBase): Observable<SeaPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeaPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single SeaPort
     * @return Response
     */
    updateOneBaseSeaPortControllerSeaPort(id: number, body: SeaPort): Observable<SeaPort> {
        let url_ = this.baseUrl + "/seaports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseSeaPortControllerSeaPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseSeaPortControllerSeaPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPort>;
        }));
    }

    protected processUpdateOneBaseSeaPortControllerSeaPort(response: HttpResponseBase): Observable<SeaPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeaPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single SeaPort
     * @return Response
     */
    replaceOneBaseSeaPortControllerSeaPort(id: number, body: SeaPort): Observable<SeaPort> {
        let url_ = this.baseUrl + "/seaports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseSeaPortControllerSeaPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseSeaPortControllerSeaPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPort>;
        }));
    }

    protected processReplaceOneBaseSeaPortControllerSeaPort(response: HttpResponseBase): Observable<SeaPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeaPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single SeaPort
     * @return Delete one base response
     */
    deleteOneBaseSeaPortControllerSeaPort(id: number): Observable<void> {
        let url_ = this.baseUrl + "/seaports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseSeaPortControllerSeaPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseSeaPortControllerSeaPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseSeaPortControllerSeaPort(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple SeaPorts
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseSeaPortControllerSeaPort(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManySeaPortResponseDto> {
        let url_ = this.baseUrl + "/seaports?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseSeaPortControllerSeaPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseSeaPortControllerSeaPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManySeaPortResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManySeaPortResponseDto>;
        }));
    }

    protected processGetManyBaseSeaPortControllerSeaPort(response: HttpResponseBase): Observable<GetManySeaPortResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManySeaPortResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single SeaPort
     * @return Get create one base response
     */
    createOneBaseSeaPortControllerSeaPort(body: SeaPort): Observable<SeaPort> {
        let url_ = this.baseUrl + "/seaports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseSeaPortControllerSeaPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseSeaPortControllerSeaPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPort>;
        }));
    }

    protected processCreateOneBaseSeaPortControllerSeaPort(response: HttpResponseBase): Observable<SeaPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SeaPort.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple SeaPorts
     * @return Get create many base response
     */
    createManyBaseSeaPortControllerSeaPort(body: CreateManySeaPortDto): Observable<SeaPort[]> {
        let url_ = this.baseUrl + "/seaports/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseSeaPortControllerSeaPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseSeaPortControllerSeaPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPort[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPort[]>;
        }));
    }

    protected processCreateManyBaseSeaPortControllerSeaPort(response: HttpResponseBase): Observable<SeaPort[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(SeaPort.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single RailPort
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseRailPortControllerRailPort(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<RailPort> {
        let url_ = this.baseUrl + "/railports/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseRailPortControllerRailPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseRailPortControllerRailPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RailPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RailPort>;
        }));
    }

    protected processGetOneBaseRailPortControllerRailPort(response: HttpResponseBase): Observable<RailPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RailPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single RailPort
     * @return Response
     */
    updateOneBaseRailPortControllerRailPort(id: number, body: RailPort): Observable<RailPort> {
        let url_ = this.baseUrl + "/railports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseRailPortControllerRailPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseRailPortControllerRailPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RailPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RailPort>;
        }));
    }

    protected processUpdateOneBaseRailPortControllerRailPort(response: HttpResponseBase): Observable<RailPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RailPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single RailPort
     * @return Response
     */
    replaceOneBaseRailPortControllerRailPort(id: number, body: RailPort): Observable<RailPort> {
        let url_ = this.baseUrl + "/railports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseRailPortControllerRailPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseRailPortControllerRailPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RailPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RailPort>;
        }));
    }

    protected processReplaceOneBaseRailPortControllerRailPort(response: HttpResponseBase): Observable<RailPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RailPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single RailPort
     * @return Delete one base response
     */
    deleteOneBaseRailPortControllerRailPort(id: number): Observable<void> {
        let url_ = this.baseUrl + "/railports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseRailPortControllerRailPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseRailPortControllerRailPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseRailPortControllerRailPort(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple RailPorts
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseRailPortControllerRailPort(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyRailPortResponseDto> {
        let url_ = this.baseUrl + "/railports?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseRailPortControllerRailPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseRailPortControllerRailPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyRailPortResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyRailPortResponseDto>;
        }));
    }

    protected processGetManyBaseRailPortControllerRailPort(response: HttpResponseBase): Observable<GetManyRailPortResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyRailPortResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single RailPort
     * @return Get create one base response
     */
    createOneBaseRailPortControllerRailPort(body: RailPort): Observable<RailPort> {
        let url_ = this.baseUrl + "/railports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseRailPortControllerRailPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseRailPortControllerRailPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RailPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RailPort>;
        }));
    }

    protected processCreateOneBaseRailPortControllerRailPort(response: HttpResponseBase): Observable<RailPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RailPort.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple RailPorts
     * @return Get create many base response
     */
    createManyBaseRailPortControllerRailPort(body: CreateManyRailPortDto): Observable<RailPort[]> {
        let url_ = this.baseUrl + "/railports/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseRailPortControllerRailPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseRailPortControllerRailPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RailPort[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RailPort[]>;
        }));
    }

    protected processCreateManyBaseRailPortControllerRailPort(response: HttpResponseBase): Observable<RailPort[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(RailPort.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single PassengerAirPort
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePassengerAirPortControllerPassengerAirPort(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PassengerAirPort> {
        let url_ = this.baseUrl + "/passenger-air-port/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePassengerAirPortControllerPassengerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePassengerAirPortControllerPassengerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirPort>;
        }));
    }

    protected processGetOneBasePassengerAirPortControllerPassengerAirPort(response: HttpResponseBase): Observable<PassengerAirPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerAirPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single PassengerAirPort
     * @return Response
     */
    updateOneBasePassengerAirPortControllerPassengerAirPort(id: number, body: PassengerAirPort): Observable<PassengerAirPort> {
        let url_ = this.baseUrl + "/passenger-air-port/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePassengerAirPortControllerPassengerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePassengerAirPortControllerPassengerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirPort>;
        }));
    }

    protected processUpdateOneBasePassengerAirPortControllerPassengerAirPort(response: HttpResponseBase): Observable<PassengerAirPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerAirPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single PassengerAirPort
     * @return Response
     */
    replaceOneBasePassengerAirPortControllerPassengerAirPort(id: number, body: PassengerAirPort): Observable<PassengerAirPort> {
        let url_ = this.baseUrl + "/passenger-air-port/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePassengerAirPortControllerPassengerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePassengerAirPortControllerPassengerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirPort>;
        }));
    }

    protected processReplaceOneBasePassengerAirPortControllerPassengerAirPort(response: HttpResponseBase): Observable<PassengerAirPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerAirPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single PassengerAirPort
     * @return Delete one base response
     */
    deleteOneBasePassengerAirPortControllerPassengerAirPort(id: number): Observable<void> {
        let url_ = this.baseUrl + "/passenger-air-port/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePassengerAirPortControllerPassengerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePassengerAirPortControllerPassengerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBasePassengerAirPortControllerPassengerAirPort(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple PassengerAirPorts
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePassengerAirPortControllerPassengerAirPort(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPassengerAirPortResponseDto> {
        let url_ = this.baseUrl + "/passenger-air-port?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePassengerAirPortControllerPassengerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePassengerAirPortControllerPassengerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyPassengerAirPortResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyPassengerAirPortResponseDto>;
        }));
    }

    protected processGetManyBasePassengerAirPortControllerPassengerAirPort(response: HttpResponseBase): Observable<GetManyPassengerAirPortResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPassengerAirPortResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single PassengerAirPort
     * @return Get create one base response
     */
    createOneBasePassengerAirPortControllerPassengerAirPort(body: PassengerAirPort): Observable<PassengerAirPort> {
        let url_ = this.baseUrl + "/passenger-air-port";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePassengerAirPortControllerPassengerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePassengerAirPortControllerPassengerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirPort>;
        }));
    }

    protected processCreateOneBasePassengerAirPortControllerPassengerAirPort(response: HttpResponseBase): Observable<PassengerAirPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PassengerAirPort.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple PassengerAirPorts
     * @return Get create many base response
     */
    createManyBasePassengerAirPortControllerPassengerAirPort(body: CreateManyPassengerAirPortDto): Observable<PassengerAirPort[]> {
        let url_ = this.baseUrl + "/passenger-air-port/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePassengerAirPortControllerPassengerAirPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePassengerAirPortControllerPassengerAirPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirPort[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirPort[]>;
        }));
    }

    protected processCreateManyBasePassengerAirPortControllerPassengerAirPort(response: HttpResponseBase): Observable<PassengerAirPort[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PassengerAirPort.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Mitigation
     * @return Get create one base response
     */
    createOneBaseMitigationControllerMitigation(body: Mitigation): Observable<Mitigation> {
        let url_ = this.baseUrl + "/mitigation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseMitigationControllerMitigation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Mitigation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Mitigation>;
        }));
    }

    protected processCreateOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Mitigation.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Mitigations
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseMitigationControllerMitigation(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyMitigationResponseDto> {
        let url_ = this.baseUrl + "/mitigation?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseMitigationControllerMitigation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyMitigationResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyMitigationResponseDto>;
        }));
    }

    protected processGetManyBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<GetManyMitigationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyMitigationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Mitigation
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseMitigationControllerMitigation(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Mitigation> {
        let url_ = this.baseUrl + "/mitigation/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseMitigationControllerMitigation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Mitigation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Mitigation>;
        }));
    }

    protected processGetOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Mitigation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Mitigation
     * @return Response
     */
    updateOneBaseMitigationControllerMitigation(id: number, body: Mitigation): Observable<Mitigation> {
        let url_ = this.baseUrl + "/mitigation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseMitigationControllerMitigation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Mitigation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Mitigation>;
        }));
    }

    protected processUpdateOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Mitigation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Mitigation
     * @return Response
     */
    replaceOneBaseMitigationControllerMitigation(id: number, body: Mitigation): Observable<Mitigation> {
        let url_ = this.baseUrl + "/mitigation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseMitigationControllerMitigation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Mitigation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Mitigation>;
        }));
    }

    protected processReplaceOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Mitigation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Mitigation
     * @return Delete one base response
     */
    deleteOneBaseMitigationControllerMitigation(id: number): Observable<void> {
        let url_ = this.baseUrl + "/mitigation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseMitigationControllerMitigation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Mitigations
     * @return Get create many base response
     */
    createManyBaseMitigationControllerMitigation(body: CreateManyMitigationDto): Observable<Mitigation[]> {
        let url_ = this.baseUrl + "/mitigation/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseMitigationControllerMitigation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Mitigation[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Mitigation[]>;
        }));
    }

    protected processCreateManyBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Mitigation.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single NextStep
     * @return Get create one base response
     */
    createOneBaseNextStepsControllerNextStep(body: NextStep): Observable<NextStep> {
        let url_ = this.baseUrl + "/next-steps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseNextStepsControllerNextStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseNextStepsControllerNextStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NextStep>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NextStep>;
        }));
    }

    protected processCreateOneBaseNextStepsControllerNextStep(response: HttpResponseBase): Observable<NextStep> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NextStep.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple NextSteps
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseNextStepsControllerNextStep(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyNextStepResponseDto> {
        let url_ = this.baseUrl + "/next-steps?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseNextStepsControllerNextStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseNextStepsControllerNextStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyNextStepResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyNextStepResponseDto>;
        }));
    }

    protected processGetManyBaseNextStepsControllerNextStep(response: HttpResponseBase): Observable<GetManyNextStepResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyNextStepResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single NextStep
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseNextStepsControllerNextStep(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<NextStep> {
        let url_ = this.baseUrl + "/next-steps/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseNextStepsControllerNextStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseNextStepsControllerNextStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NextStep>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NextStep>;
        }));
    }

    protected processGetOneBaseNextStepsControllerNextStep(response: HttpResponseBase): Observable<NextStep> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NextStep.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single NextStep
     * @return Response
     */
    updateOneBaseNextStepsControllerNextStep(id: number, body: NextStep): Observable<NextStep> {
        let url_ = this.baseUrl + "/next-steps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseNextStepsControllerNextStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseNextStepsControllerNextStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NextStep>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NextStep>;
        }));
    }

    protected processUpdateOneBaseNextStepsControllerNextStep(response: HttpResponseBase): Observable<NextStep> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NextStep.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single NextStep
     * @return Response
     */
    replaceOneBaseNextStepsControllerNextStep(id: number, body: NextStep): Observable<NextStep> {
        let url_ = this.baseUrl + "/next-steps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseNextStepsControllerNextStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseNextStepsControllerNextStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NextStep>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NextStep>;
        }));
    }

    protected processReplaceOneBaseNextStepsControllerNextStep(response: HttpResponseBase): Observable<NextStep> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NextStep.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single NextStep
     * @return Delete one base response
     */
    deleteOneBaseNextStepsControllerNextStep(id: number): Observable<void> {
        let url_ = this.baseUrl + "/next-steps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseNextStepsControllerNextStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseNextStepsControllerNextStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseNextStepsControllerNextStep(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple NextSteps
     * @return Get create many base response
     */
    createManyBaseNextStepsControllerNextStep(body: CreateManyNextStepDto): Observable<NextStep[]> {
        let url_ = this.baseUrl + "/next-steps/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseNextStepsControllerNextStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseNextStepsControllerNextStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NextStep[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NextStep[]>;
        }));
    }

    protected processCreateManyBaseNextStepsControllerNextStep(response: HttpResponseBase): Observable<NextStep[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(NextStep.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Recomendation
     * @return Get create one base response
     */
    createOneBaseRecomendationControllerRecomendation(body: Recomendation): Observable<Recomendation> {
        let url_ = this.baseUrl + "/recomendation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseRecomendationControllerRecomendation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseRecomendationControllerRecomendation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Recomendation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Recomendation>;
        }));
    }

    protected processCreateOneBaseRecomendationControllerRecomendation(response: HttpResponseBase): Observable<Recomendation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Recomendation.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Recomendations
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseRecomendationControllerRecomendation(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyRecomendationResponseDto> {
        let url_ = this.baseUrl + "/recomendation?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseRecomendationControllerRecomendation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseRecomendationControllerRecomendation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyRecomendationResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyRecomendationResponseDto>;
        }));
    }

    protected processGetManyBaseRecomendationControllerRecomendation(response: HttpResponseBase): Observable<GetManyRecomendationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyRecomendationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Recomendation
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseRecomendationControllerRecomendation(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Recomendation> {
        let url_ = this.baseUrl + "/recomendation/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseRecomendationControllerRecomendation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseRecomendationControllerRecomendation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Recomendation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Recomendation>;
        }));
    }

    protected processGetOneBaseRecomendationControllerRecomendation(response: HttpResponseBase): Observable<Recomendation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Recomendation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Recomendation
     * @return Response
     */
    updateOneBaseRecomendationControllerRecomendation(id: number, body: Recomendation): Observable<Recomendation> {
        let url_ = this.baseUrl + "/recomendation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseRecomendationControllerRecomendation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseRecomendationControllerRecomendation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Recomendation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Recomendation>;
        }));
    }

    protected processUpdateOneBaseRecomendationControllerRecomendation(response: HttpResponseBase): Observable<Recomendation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Recomendation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Recomendation
     * @return Response
     */
    replaceOneBaseRecomendationControllerRecomendation(id: number, body: Recomendation): Observable<Recomendation> {
        let url_ = this.baseUrl + "/recomendation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseRecomendationControllerRecomendation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseRecomendationControllerRecomendation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Recomendation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Recomendation>;
        }));
    }

    protected processReplaceOneBaseRecomendationControllerRecomendation(response: HttpResponseBase): Observable<Recomendation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Recomendation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Recomendation
     * @return Delete one base response
     */
    deleteOneBaseRecomendationControllerRecomendation(id: number): Observable<void> {
        let url_ = this.baseUrl + "/recomendation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseRecomendationControllerRecomendation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseRecomendationControllerRecomendation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseRecomendationControllerRecomendation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Recomendations
     * @return Get create many base response
     */
    createManyBaseRecomendationControllerRecomendation(body: CreateManyRecomendationDto): Observable<Recomendation[]> {
        let url_ = this.baseUrl + "/recomendation/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseRecomendationControllerRecomendation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseRecomendationControllerRecomendation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Recomendation[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Recomendation[]>;
        }));
    }

    protected processCreateManyBaseRecomendationControllerRecomendation(response: HttpResponseBase): Observable<Recomendation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Recomendation.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UsersControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUsersByRole(unitId: string, role: string): Observable<User[]> {
        let url_ = this.baseUrl + "/users/users-by-role?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        if (role === undefined || role === null)
            throw new Error("The parameter 'role' must be defined and cannot be null.");
        else
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersByRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersByRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User[]>;
        }));
    }

    protected processGetUsersByRole(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserDetailsWithLoginProfile(id: number): Observable<UserWithLoginProfileDto> {
        let url_ = this.baseUrl + "/users/with-login-profile?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetailsWithLoginProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetailsWithLoginProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserWithLoginProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserWithLoginProfileDto>;
        }));
    }

    protected processGetUserDetailsWithLoginProfile(response: HttpResponseBase): Observable<UserWithLoginProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserWithLoginProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addMasterAdmin(body: CreateUserDto): Observable<any> {
        let url_ = this.baseUrl + "/users/add-master-admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMasterAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMasterAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processAddMasterAdmin(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUnitByEmail(email: string): Observable<Unit> {
        let url_ = this.baseUrl + "/users/unit-by-email?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processGetUnitByEmail(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserByEmail(email: string): Observable<User> {
        let url_ = this.baseUrl + "/users/get-user-by-email?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetUserByEmail(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllowedUnits(email: string): Observable<any> {
        let url_ = this.baseUrl + "/users/get-allowed-units-by-email?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllowedUnits(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllowedFPProjects(email: string): Observable<any> {
        let url_ = this.baseUrl + "/users/get-allowed-projects-by-email?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedFPProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedFPProjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllowedFPProjects(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUsersCount(unitId: string): Observable<any> {
        let url_ = this.baseUrl + "/users/get-users-count?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetUsersCount(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportUsers(unitId: string, isAll: string): Observable<ExportUserDto> {
        let url_ = this.baseUrl + "/users/export-users?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        if (isAll === undefined || isAll === null)
            throw new Error("The parameter 'isAll' must be defined and cannot be null.");
        else
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportUserDto>;
        }));
    }

    protected processExportUsers(response: HttpResponseBase): Observable<ExportUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addFromExcel(): Observable<any[]> {
        let url_ = this.baseUrl + "/users/import-users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processAddFromExcel(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(item);
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addAllowedUnits(email: string, unitIds: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/users/add-allowed-unit?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (unitIds === undefined || unitIds === null)
            throw new Error("The parameter 'unitIds' must be defined and cannot be null.");
        else
            unitIds && unitIds.forEach(item => { url_ += "unitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAllowedUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAllowedUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddAllowedUnits(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveAllowedFPProjects(email: string, projectIds: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/users/add-allowed-fp-projects?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (projectIds === undefined || projectIds === null)
            throw new Error("The parameter 'projectIds' must be defined and cannot be null.");
        else
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAllowedFPProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAllowedFPProjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveAllowedFPProjects(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UnitControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addFromExcel(): Observable<void> {
        let url_ = this.baseUrl + "/unit/add-from-excell";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddFromExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeStatus(id: number, status: string): Observable<Unit> {
        let url_ = this.baseUrl + "/unit/changeStatus?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processChangeStatus(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeStatusOfAll(parentUnitId: number, status: string): Observable<Unit> {
        let url_ = this.baseUrl + "/unit/changeStatus-all-child-units?";
        if (parentUnitId === undefined || parentUnitId === null)
            throw new Error("The parameter 'parentUnitId' must be defined and cannot be null.");
        else
            url_ += "parentUnitId=" + encodeURIComponent("" + parentUnitId) + "&";
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeStatusOfAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeStatusOfAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processChangeStatusOfAll(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getConsecutiveYears(unitId: number, projectTypeId: number): Observable<ConsecutiveYears> {
        let url_ = this.baseUrl + "/unit/get-consecutive-years?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        if (projectTypeId === undefined || projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' must be defined and cannot be null.");
        else
            url_ += "projectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsecutiveYears(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsecutiveYears(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsecutiveYears>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsecutiveYears>;
        }));
    }

    protected processGetConsecutiveYears(response: HttpResponseBase): Observable<ConsecutiveYears> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsecutiveYears.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getParentChildUnits(unitId: number): Observable<ParentChildCountDto> {
        let url_ = this.baseUrl + "/unit/get-parent-child-count?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentChildUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentChildUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParentChildCountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParentChildCountDto>;
        }));
    }

    protected processGetParentChildUnits(response: HttpResponseBase): Observable<ParentChildCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParentChildCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChildUnits(unitId: number): Observable<Unit[]> {
        let url_ = this.baseUrl + "/unit/get-get-child-units?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit[]>;
        }));
    }

    protected processGetChildUnits(response: HttpResponseBase): Observable<Unit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Unit.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChildUnitIds(unitId: number): Observable<number[]> {
        let url_ = this.baseUrl + "/unit/get-get-child-unit-ids?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildUnitIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildUnitIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetChildUnitIds(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUnitsWithParent(body: ByUnitIdsDto): Observable<Unit[]> {
        let url_ = this.baseUrl + "/unit/get-units-with-parent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitsWithParent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitsWithParent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit[]>;
        }));
    }

    protected processGetUnitsWithParent(response: HttpResponseBase): Observable<Unit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Unit.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UnitDetailsControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    uploadFileImg(): Observable<UnitDetails> {
        let url_ = this.baseUrl + "/unit-details/upload-img/{uid}";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFileImg(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFileImg(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDetails>;
        }));
    }

    protected processUploadFileImg(response: HttpResponseBase): Observable<UnitDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UnitDetails.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NumEmployeesControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTotalEmployees(projectId: number): Observable<number> {
        let url_ = this.baseUrl + "/num-employees/get-total-employees?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTotalEmployees(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadBulkUnitEmployee(): Observable<void> {
        let url_ = this.baseUrl + "/num-employees/upload-bulk-unit-employee";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadBulkUnitEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadBulkUnitEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadBulkUnitEmployee(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVariableMapping(): Observable<void> {
        let url_ = this.baseUrl + "/num-employees/get-variable-mapping-employee-num";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVariableMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVariableMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetVariableMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmissionBaseControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addFromExcel(projectId: number, esId: number, unitId: number, userId: number): Observable<void> {
        let url_ = this.baseUrl + "/emission-base/add-from-excell?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (esId === undefined || esId === null)
            throw new Error("The parameter 'esId' must be defined and cannot be null.");
        else
            url_ += "esId=" + encodeURIComponent("" + esId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddFromExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    bulkDelete(body: BulckDeletDto): Observable<any> {
        let url_ = this.baseUrl + "/emission-base/bulk-delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processBulkDelete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVariableMapping(esCode: string): Observable<any> {
        let url_ = this.baseUrl + "/emission-base/get-variable-mapping?";
        if (esCode === undefined || esCode === null)
            throw new Error("The parameter 'esCode' must be defined and cannot be null.");
        else
            url_ += "esCode=" + encodeURIComponent("" + esCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVariableMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVariableMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetVariableMapping(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadBulkMultiUnit(projectId: number, esCode: string, userId: number): Observable<any> {
        let url_ = this.baseUrl + "/emission-base/upload-bulk-multi-unit?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (esCode === undefined || esCode === null)
            throw new Error("The parameter 'esCode' must be defined and cannot be null.");
        else
            url_ += "esCode=" + encodeURIComponent("" + esCode) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadBulkMultiUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadBulkMultiUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processUploadBulkMultiUnit(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadBulk(projectId: number, esCode: string, unitId: number, userId: number, ownerShip: string, isMobile: string): Observable<void> {
        let url_ = this.baseUrl + "/emission-base/upload-bulk?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (esCode === undefined || esCode === null)
            throw new Error("The parameter 'esCode' must be defined and cannot be null.");
        else
            url_ += "esCode=" + encodeURIComponent("" + esCode) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (ownerShip === undefined || ownerShip === null)
            throw new Error("The parameter 'ownerShip' must be defined and cannot be null.");
        else
            url_ += "ownerShip=" + encodeURIComponent("" + ownerShip) + "&";
        if (isMobile === undefined || isMobile === null)
            throw new Error("The parameter 'isMobile' must be defined and cannot be null.");
        else
            url_ += "isMobile=" + encodeURIComponent("" + isMobile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadBulk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadBulk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadBulk(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadAirports(): Observable<void> {
        let url_ = this.baseUrl + "/emission-base/upload-airports";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadAirports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadAirports(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadAirports(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTotal(projectId: number, unitId: number): Observable<void> {
        let url_ = this.baseUrl + "/emission-base/update-total?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTotal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTotal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTotal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getManyActivityData(body: ManyActivityDataDto): Observable<any[]> {
        let url_ = this.baseUrl + "/emission-base/get-many-activity-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processGetManyActivityData(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(item);
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    bulkRecalculate(body: BulckCalculatio): Observable<any> {
        let url_ = this.baseUrl + "/emission-base/bulk-recalculate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkRecalculate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkRecalculate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processBulkRecalculate(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getManyActivityDataForEsList(body: ManyActivityDataDto): Observable<void> {
        let url_ = this.baseUrl + "/emission-base/get-many-activity-data-for-es-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyActivityDataForEsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyActivityDataForEsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetManyActivityDataForEsList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnv(): Observable<string> {
        let url_ = this.baseUrl + "/emission-base/env";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnv(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetEnv(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    validateMonth(source: string, projectId: number, unitId: number, year: string, month: number): Observable<boolean> {
        let url_ = this.baseUrl + "/emission-base/validate-month?";
        if (source === undefined || source === null)
            throw new Error("The parameter 'source' must be defined and cannot be null.");
        else
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined and cannot be null.");
        else
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (month === undefined || month === null)
            throw new Error("The parameter 'month' must be defined and cannot be null.");
        else
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateMonth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidateMonth(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProgressData(projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/emission-base/progress-data?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgressData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgressData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetProgressData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    modifyActivityData(body: ProgressDetailDto): Observable<any> {
        let url_ = this.baseUrl + "/emission-base/progress-detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModifyActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModifyActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processModifyActivityData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    generateActivityData(body: ProgressDetailDto): Observable<any> {
        let url_ = this.baseUrl + "/emission-base/progress-detail-es";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGenerateActivityData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadActivityData(body: ActivityDataDownloadDto): Observable<any> {
        let url_ = this.baseUrl + "/emission-base/download-ac-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDownloadActivityData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProjectControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getProjectEmissionSources(id: number): Observable<PesEmissionsDto[]> {
        let url_ = this.baseUrl + "/project/get-emission-source-of-project?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectEmissionSources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectEmissionSources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PesEmissionsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PesEmissionsDto[]>;
        }));
    }

    protected processGetProjectEmissionSources(response: HttpResponseBase): Observable<PesEmissionsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PesEmissionsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProjectUnitEmissionSources(id: number): Observable<ProjectUnitEmissionSource[]> {
        let url_ = this.baseUrl + "/project/get-emission-source-of-project-unit?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectUnitEmissionSources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectUnitEmissionSources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnitEmissionSource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnitEmissionSource[]>;
        }));
    }

    protected processGetProjectUnitEmissionSources(response: HttpResponseBase): Observable<ProjectUnitEmissionSource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProjectUnitEmissionSource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeEmissionSourceOfProject(body: EmissionSourceOfProject): Observable<void> {
        let url_ = this.baseUrl + "/project/remove-emission-source-of-project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmissionSourceOfProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmissionSourceOfProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveEmissionSourceOfProject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addEmissionSourceOfProject(body: EmissionSourceOfProject): Observable<any> {
        let url_ = this.baseUrl + "/project/add-emission-source-of-project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmissionSourceOfProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmissionSourceOfProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processAddEmissionSourceOfProject(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeEmissionSourceOfProjectUnit(body: EmissionSourceOfProjectUnit): Observable<void> {
        let url_ = this.baseUrl + "/project/remove-emission-source-of-project-unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmissionSourceOfProjectUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmissionSourceOfProjectUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveEmissionSourceOfProjectUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addEmissionSourceOfProjectUnit(body: EmissionSourceOfProjectUnit): Observable<any> {
        let url_ = this.baseUrl + "/project/add-emission-source-of-project-unit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmissionSourceOfProjectUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmissionSourceOfProjectUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processAddEmissionSourceOfProjectUnit(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeEmissionSourceOfProjectMultiple(body: EmissionSourceListOfProject): Observable<void> {
        let url_ = this.baseUrl + "/project/remove-emission-source-of-project-multiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmissionSourceOfProjectMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmissionSourceOfProjectMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveEmissionSourceOfProjectMultiple(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addEmissionSourceOfProjectMultiple(body: EmissionSourceListOfProject): Observable<any[]> {
        let url_ = this.baseUrl + "/project/add-emission-source-of-project-multiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmissionSourceOfProjectMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmissionSourceOfProjectMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processAddEmissionSourceOfProjectMultiple(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(item);
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addEmissionSourceOfProjectUnitMultiple(body: ListOfEmissionSourceOfProjectUnit): Observable<any[]> {
        let url_ = this.baseUrl + "/project/add-emission-source-of-project-unit-multiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmissionSourceOfProjectUnitMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmissionSourceOfProjectUnitMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processAddEmissionSourceOfProjectUnitMultiple(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(item);
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeStatus(id: number, status: string): Observable<Project> {
        let url_ = this.baseUrl + "/project/changeStatus?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project>;
        }));
    }

    protected processChangeStatus(response: HttpResponseBase): Observable<Project> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addPaymentRef(id: number, ref: string): Observable<Project> {
        let url_ = this.baseUrl + "/project/add-payment-ref?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined and cannot be null.");
        else
            url_ += "ref=" + encodeURIComponent("" + ref) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPaymentRef(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPaymentRef(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project>;
        }));
    }

    protected processAddPaymentRef(response: HttpResponseBase): Observable<Project> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setOwnerUnit(id: number, unitId: number): Observable<void> {
        let url_ = this.baseUrl + "/project/set-owner-unit?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOwnerUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOwnerUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetOwnerUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrgEmissions(unitIds: string[], projectType: string): Observable<OrgEmissionDto> {
        let url_ = this.baseUrl + "/project/get-org-emissions?";
        if (unitIds === undefined || unitIds === null)
            throw new Error("The parameter 'unitIds' must be defined and cannot be null.");
        else
            unitIds && unitIds.forEach(item => { url_ += "unitIds=" + encodeURIComponent("" + item) + "&"; });
        if (projectType === undefined || projectType === null)
            throw new Error("The parameter 'projectType' must be defined and cannot be null.");
        else
            url_ += "projectType=" + encodeURIComponent("" + projectType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrgEmissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrgEmissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrgEmissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrgEmissionDto>;
        }));
    }

    protected processGetOrgEmissions(response: HttpResponseBase): Observable<OrgEmissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrgEmissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getClosedAndActiveProjectsCount(unitId: number): Observable<ActiveClosedProjectDto> {
        let url_ = this.baseUrl + "/project/get-closed-active-projects-count?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClosedAndActiveProjectsCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClosedAndActiveProjectsCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActiveClosedProjectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActiveClosedProjectDto>;
        }));
    }

    protected processGetClosedAndActiveProjectsCount(response: HttpResponseBase): Observable<ActiveClosedProjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActiveClosedProjectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProjectUnitControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getProjectUnitByProjectType(body: ProjectTypeDto): Observable<any> {
        let url_ = this.baseUrl + "/project-unit/get-project-unit-by-project-type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectUnitByProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectUnitByProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetProjectUnitByProjectType(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProjectUnitsByUntIds(body: ByUnitIdsDto): Observable<ProjectUnit[]> {
        let url_ = this.baseUrl + "/project-unit/get-projects-unit-by-unit-ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectUnitsByUntIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectUnitsByUntIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnit[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnit[]>;
        }));
    }

    protected processGetProjectUnitsByUntIds(response: HttpResponseBase): Observable<ProjectUnit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectUnit.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProjectUnitsByUntIdsAndProject(body: ByUnitIdsDto): Observable<ProjectUnit[]> {
        let url_ = this.baseUrl + "/project-unit/get-projects-unit-by-unit-ids-and-project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectUnitsByUntIdsAndProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectUnitsByUntIdsAndProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectUnit[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectUnit[]>;
        }));
    }

    protected processGetProjectUnitsByUntIdsAndProject(response: HttpResponseBase): Observable<ProjectUnit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectUnit.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProjectUnitEmissionSourceControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEmissionsByType(projectId: number): Observable<any> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-emissions-by-type?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmissionsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmissionsByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetEmissionsByType(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProjectUnitByType(unitId: number, type: string, projectType: string): Observable<any> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-project-unit-by-type?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (projectType === undefined || projectType === null)
            throw new Error("The parameter 'projectType' must be defined and cannot be null.");
        else
            url_ += "projectType=" + encodeURIComponent("" + projectType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectUnitByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectUnitByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetProjectUnitByType(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPuesData(body: PuesDataReqDto): Observable<PuesDataDto> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-pues-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPuesData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPuesData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PuesDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PuesDataDto>;
        }));
    }

    protected processGetPuesData(response: HttpResponseBase): Observable<PuesDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PuesDataDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    hasPUES(unitId: number, projectId: number, esCode: string): Observable<boolean> {
        let url_ = this.baseUrl + "/project-unit-emission-source/has-PUES?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (esCode === undefined || esCode === null)
            throw new Error("The parameter 'esCode' must be defined and cannot be null.");
        else
            url_ += "esCode=" + encodeURIComponent("" + esCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasPUES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasPUES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processHasPUES(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrgEmissionSourceEmissions(unitId: string[], projectType: string): Observable<OrgEmissionDto> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-org-es-emissions?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            unitId && unitId.forEach(item => { url_ += "unitId=" + encodeURIComponent("" + item) + "&"; });
        if (projectType === undefined || projectType === null)
            throw new Error("The parameter 'projectType' must be defined and cannot be null.");
        else
            url_ += "projectType=" + encodeURIComponent("" + projectType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrgEmissionSourceEmissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrgEmissionSourceEmissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrgEmissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrgEmissionDto>;
        }));
    }

    protected processGetOrgEmissionSourceEmissions(response: HttpResponseBase): Observable<OrgEmissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrgEmissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSumForProjectUnits(body: ProjectTypeDto): Observable<any> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-sum-for-project-units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSumForProjectUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSumForProjectUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetSumForProjectUnits(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSumForProjectUnitsForOrgDashboard(body: ProjectTypeDto): Observable<EmissionSumDto> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-sum-for-project-units-for-org-dashboard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSumForProjectUnitsForOrgDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSumForProjectUnitsForOrgDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionSumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionSumDto>;
        }));
    }

    protected processGetSumForProjectUnitsForOrgDashboard(response: HttpResponseBase): Observable<EmissionSumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EmissionSumDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllowedUnitsforProjectAndEs(es: string, projectId: number): Observable<any> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-allowed-units-for--roject-and-es?";
        if (es === undefined || es === null)
            throw new Error("The parameter 'es' must be defined and cannot be null.");
        else
            url_ += "es=" + encodeURIComponent("" + es) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedUnitsforProjectAndEs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedUnitsforProjectAndEs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllowedUnitsforProjectAndEs(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProjectUnitESListByProjectUntIds(body: ByProjectUnitIdsDto): Observable<any> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-projects-unit-eslist-by-project-unit-ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectUnitESListByProjectUntIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectUnitESListByProjectUntIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetProjectUnitESListByProjectUntIds(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    pUESListBYProjectAndUYnit(unitId: number, projectId: number): Observable<void> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-pues-list-by-project-and-unit?";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPUESListBYProjectAndUYnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPUESListBYProjectAndUYnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPUESListBYProjectAndUYnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPUESAndUnit(projectId: number): Observable<any> {
        let url_ = this.baseUrl + "/project-unit-emission-source/get-pues-and-unit?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPUESAndUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPUESAndUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetPUESAndUnit(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    esEmissionChartData(body: ProjectTypeDto): Observable<any> {
        let url_ = this.baseUrl + "/project-unit-emission-source/es-emission-chart-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEsEmissionChartData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEsEmissionChartData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processEsEmissionChartData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProjectEmissionFactorControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEmissionFactors(esCodes: string[], projectId: number): Observable<any[]> {
        let url_ = this.baseUrl + "/project-emission-factor/get-emission-factors?";
        if (esCodes === undefined || esCodes === null)
            throw new Error("The parameter 'esCodes' must be defined and cannot be null.");
        else
            esCodes && esCodes.forEach(item => { url_ += "esCodes=" + encodeURIComponent("" + item) + "&"; });
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmissionFactors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmissionFactors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processGetEmissionFactors(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(item);
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCommonEmissionFactors(): Observable<any[]> {
        let url_ = this.baseUrl + "/project-emission-factor/get-emission-factors-report";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommonEmissionFactors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommonEmissionFactors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processGetCommonEmissionFactors(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(item);
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmissionSourceControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    seed(): Observable<void> {
        let url_ = this.baseUrl + "/emission-source/seed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSeed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProjectEmissionSourceControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    etEmissionsTotals(id: number): Observable<any[]> {
        let url_ = this.baseUrl + "/project-emission-source/get-emissions-totals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEtEmissionsTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEtEmissionsTotals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processEtEmissionsTotals(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EvidenceRequestControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    requestEvidence(body: EvidenceRequestDto): Observable<EvidenceRequest> {
        let url_ = this.baseUrl + "/evidence-request/request-evidence";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestEvidence(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestEvidence(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EvidenceRequest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EvidenceRequest>;
        }));
    }

    protected processRequestEvidence(response: HttpResponseBase): Observable<EvidenceRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EvidenceRequest.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRequestsForActivityData(body: GetRequestsDto): Observable<ResponseDto> {
        let url_ = this.baseUrl + "/evidence-request/get-requests-for-activity-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestsForActivityData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestsForActivityData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDto>;
        }));
    }

    protected processGetRequestsForActivityData(response: HttpResponseBase): Observable<ResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadEvidenceDocument(body: UploadDto): Observable<UploadResDto> {
        let url_ = this.baseUrl + "/evidence-request/upload-evidence";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadEvidenceDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadEvidenceDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadResDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadResDto>;
        }));
    }

    protected processUploadEvidenceDocument(response: HttpResponseBase): Observable<UploadResDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UploadResDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    enableVerification(body: EnableVerificationReqDto): Observable<EnableVerificationResDto> {
        let url_ = this.baseUrl + "/evidence-request/enable-verification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableVerification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableVerification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnableVerificationResDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnableVerificationResDto>;
        }));
    }

    protected processEnableVerification(response: HttpResponseBase): Observable<EnableVerificationResDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EnableVerificationResDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PassengerAirActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    icaoApi(body: IcaoDto): Observable<any> {
        let url_ = this.baseUrl + "/passenger-air/icao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIcaoApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIcaoApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processIcaoApi(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PurchasedGoodsAndServicesActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createPurchasedGoodAndServices(body: CreatePurchasedGoodsAndServiceDto): Observable<void> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePurchasedGoodAndServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePurchasedGoodAndServices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePurchasedGoodAndServices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllPurchaseGoodAndServicesData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/get-all-purchase-good-and-services-data?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPurchaseGoodAndServicesData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPurchaseGoodAndServicesData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllPurchaseGoodAndServicesData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOnePurchasedGoodAndServicesDataSet(groupNumber: string, isView: string): Observable<any> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/get-one-purchase-good-and-services-data/group-number-set?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        if (isView === undefined || isView === null)
            throw new Error("The parameter 'isView' must be defined and cannot be null.");
        else
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnePurchasedGoodAndServicesDataSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnePurchasedGoodAndServicesDataSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetOnePurchasedGoodAndServicesDataSet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWholeGroup(groupNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/delete-whole-group?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWholeGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWholeGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteWholeGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOneRow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/purchased-goods-and-services/deleteOneRow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneRow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WasteGeneratedInOperationsActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createOne(body: WasteGeneratedInOperationsActivityDataDto): Observable<WasteGeneratedInOperationsActivityData> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/waste/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WasteGeneratedInOperationsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WasteGeneratedInOperationsActivityData>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<WasteGeneratedInOperationsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WasteGeneratedInOperationsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllWasteGeneratedInOperationsData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/waste/getWasteGeneratedInOperationsData/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWasteGeneratedInOperationsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWasteGeneratedInOperationsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllWasteGeneratedInOperationsData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOneWasteGeneratedInOperationsDataSet(groupNumber: string): Observable<any> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/waste/getOneWasteGeneratedInOperationsData/groupNumberSet?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneWasteGeneratedInOperationsDataSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneWasteGeneratedInOperationsDataSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetOneWasteGeneratedInOperationsDataSet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWholeGroup(groupNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/waste/deleteWholeGroup?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWholeGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWholeGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteWholeGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/waste/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOneRow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/waste/deleteOneRow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneRow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FuelEnergyRelatedActivitiesActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createAll(body: FuelEnergyRelatedActivitiesActivityDataDto): Observable<FuelEnergyRelatedActivitiesActivityData> {
        let url_ = this.baseUrl + "/fuelandenergy/saveFuelAndEnergy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuelEnergyRelatedActivitiesActivityData>;
        }));
    }

    protected processCreateAll(response: HttpResponseBase): Observable<FuelEnergyRelatedActivitiesActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FuelEnergyRelatedActivitiesActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFuelEnergyData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/fuelandenergy/getfuelenergyactivitytData/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFuelEnergyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFuelEnergyData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllFuelEnergyData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAll(id: number, body: FuelEnergyRelatedActivitiesActivityDataDto): Observable<void> {
        let url_ = this.baseUrl + "/fuelandenergy/ghg/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEntryById(eid: string): Observable<FuelEnergyRelatedActivitiesActivityDataDto> {
        let url_ = this.baseUrl + "/fuelandenergy/ghg/getEntryById?";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined and cannot be null.");
        else
            url_ += "eid=" + encodeURIComponent("" + eid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FuelEnergyRelatedActivitiesActivityDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FuelEnergyRelatedActivitiesActivityDataDto>;
        }));
    }

    protected processGetEntryById(response: HttpResponseBase): Observable<FuelEnergyRelatedActivitiesActivityDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelEnergyRelatedActivitiesActivityDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEntry(eid: number): Observable<any> {
        let url_ = this.baseUrl + "/fuelandenergy/ghg/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAllEntry(eid: string): Observable<any> {
        let url_ = this.baseUrl + "/fuelandenergy/all/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteAllEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/fuelandenergy/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InvestmentsActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createAll(body: InvestmentsActivityDataDto): Observable<InvestmentsActivityData> {
        let url_ = this.baseUrl + "/investments/saveinvest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentsActivityData>;
        }));
    }

    protected processCreateAll(response: HttpResponseBase): Observable<InvestmentsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = InvestmentsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllInvestmentData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/investments/getInvestmentData/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInvestmentData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInvestmentData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllInvestmentData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAll(id: number, body: InvestmentsActivityDataDto): Observable<void> {
        let url_ = this.baseUrl + "/investments/ghg/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEntryById(eid: string): Observable<InvestmentsActivityDataDto> {
        let url_ = this.baseUrl + "/investments/ghgh/getEntryById?";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined and cannot be null.");
        else
            url_ += "eid=" + encodeURIComponent("" + eid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentsActivityDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentsActivityDataDto>;
        }));
    }

    protected processGetEntryById(response: HttpResponseBase): Observable<InvestmentsActivityDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentsActivityDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEntry(eid: number): Observable<any> {
        let url_ = this.baseUrl + "/investments/ghgh/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAllEntry(eid: string): Observable<any> {
        let url_ = this.baseUrl + "/investments/all/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteAllEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/investments/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NetZeroBusinessTravelActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createOne(body: NetZeroBusinessTravelActivityDataDto): Observable<NetZeroBusinessTravelActivityData> {
        let url_ = this.baseUrl + "/net_zero_business_travel/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroBusinessTravelActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroBusinessTravelActivityData>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<NetZeroBusinessTravelActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NetZeroBusinessTravelActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllBussinesTravelData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/net_zero_business_travel/getBussinesTravelData/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBussinesTravelData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBussinesTravelData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllBussinesTravelData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOneBussinesTravelDataSet(groupNumber: string): Observable<any> {
        let url_ = this.baseUrl + "/net_zero_business_travel/getOneBussinesTravelData/groupNumberSet?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBussinesTravelDataSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBussinesTravelDataSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetOneBussinesTravelDataSet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWholeGroup(groupNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/net_zero_business_travel/deleteWholeGroup?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWholeGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWholeGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteWholeGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/net_zero_business_travel/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOneRow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/net_zero_business_travel/deleteOneRow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneRow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NetZeroEmployeeCommutingActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createOne(body: NetZeroEmployeeCommutingActivityDataDto): Observable<NetZeroEmployeeCommutingActivityData> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NetZeroEmployeeCommutingActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NetZeroEmployeeCommutingActivityData>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<NetZeroEmployeeCommutingActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NetZeroEmployeeCommutingActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllEmployeeCommutingData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/getEmployeeCommutingData/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployeeCommutingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployeeCommutingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllEmployeeCommutingData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOneEmployeeCommutingDataSet(groupNumber: string): Observable<any> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/getOneEmployeeCommutingData/groupNumberSet?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneEmployeeCommutingDataSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneEmployeeCommutingDataSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetOneEmployeeCommutingDataSet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWholeGroup(groupNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/deleteWholeGroup?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWholeGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWholeGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteWholeGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOneRow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/net_zero_employee_commuting/deleteOneRow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneRow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EndOfLifeTreatmentOfSoldProductsActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createAll(body: EndOfLifeTreatmentOfSoldProductsActivityDataDto): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/eolt-sold-products/save-eolt-sold-products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityData>;
        }));
    }

    protected processCreateAll(response: HttpResponseBase): Observable<EndOfLifeTreatmentOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EndOfLifeTreatmentOfSoldProductsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllEoltSoldProductsData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/eolt-sold-products/getInvestmentData/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEoltSoldProductsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEoltSoldProductsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllEoltSoldProductsData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAll(id: number, body: EndOfLifeTreatmentOfSoldProductsActivityDataDto): Observable<void> {
        let url_ = this.baseUrl + "/eolt-sold-products/ghg/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEntryById(eid: string): Observable<EndOfLifeTreatmentOfSoldProductsActivityDataDto> {
        let url_ = this.baseUrl + "/eolt-sold-products/ghgh/getEntryById?";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined and cannot be null.");
        else
            url_ += "eid=" + encodeURIComponent("" + eid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EndOfLifeTreatmentOfSoldProductsActivityDataDto>;
        }));
    }

    protected processGetEntryById(response: HttpResponseBase): Observable<EndOfLifeTreatmentOfSoldProductsActivityDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EndOfLifeTreatmentOfSoldProductsActivityDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEntry(eid: number): Observable<any> {
        let url_ = this.baseUrl + "/eolt-sold-products/ghgh/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAllEntry(eid: string): Observable<any> {
        let url_ = this.baseUrl + "/eolt-sold-products/all/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteAllEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/eolt-sold-products/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UpstreamLeasedAssetsActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createAll(body: UpstreamLeasedAssetsActivityDataDto): Observable<UpstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/saveinvest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamLeasedAssetsActivityData>;
        }));
    }

    protected processCreateAll(response: HttpResponseBase): Observable<UpstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UpstreamLeasedAssetsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllUpstreamLeasedAssetsData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/getUpstreamLeasedAssetsData/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUpstreamLeasedAssetsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUpstreamLeasedAssetsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllUpstreamLeasedAssetsData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAll(id: number, body: UpstreamLeasedAssetsActivityDataDto): Observable<void> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/ghg/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEntryById(eid: string): Observable<UpstreamLeasedAssetsActivityDataDto> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/ghgh/getEntryById?";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined and cannot be null.");
        else
            url_ += "eid=" + encodeURIComponent("" + eid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpstreamLeasedAssetsActivityDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpstreamLeasedAssetsActivityDataDto>;
        }));
    }

    protected processGetEntryById(response: HttpResponseBase): Observable<UpstreamLeasedAssetsActivityDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpstreamLeasedAssetsActivityDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEntry(eid: number): Observable<any> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/ghgh/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAllEntry(eid: string): Observable<any> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/all/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteAllEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/UpstreamLeasedAssets/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProcessingOfSoldProductsActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createAll(body: ProcessingOfSoldProductsActivityDataDto): Observable<ProcessingOfSoldProductsActivityData> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/saveinvest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessingOfSoldProductsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessingOfSoldProductsActivityData>;
        }));
    }

    protected processCreateAll(response: HttpResponseBase): Observable<ProcessingOfSoldProductsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProcessingOfSoldProductsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllUpstreamLeasedAssetsData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/getUpstreamLeasedAssetsData/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUpstreamLeasedAssetsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUpstreamLeasedAssetsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllUpstreamLeasedAssetsData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAll(id: number, body: ProcessingOfSoldProductsActivityDataDto): Observable<void> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/ghg/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEntryById(eid: string): Observable<ProcessingOfSoldProductsActivityDataDto> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/ghgh/getEntryById?";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined and cannot be null.");
        else
            url_ += "eid=" + encodeURIComponent("" + eid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessingOfSoldProductsActivityDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessingOfSoldProductsActivityDataDto>;
        }));
    }

    protected processGetEntryById(response: HttpResponseBase): Observable<ProcessingOfSoldProductsActivityDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessingOfSoldProductsActivityDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEntry(eid: number): Observable<any> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/ghgh/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAllEntry(eid: string): Observable<any> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/all/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteAllEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/ProcessingOfSoldProduct/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FranchisesActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createOne(body: FranchisesActivityDataDto): Observable<boolean> {
        let url_ = this.baseUrl + "/franchises/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFranchisesData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/franchises/get-all-franchises-data?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFranchisesData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFranchisesData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllFranchisesData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOneFranchisesDataSet(groupNumber: string): Observable<any> {
        let url_ = this.baseUrl + "/franchises/get-one-franchises-data/group-number-set?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneFranchisesDataSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneFranchisesDataSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetOneFranchisesDataSet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWholeGroup(groupNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/franchises/delete-whole-group?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWholeGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWholeGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteWholeGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOneRow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/franchises/deleteOneRow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneRow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/franchises/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DownstreamLeasedAssetsActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createOne(body: DownstreamLeasedAssetsActivityDataDto): Observable<DownstreamLeasedAssetsActivityData> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownstreamLeasedAssetsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownstreamLeasedAssetsActivityData>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<DownstreamLeasedAssetsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DownstreamLeasedAssetsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllDownstreamLeasedAssetsData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/getDownstreamLeasedAssetsData/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDownstreamLeasedAssetsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDownstreamLeasedAssetsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllDownstreamLeasedAssetsData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOneDownstreamLeasedAssetsDataSet(groupNumber: string): Observable<any> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/getOneDownstreamLeasedAssetsData/groupNumberSet?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneDownstreamLeasedAssetsDataSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneDownstreamLeasedAssetsDataSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetOneDownstreamLeasedAssetsDataSet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWholeGroup(groupNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/getOneDownstreamLeasedAssetsData/deleteWholeGroup?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWholeGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWholeGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteWholeGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/getOneDownstreamLeasedAssetsData//deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOneRow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/waste_generated_in_operations/getOneDownstreamLeasedAssetsData/deleteOneRow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneRow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DownstreamTransportationActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createOne(body: DownstreamTransportationActivityDataDto): Observable<boolean> {
        let url_ = this.baseUrl + "/downstream-transportation/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllDownstreamTransportationData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/downstream-transportation/get-all-downstream-transportation-data?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDownstreamTransportationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDownstreamTransportationData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllDownstreamTransportationData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOneDownstreamTransportationDataSet(groupNumber: string): Observable<any> {
        let url_ = this.baseUrl + "/downstream-transportation/get-one-downstream-transportation-data/group-number-set?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneDownstreamTransportationDataSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneDownstreamTransportationDataSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetOneDownstreamTransportationDataSet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWholeGroup(groupNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/downstream-transportation/delete-whole-group?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWholeGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWholeGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteWholeGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOneRow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/downstream-transportation/deleteOneRow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneRow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UpstreamTransportationActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createOne(body: UpstreamTransportationActivityDataDto): Observable<boolean> {
        let url_ = this.baseUrl + "/upstream-transportation/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllUpstreamTransportationData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/upstream-transportation/get-all-upstream-transportation-data?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUpstreamTransportationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUpstreamTransportationData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllUpstreamTransportationData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOneUpstreamTransportationDataSet(groupNumber: string): Observable<any> {
        let url_ = this.baseUrl + "/upstream-transportation/get-one-upstream-transportation-data/group-number-set?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneUpstreamTransportationDataSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneUpstreamTransportationDataSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetOneUpstreamTransportationDataSet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWholeGroup(groupNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/upstream-transportation/delete-whole-group?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWholeGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWholeGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteWholeGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOneRow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/upstream-transportation/deleteOneRow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneRow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NetZeroUseOfSoldProductsActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createUseOfSoldProducts(body: CreateNetZeroUseOfSoldProductDto): Observable<void> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUseOfSoldProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUseOfSoldProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateUseOfSoldProducts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllUseOfSoldProductsData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/get-all-use-of-sold-products-data?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUseOfSoldProductsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUseOfSoldProductsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllUseOfSoldProductsData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOneUseOfSoldProductsDataSet(groupNumber: string, isView: string): Observable<any> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/get-one-use-of-sold-products-data/group-number-set?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        if (isView === undefined || isView === null)
            throw new Error("The parameter 'isView' must be defined and cannot be null.");
        else
            url_ += "isView=" + encodeURIComponent("" + isView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneUseOfSoldProductsDataSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneUseOfSoldProductsDataSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetOneUseOfSoldProductsDataSet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWholeGroup(groupNumber: string): Observable<boolean> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/delete-whole-group?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            url_ += "groupNumber=" + encodeURIComponent("" + groupNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWholeGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWholeGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteWholeGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOneRow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/net-zero-use-of-sold-products/deleteOneRow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneRow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CapitalGoodsActivityDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createAll(body: CapitalGoodsActivityDataDto): Observable<CapitalGoodsActivityData> {
        let url_ = this.baseUrl + "/capital-goods/save-capital-goods";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CapitalGoodsActivityData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CapitalGoodsActivityData>;
        }));
    }

    protected processCreateAll(response: HttpResponseBase): Observable<CapitalGoodsActivityData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CapitalGoodsActivityData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllEoltSoldProductsData(page: number, limit: number, projectId: number, unitId: number): Observable<any> {
        let url_ = this.baseUrl + "/capital-goods/get-capital-goods/all?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined and cannot be null.");
        else
            url_ += "unitId=" + encodeURIComponent("" + unitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEoltSoldProductsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEoltSoldProductsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllEoltSoldProductsData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAll(id: number, body: CapitalGoodsActivityDataDto): Observable<void> {
        let url_ = this.baseUrl + "/capital-goods/ghg/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEntryById(eid: string): Observable<CapitalGoodsActivityDataDto> {
        let url_ = this.baseUrl + "/capital-goods/ghgh/getEntryById?";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined and cannot be null.");
        else
            url_ += "eid=" + encodeURIComponent("" + eid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CapitalGoodsActivityDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CapitalGoodsActivityDataDto>;
        }));
    }

    protected processGetEntryById(response: HttpResponseBase): Observable<CapitalGoodsActivityDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CapitalGoodsActivityDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEntry(eid: number): Observable<any> {
        let url_ = this.baseUrl + "/capital-goods/ghgh/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAllEntry(eid: string): Observable<any> {
        let url_ = this.baseUrl + "/capital-goods/all/{eid}";
        if (eid === undefined || eid === null)
            throw new Error("The parameter 'eid' must be defined.");
        url_ = url_.replace("{eid}", encodeURIComponent("" + eid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeleteAllEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSelectedALL(groupNumber: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/capital-goods/deleteSelectedALL?";
        if (groupNumber === undefined || groupNumber === null)
            throw new Error("The parameter 'groupNumber' must be defined and cannot be null.");
        else
            groupNumber && groupNumber.forEach(item => { url_ += "groupNumber=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSelectedALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSelectedALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteSelectedALL(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ParameterControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    seed(): Observable<void> {
        let url_ = this.baseUrl + "/parameter/seed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSeed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getManyParamtersByESList(body: ManyParameterDto): Observable<ManyParameterResDto> {
        let url_ = this.baseUrl + "/parameter/get-many-paramters-by-es-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyParamtersByESList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyParamtersByESList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ManyParameterResDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ManyParameterResDto>;
        }));
    }

    protected processGetManyParamtersByESList(response: HttpResponseBase): Observable<ManyParameterResDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ManyParameterResDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReportControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    generateReport(body: GenerateDto): Observable<void> {
        let url_ = this.baseUrl + "/report/generate-report";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    testTot(): Observable<void> {
        let url_ = this.baseUrl + "/report/test-total";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestTot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestTot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    testGraph(body: GraphsDto): Observable<any> {
        let url_ = this.baseUrl + "/report/testGraph";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestGraph(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestGraph(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processTestGraph(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    allowClientToGenerate(id: string, isAllow: string): Observable<void> {
        let url_ = this.baseUrl + "/report/allow-genrate?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (isAllow === undefined || isAllow === null)
            throw new Error("The parameter 'isAllow' must be defined and cannot be null.");
        else
            url_ += "isAllow=" + encodeURIComponent("" + isAllow) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllowClientToGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllowClientToGenerate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAllowClientToGenerate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    finalReport(): Observable<any> {
        let url_ = this.baseUrl + "/report/finalreport";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processFinalReport(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    test(): Observable<string> {
        let url_ = this.baseUrl + "/report/total";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reportTest(): Observable<any> {
        let url_ = this.baseUrl + "/report/report";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processReportTest(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AirPortDisControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getDisByAirportcodes(body: string[]): Observable<any> {
        let url_ = this.baseUrl + "/airdis/disbycodes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDisByAirportcodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDisByAirportcodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetDisByAirportcodes(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SeaPortsDisControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getDisBySeaportcodes(body: string[]): Observable<any> {
        let url_ = this.baseUrl + "/seaportsdis/disbycodes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDisBySeaportcodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDisBySeaportcodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetDisBySeaportcodes(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AirPortControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    findAirPortsByCountry(countryId: number): Observable<AirPort[]> {
        let url_ = this.baseUrl + "/airports/{countryId}?";
        if (countryId === undefined || countryId === null)
            throw new Error("The parameter 'countryId' must be defined and cannot be null.");
        else
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAirPortsByCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAirPortsByCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirPort[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirPort[]>;
        }));
    }

    protected processFindAirPortsByCountry(response: HttpResponseBase): Observable<AirPort[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AirPort.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SeaPortControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    findSeaPortsByCountry(countryId: number): Observable<SeaPort[]> {
        let url_ = this.baseUrl + "/seaports/{countryId}?";
        if (countryId === undefined || countryId === null)
            throw new Error("The parameter 'countryId' must be defined and cannot be null.");
        else
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindSeaPortsByCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindSeaPortsByCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeaPort[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeaPort[]>;
        }));
    }

    protected processFindSeaPortsByCountry(response: HttpResponseBase): Observable<SeaPort[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SeaPort.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PassengerAirPortControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAirportByCode(code: string): Observable<PassengerAirPort> {
        let url_ = this.baseUrl + "/passenger-air-port/get-airport-by-code?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAirportByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAirportByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassengerAirPort>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassengerAirPort>;
        }));
    }

    protected processGetAirportByCode(response: HttpResponseBase): Observable<PassengerAirPort> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassengerAirPort.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmailControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(body: CreateEmailDto): Observable<void> {
        let url_ = this.baseUrl + "/email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class GetManyDocumentsResponseDto implements IGetManyDocumentsResponseDto {
    data: Documents[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyDocumentsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Documents.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyDocumentsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyDocumentsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyDocumentsResponseDto {
        const json = this.toJSON();
        let result = new GetManyDocumentsResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyDocumentsResponseDto {
    data: Documents[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Documents implements IDocuments {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    mimeType: string;
    fileName: string;
    relativePath: string;
    type: string;
    url: string;

    constructor(data?: IDocuments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.mimeType = _data["mimeType"];
            this.fileName = _data["fileName"];
            this.relativePath = _data["relativePath"];
            this.type = _data["type"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Documents {
        data = typeof data === 'object' ? data : {};
        let result = new Documents();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["mimeType"] = this.mimeType;
        data["fileName"] = this.fileName;
        data["relativePath"] = this.relativePath;
        data["type"] = this.type;
        data["url"] = this.url;
        return data;
    }

    clone(): Documents {
        const json = this.toJSON();
        let result = new Documents();
        result.init(json);
        return result;
    }
}

export interface IDocuments {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    mimeType: string;
    fileName: string;
    relativePath: string;
    type: string;
    url: string;
}

export class CreateManyDocumentsDto implements ICreateManyDocumentsDto {
    bulk: Documents[];

    constructor(data?: ICreateManyDocumentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Documents.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyDocumentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyDocumentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyDocumentsDto {
        const json = this.toJSON();
        let result = new CreateManyDocumentsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyDocumentsDto {
    bulk: Documents[];
}

export class GetManyUserResponseDto implements IGetManyUserResponseDto {
    data: User[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUserResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(User.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUserResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUserResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUserResponseDto {
        const json = this.toJSON();
        let result = new GetManyUserResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUserResponseDto {
    data: User[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyUnitResponseDto implements IGetManyUnitResponseDto {
    data: Unit[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUnitResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Unit.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUnitResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUnitResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUnitResponseDto {
        const json = this.toJSON();
        let result = new GetManyUnitResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUnitResponseDto {
    data: Unit[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyCountryResponseDto implements IGetManyCountryResponseDto {
    data: Country[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyCountryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Country.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyCountryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyCountryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyCountryResponseDto {
        const json = this.toJSON();
        let result = new GetManyCountryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyCountryResponseDto {
    data: Country[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Country implements ICountry {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    codeThree: string;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.codeThree = _data["codeThree"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeThree"] = this.codeThree;
        return data;
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    codeThree: string;
}

export class GetManyProjectUnitResponseDto implements IGetManyProjectUnitResponseDto {
    data: ProjectUnit[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProjectUnitResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectUnit.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectUnitResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectUnitResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProjectUnitResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectUnitResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectUnitResponseDto {
    data: ProjectUnit[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyProjectUnitEmissionSourceResponseDto implements IGetManyProjectUnitEmissionSourceResponseDto {
    data: ProjectUnitEmissionSource[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProjectUnitEmissionSourceResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectUnitEmissionSource.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectUnitEmissionSourceResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectUnitEmissionSourceResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProjectUnitEmissionSourceResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectUnitEmissionSourceResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectUnitEmissionSourceResponseDto {
    data: ProjectUnitEmissionSource[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyEmissionSourceResponseDto implements IGetManyEmissionSourceResponseDto {
    data: EmissionSource[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyEmissionSourceResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(EmissionSource.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyEmissionSourceResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyEmissionSourceResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyEmissionSourceResponseDto {
        const json = this.toJSON();
        let result = new GetManyEmissionSourceResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyEmissionSourceResponseDto {
    data: EmissionSource[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyProjectEmissionSourceResponseDto implements IGetManyProjectEmissionSourceResponseDto {
    data: ProjectEmissionSource[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProjectEmissionSourceResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectEmissionSource.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectEmissionSourceResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectEmissionSourceResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProjectEmissionSourceResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectEmissionSourceResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectEmissionSourceResponseDto {
    data: ProjectEmissionSource[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyProjectResponseDto implements IGetManyProjectResponseDto {
    data: Project[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProjectResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Project.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProjectResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectResponseDto {
    data: Project[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyProjectTypeResponseDto implements IGetManyProjectTypeResponseDto {
    data: ProjectType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProjectTypeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectType.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectTypeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectTypeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProjectTypeResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectTypeResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectTypeResponseDto {
    data: ProjectType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ProjectType implements IProjectType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;

    constructor(data?: IProjectType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ProjectType {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }

    clone(): ProjectType {
        const json = this.toJSON();
        let result = new ProjectType();
        result.init(json);
        return result;
    }
}

export interface IProjectType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
}

export class GetManyMethodologyResponseDto implements IGetManyMethodologyResponseDto {
    data: Methodology[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyMethodologyResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Methodology.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyMethodologyResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyMethodologyResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyMethodologyResponseDto {
        const json = this.toJSON();
        let result = new GetManyMethodologyResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyMethodologyResponseDto {
    data: Methodology[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Methodology implements IMethodology {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    description: string;
    projectType: ProjectType;

    constructor(data?: IMethodology) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectType = new ProjectType();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.projectType = _data["projectType"] ? ProjectType.fromJS(_data["projectType"]) : new ProjectType();
        }
    }

    static fromJS(data: any): Methodology {
        data = typeof data === 'object' ? data : {};
        let result = new Methodology();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        return data;
    }

    clone(): Methodology {
        const json = this.toJSON();
        let result = new Methodology();
        result.init(json);
        return result;
    }
}

export interface IMethodology {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    description: string;
    projectType: ProjectType;
}

export class Project implements IProject {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    year: string;
    projectEmissionSources: ProjectEmissionSource[];
    projectUnits: ProjectUnit[];
    projectType: ProjectType;
    methodology: Methodology;
    projectStatus: ProjectStatus;
    verifier: User;
    enteredBy: User;
    responsiblePerson: User;
    organizationalBoundary: string;
    controlApproach: string;
    emission: number;
    isFinancialYear: boolean;
    fyFrom: moment.Moment;
    fyTo: moment.Moment;
    directEmission: number;
    directCO2Emission: number;
    directCH4Emission: number;
    directN2OEmission: number;
    indirectEmission: number;
    indirectCO2Emission: number;
    indirectCH4Emission: number;
    indirectN2OEmission: number;
    indirectEsGTOne: number;
    otherEmission: number;
    otherCO2Emission: number;
    otherCH4Emission: number;
    otherN2OEmission: number;
    ownerUnit: Unit;
    comment: string;
    paymentReff: string;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectEmissionSources = [];
            this.projectUnits = [];
            this.projectType = new ProjectType();
            this.methodology = new Methodology();
            this.verifier = new User();
            this.enteredBy = new User();
            this.responsiblePerson = new User();
            this.ownerUnit = new Unit();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.year = _data["year"];
            if (Array.isArray(_data["projectEmissionSources"])) {
                this.projectEmissionSources = [] as any;
                for (let item of _data["projectEmissionSources"])
                    this.projectEmissionSources.push(ProjectEmissionSource.fromJS(item));
            }
            if (Array.isArray(_data["projectUnits"])) {
                this.projectUnits = [] as any;
                for (let item of _data["projectUnits"])
                    this.projectUnits.push(ProjectUnit.fromJS(item));
            }
            this.projectType = _data["projectType"] ? ProjectType.fromJS(_data["projectType"]) : new ProjectType();
            this.methodology = _data["methodology"] ? Methodology.fromJS(_data["methodology"]) : new Methodology();
            this.projectStatus = _data["projectStatus"];
            this.verifier = _data["verifier"] ? User.fromJS(_data["verifier"]) : new User();
            this.enteredBy = _data["enteredBy"] ? User.fromJS(_data["enteredBy"]) : new User();
            this.responsiblePerson = _data["responsiblePerson"] ? User.fromJS(_data["responsiblePerson"]) : new User();
            this.organizationalBoundary = _data["organizationalBoundary"];
            this.controlApproach = _data["controlApproach"];
            this.emission = _data["emission"];
            this.isFinancialYear = _data["isFinancialYear"];
            this.fyFrom = _data["fyFrom"] ? moment(_data["fyFrom"].toString()) : <any>undefined;
            this.fyTo = _data["fyTo"] ? moment(_data["fyTo"].toString()) : <any>undefined;
            this.directEmission = _data["directEmission"];
            this.directCO2Emission = _data["directCO2Emission"];
            this.directCH4Emission = _data["directCH4Emission"];
            this.directN2OEmission = _data["directN2OEmission"];
            this.indirectEmission = _data["indirectEmission"];
            this.indirectCO2Emission = _data["indirectCO2Emission"];
            this.indirectCH4Emission = _data["indirectCH4Emission"];
            this.indirectN2OEmission = _data["indirectN2OEmission"];
            this.indirectEsGTOne = _data["indirectEsGTOne"];
            this.otherEmission = _data["otherEmission"];
            this.otherCO2Emission = _data["otherCO2Emission"];
            this.otherCH4Emission = _data["otherCH4Emission"];
            this.otherN2OEmission = _data["otherN2OEmission"];
            this.ownerUnit = _data["ownerUnit"] ? Unit.fromJS(_data["ownerUnit"]) : new Unit();
            this.comment = _data["comment"];
            this.paymentReff = _data["paymentReff"];
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["year"] = this.year;
        if (Array.isArray(this.projectEmissionSources)) {
            data["projectEmissionSources"] = [];
            for (let item of this.projectEmissionSources)
                data["projectEmissionSources"].push(item.toJSON());
        }
        if (Array.isArray(this.projectUnits)) {
            data["projectUnits"] = [];
            for (let item of this.projectUnits)
                data["projectUnits"].push(item.toJSON());
        }
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["methodology"] = this.methodology ? this.methodology.toJSON() : <any>undefined;
        data["projectStatus"] = this.projectStatus;
        data["verifier"] = this.verifier ? this.verifier.toJSON() : <any>undefined;
        data["enteredBy"] = this.enteredBy ? this.enteredBy.toJSON() : <any>undefined;
        data["responsiblePerson"] = this.responsiblePerson ? this.responsiblePerson.toJSON() : <any>undefined;
        data["organizationalBoundary"] = this.organizationalBoundary;
        data["controlApproach"] = this.controlApproach;
        data["emission"] = this.emission;
        data["isFinancialYear"] = this.isFinancialYear;
        data["fyFrom"] = this.fyFrom ? this.fyFrom.toISOString() : <any>undefined;
        data["fyTo"] = this.fyTo ? this.fyTo.toISOString() : <any>undefined;
        data["directEmission"] = this.directEmission;
        data["directCO2Emission"] = this.directCO2Emission;
        data["directCH4Emission"] = this.directCH4Emission;
        data["directN2OEmission"] = this.directN2OEmission;
        data["indirectEmission"] = this.indirectEmission;
        data["indirectCO2Emission"] = this.indirectCO2Emission;
        data["indirectCH4Emission"] = this.indirectCH4Emission;
        data["indirectN2OEmission"] = this.indirectN2OEmission;
        data["indirectEsGTOne"] = this.indirectEsGTOne;
        data["otherEmission"] = this.otherEmission;
        data["otherCO2Emission"] = this.otherCO2Emission;
        data["otherCH4Emission"] = this.otherCH4Emission;
        data["otherN2OEmission"] = this.otherN2OEmission;
        data["ownerUnit"] = this.ownerUnit ? this.ownerUnit.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        data["paymentReff"] = this.paymentReff;
        return data;
    }

    clone(): Project {
        const json = this.toJSON();
        let result = new Project();
        result.init(json);
        return result;
    }
}

export interface IProject {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    year: string;
    projectEmissionSources: ProjectEmissionSource[];
    projectUnits: ProjectUnit[];
    projectType: ProjectType;
    methodology: Methodology;
    projectStatus: ProjectStatus;
    verifier: User;
    enteredBy: User;
    responsiblePerson: User;
    organizationalBoundary: string;
    controlApproach: string;
    emission: number;
    isFinancialYear: boolean;
    fyFrom: moment.Moment;
    fyTo: moment.Moment;
    directEmission: number;
    directCO2Emission: number;
    directCH4Emission: number;
    directN2OEmission: number;
    indirectEmission: number;
    indirectCO2Emission: number;
    indirectCH4Emission: number;
    indirectN2OEmission: number;
    indirectEsGTOne: number;
    otherEmission: number;
    otherCO2Emission: number;
    otherCH4Emission: number;
    otherN2OEmission: number;
    ownerUnit: Unit;
    comment: string;
    paymentReff: string;
}

export class ProjectEmissionSource implements IProjectEmissionSource {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    emissionSource: EmissionSource;
    project: Project;
    emission: number;
    directEmission: number;
    directCO2Emission: number;
    directCH4Emission: number;
    directN2OEmission: number;
    indirectEmission: number;
    indirectCO2Emission: number;
    indirectCH4Emission: number;
    indirectN2OEmission: number;
    indirectEsGTOne: number;
    otherEmission: number;
    otherCO2Emission: number;
    otherCH4Emission: number;
    otherN2OEmission: number;

    constructor(data?: IProjectEmissionSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.emissionSource = new EmissionSource();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.emissionSource = _data["emissionSource"] ? EmissionSource.fromJS(_data["emissionSource"]) : new EmissionSource();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.emission = _data["emission"];
            this.directEmission = _data["directEmission"];
            this.directCO2Emission = _data["directCO2Emission"];
            this.directCH4Emission = _data["directCH4Emission"];
            this.directN2OEmission = _data["directN2OEmission"];
            this.indirectEmission = _data["indirectEmission"];
            this.indirectCO2Emission = _data["indirectCO2Emission"];
            this.indirectCH4Emission = _data["indirectCH4Emission"];
            this.indirectN2OEmission = _data["indirectN2OEmission"];
            this.indirectEsGTOne = _data["indirectEsGTOne"];
            this.otherEmission = _data["otherEmission"];
            this.otherCO2Emission = _data["otherCO2Emission"];
            this.otherCH4Emission = _data["otherCH4Emission"];
            this.otherN2OEmission = _data["otherN2OEmission"];
        }
    }

    static fromJS(data: any): ProjectEmissionSource {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectEmissionSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["emissionSource"] = this.emissionSource ? this.emissionSource.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["emission"] = this.emission;
        data["directEmission"] = this.directEmission;
        data["directCO2Emission"] = this.directCO2Emission;
        data["directCH4Emission"] = this.directCH4Emission;
        data["directN2OEmission"] = this.directN2OEmission;
        data["indirectEmission"] = this.indirectEmission;
        data["indirectCO2Emission"] = this.indirectCO2Emission;
        data["indirectCH4Emission"] = this.indirectCH4Emission;
        data["indirectN2OEmission"] = this.indirectN2OEmission;
        data["indirectEsGTOne"] = this.indirectEsGTOne;
        data["otherEmission"] = this.otherEmission;
        data["otherCO2Emission"] = this.otherCO2Emission;
        data["otherCH4Emission"] = this.otherCH4Emission;
        data["otherN2OEmission"] = this.otherN2OEmission;
        return data;
    }

    clone(): ProjectEmissionSource {
        const json = this.toJSON();
        let result = new ProjectEmissionSource();
        result.init(json);
        return result;
    }
}

export interface IProjectEmissionSource {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    emissionSource: EmissionSource;
    project: Project;
    emission: number;
    directEmission: number;
    directCO2Emission: number;
    directCH4Emission: number;
    directN2OEmission: number;
    indirectEmission: number;
    indirectCO2Emission: number;
    indirectCH4Emission: number;
    indirectN2OEmission: number;
    indirectEsGTOne: number;
    otherEmission: number;
    otherCO2Emission: number;
    otherCH4Emission: number;
    otherN2OEmission: number;
}

export class EmissionSource implements IEmissionSource {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    sbtName: string;
    code: string;
    projectEmissionSource: ProjectEmissionSource[];

    constructor(data?: IEmissionSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectEmissionSource = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.sbtName = _data["sbtName"];
            this.code = _data["code"];
            if (Array.isArray(_data["projectEmissionSource"])) {
                this.projectEmissionSource = [] as any;
                for (let item of _data["projectEmissionSource"])
                    this.projectEmissionSource.push(ProjectEmissionSource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmissionSource {
        data = typeof data === 'object' ? data : {};
        let result = new EmissionSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["sbtName"] = this.sbtName;
        data["code"] = this.code;
        if (Array.isArray(this.projectEmissionSource)) {
            data["projectEmissionSource"] = [];
            for (let item of this.projectEmissionSource)
                data["projectEmissionSource"].push(item.toJSON());
        }
        return data;
    }

    clone(): EmissionSource {
        const json = this.toJSON();
        let result = new EmissionSource();
        result.init(json);
        return result;
    }
}

export interface IEmissionSource {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    sbtName: string;
    code: string;
    projectEmissionSource: ProjectEmissionSource[];
}

export class GetManyAssignedESResponseDto implements IGetManyAssignedESResponseDto {
    data: AssignedES[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyAssignedESResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(AssignedES.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyAssignedESResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyAssignedESResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyAssignedESResponseDto {
        const json = this.toJSON();
        let result = new GetManyAssignedESResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyAssignedESResponseDto {
    data: AssignedES[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class AssignedES implements IAssignedES {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    user: User;
    pues: ProjectUnitEmissionSource;
    add: boolean;
    edit: boolean;
    delete: boolean;

    constructor(data?: IAssignedES) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.pues = new ProjectUnitEmissionSource();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.pues = _data["pues"] ? ProjectUnitEmissionSource.fromJS(_data["pues"]) : new ProjectUnitEmissionSource();
            this.add = _data["add"];
            this.edit = _data["edit"];
            this.delete = _data["delete"];
        }
    }

    static fromJS(data: any): AssignedES {
        data = typeof data === 'object' ? data : {};
        let result = new AssignedES();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["pues"] = this.pues ? this.pues.toJSON() : <any>undefined;
        data["add"] = this.add;
        data["edit"] = this.edit;
        data["delete"] = this.delete;
        return data;
    }

    clone(): AssignedES {
        const json = this.toJSON();
        let result = new AssignedES();
        result.init(json);
        return result;
    }
}

export interface IAssignedES {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    user: User;
    pues: ProjectUnitEmissionSource;
    add: boolean;
    edit: boolean;
    delete: boolean;
}

export class ProjectUnitEmissionSource implements IProjectUnitEmissionSource {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    emissionSource: EmissionSource;
    projectUnit: ProjectUnit;
    emission: number;
    tier: ProjectUnitEmissionSourceTier | undefined;
    clasification: ProjectUnitEmissionSourceClasification;
    assignedESList: AssignedES[];
    stationery: boolean;
    mobile: boolean;
    isComplete: boolean;
    directEmission: number;
    directCO2Emission: number;
    directCH4Emission: number;
    directN2OEmission: number;
    indirectEmission: number;
    indirectCO2Emission: number;
    indirectCH4Emission: number;
    indirectN2OEmission: number;
    indirectEsGTOne: number;
    otherEmission: number;
    otherCO2Emission: number;
    otherCH4Emission: number;
    otherN2OEmission: number;
    scope: ProjectUnitEmissionSourceScope;

    constructor(data?: IProjectUnitEmissionSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.emissionSource = new EmissionSource();
            this.projectUnit = new ProjectUnit();
            this.assignedESList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.emissionSource = _data["emissionSource"] ? EmissionSource.fromJS(_data["emissionSource"]) : new EmissionSource();
            this.projectUnit = _data["projectUnit"] ? ProjectUnit.fromJS(_data["projectUnit"]) : new ProjectUnit();
            this.emission = _data["emission"];
            this.tier = _data["tier"];
            this.clasification = _data["clasification"];
            if (Array.isArray(_data["assignedESList"])) {
                this.assignedESList = [] as any;
                for (let item of _data["assignedESList"])
                    this.assignedESList.push(AssignedES.fromJS(item));
            }
            this.stationery = _data["stationery"];
            this.mobile = _data["mobile"];
            this.isComplete = _data["isComplete"];
            this.directEmission = _data["directEmission"];
            this.directCO2Emission = _data["directCO2Emission"];
            this.directCH4Emission = _data["directCH4Emission"];
            this.directN2OEmission = _data["directN2OEmission"];
            this.indirectEmission = _data["indirectEmission"];
            this.indirectCO2Emission = _data["indirectCO2Emission"];
            this.indirectCH4Emission = _data["indirectCH4Emission"];
            this.indirectN2OEmission = _data["indirectN2OEmission"];
            this.indirectEsGTOne = _data["indirectEsGTOne"];
            this.otherEmission = _data["otherEmission"];
            this.otherCO2Emission = _data["otherCO2Emission"];
            this.otherCH4Emission = _data["otherCH4Emission"];
            this.otherN2OEmission = _data["otherN2OEmission"];
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): ProjectUnitEmissionSource {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUnitEmissionSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["emissionSource"] = this.emissionSource ? this.emissionSource.toJSON() : <any>undefined;
        data["projectUnit"] = this.projectUnit ? this.projectUnit.toJSON() : <any>undefined;
        data["emission"] = this.emission;
        data["tier"] = this.tier;
        data["clasification"] = this.clasification;
        if (Array.isArray(this.assignedESList)) {
            data["assignedESList"] = [];
            for (let item of this.assignedESList)
                data["assignedESList"].push(item.toJSON());
        }
        data["stationery"] = this.stationery;
        data["mobile"] = this.mobile;
        data["isComplete"] = this.isComplete;
        data["directEmission"] = this.directEmission;
        data["directCO2Emission"] = this.directCO2Emission;
        data["directCH4Emission"] = this.directCH4Emission;
        data["directN2OEmission"] = this.directN2OEmission;
        data["indirectEmission"] = this.indirectEmission;
        data["indirectCO2Emission"] = this.indirectCO2Emission;
        data["indirectCH4Emission"] = this.indirectCH4Emission;
        data["indirectN2OEmission"] = this.indirectN2OEmission;
        data["indirectEsGTOne"] = this.indirectEsGTOne;
        data["otherEmission"] = this.otherEmission;
        data["otherCO2Emission"] = this.otherCO2Emission;
        data["otherCH4Emission"] = this.otherCH4Emission;
        data["otherN2OEmission"] = this.otherN2OEmission;
        data["scope"] = this.scope;
        return data;
    }

    clone(): ProjectUnitEmissionSource {
        const json = this.toJSON();
        let result = new ProjectUnitEmissionSource();
        result.init(json);
        return result;
    }
}

export interface IProjectUnitEmissionSource {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    emissionSource: EmissionSource;
    projectUnit: ProjectUnit;
    emission: number;
    tier: ProjectUnitEmissionSourceTier | undefined;
    clasification: ProjectUnitEmissionSourceClasification;
    assignedESList: AssignedES[];
    stationery: boolean;
    mobile: boolean;
    isComplete: boolean;
    directEmission: number;
    directCO2Emission: number;
    directCH4Emission: number;
    directN2OEmission: number;
    indirectEmission: number;
    indirectCO2Emission: number;
    indirectCH4Emission: number;
    indirectN2OEmission: number;
    indirectEsGTOne: number;
    otherEmission: number;
    otherCO2Emission: number;
    otherCH4Emission: number;
    otherN2OEmission: number;
    scope: ProjectUnitEmissionSourceScope;
}

export class ProjectUnit implements IProjectUnit {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    projectUnitEmissionSources: ProjectUnitEmissionSource[];
    project: Project;
    unit: Unit;
    isCreatingUnit: boolean;

    constructor(data?: IProjectUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectUnitEmissionSources = [];
            this.project = new Project();
            this.unit = new Unit();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            if (Array.isArray(_data["projectUnitEmissionSources"])) {
                this.projectUnitEmissionSources = [] as any;
                for (let item of _data["projectUnitEmissionSources"])
                    this.projectUnitEmissionSources.push(ProjectUnitEmissionSource.fromJS(item));
            }
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.isCreatingUnit = _data["isCreatingUnit"];
        }
    }

    static fromJS(data: any): ProjectUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        if (Array.isArray(this.projectUnitEmissionSources)) {
            data["projectUnitEmissionSources"] = [];
            for (let item of this.projectUnitEmissionSources)
                data["projectUnitEmissionSources"].push(item.toJSON());
        }
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["isCreatingUnit"] = this.isCreatingUnit;
        return data;
    }

    clone(): ProjectUnit {
        const json = this.toJSON();
        let result = new ProjectUnit();
        result.init(json);
        return result;
    }
}

export interface IProjectUnit {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    projectUnitEmissionSources: ProjectUnitEmissionSource[];
    project: Project;
    unit: Unit;
    isCreatingUnit: boolean;
}

export class GetManyIndustryResponseDto implements IGetManyIndustryResponseDto {
    data: Industry[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyIndustryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Industry.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyIndustryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyIndustryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyIndustryResponseDto {
        const json = this.toJSON();
        let result = new GetManyIndustryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyIndustryResponseDto {
    data: Industry[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Industry implements IIndustry {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    units: Unit[];
    type: IndustryType;

    constructor(data?: IIndustry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.units = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            if (Array.isArray(_data["units"])) {
                this.units = [] as any;
                for (let item of _data["units"])
                    this.units.push(Unit.fromJS(item));
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Industry {
        data = typeof data === 'object' ? data : {};
        let result = new Industry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        if (Array.isArray(this.units)) {
            data["units"] = [];
            for (let item of this.units)
                data["units"].push(item.toJSON());
        }
        data["type"] = this.type;
        return data;
    }

    clone(): Industry {
        const json = this.toJSON();
        let result = new Industry();
        result.init(json);
        return result;
    }
}

export interface IIndustry {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    units: Unit[];
    type: IndustryType;
}

export class Unit implements IUnit {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    levelName: string;
    country: Country;
    levelDetailsId: number;
    childUnits: Unit[];
    parentUnit: Unit;
    projectUnits: ProjectUnit[];
    industry: Industry;
    unitStatus: UnitStatus;
    createdAt: moment.Moment;
    perfix: string;

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.country = new Country();
            this.childUnits = [];
          //  this.parentUnit = new Unit();
            this.projectUnits = [];
            this.industry = new Industry();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.levelName = _data["levelName"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
            this.levelDetailsId = _data["levelDetailsId"];
            if (Array.isArray(_data["childUnits"])) {
                this.childUnits = [] as any;
                for (let item of _data["childUnits"])
                    this.childUnits.push(Unit.fromJS(item));
            }
            this.parentUnit = _data["parentUnit"] ? Unit.fromJS(_data["parentUnit"]) : new Unit();
            if (Array.isArray(_data["projectUnits"])) {
                this.projectUnits = [] as any;
                for (let item of _data["projectUnits"])
                    this.projectUnits.push(ProjectUnit.fromJS(item));
            }
            this.industry = _data["industry"] ? Industry.fromJS(_data["industry"]) : new Industry();
            this.unitStatus = _data["unitStatus"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.perfix = _data["perfix"];
        }
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["levelName"] = this.levelName;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["levelDetailsId"] = this.levelDetailsId;
        if (Array.isArray(this.childUnits)) {
            data["childUnits"] = [];
            for (let item of this.childUnits)
                data["childUnits"].push(item.toJSON());
        }
        data["parentUnit"] = this.parentUnit ? this.parentUnit.toJSON() : <any>undefined;
        if (Array.isArray(this.projectUnits)) {
            data["projectUnits"] = [];
            for (let item of this.projectUnits)
                data["projectUnits"].push(item.toJSON());
        }
        data["industry"] = this.industry ? this.industry.toJSON() : <any>undefined;
        data["unitStatus"] = this.unitStatus;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["perfix"] = this.perfix;
        return data;
    }

    clone(): Unit {
        const json = this.toJSON();
        let result = new Unit();
        result.init(json);
        return result;
    }
}

export interface IUnit {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    levelName: string;
    country: Country;
    levelDetailsId: number;
    childUnits: Unit[];
    parentUnit: Unit;
    projectUnits: ProjectUnit[];
    industry: Industry;
    unitStatus: UnitStatus;
    createdAt: moment.Moment;
    perfix: string;
}

export class User implements IUser {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    firstName: string;
    lastName: string;
    email: string;
    telephone: string;
    designation: string;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    unit: Unit;
    loginProfile: string;
    allowedSelectUnits: string;
    allowedFPProjects: string;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unit = new Unit();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.designation = _data["designation"];
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.canNotDelete = _data["canNotDelete"];
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.loginProfile = _data["loginProfile"];
            this.allowedSelectUnits = _data["allowedSelectUnits"];
            this.allowedFPProjects = _data["allowedFPProjects"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["designation"] = this.designation;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["canNotDelete"] = this.canNotDelete;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["loginProfile"] = this.loginProfile;
        data["allowedSelectUnits"] = this.allowedSelectUnits;
        data["allowedFPProjects"] = this.allowedFPProjects;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    firstName: string;
    lastName: string;
    email: string;
    telephone: string;
    designation: string;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    unit: Unit;
    loginProfile: string;
    allowedSelectUnits: string;
    allowedFPProjects: string;
}

export class UserWithLoginProfileDto implements IUserWithLoginProfileDto {
    user: User;
    userName: string;
    roles: string[];
    profileState: number;

    constructor(data?: IUserWithLoginProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.userName = _data["userName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(item);
            }
            this.profileState = _data["profileState"];
        }
    }

    static fromJS(data: any): UserWithLoginProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithLoginProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["profileState"] = this.profileState;
        return data;
    }

    clone(): UserWithLoginProfileDto {
        const json = this.toJSON();
        let result = new UserWithLoginProfileDto();
        result.init(json);
        return result;
    }
}

export interface IUserWithLoginProfileDto {
    user: User;
    userName: string;
    roles: string[];
    profileState: number;
}

export class CreateUserDto implements ICreateUserDto {
    firstName: string;
    lastName: string;
    email: string;
    designation: string;
    telephone: string;
    loginProfile: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.designation = _data["designation"];
            this.telephone = _data["telephone"];
            this.loginProfile = _data["loginProfile"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["designation"] = this.designation;
        data["telephone"] = this.telephone;
        data["loginProfile"] = this.loginProfile;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    firstName: string;
    lastName: string;
    email: string;
    designation: string;
    telephone: string;
    loginProfile: string;
}

export class ExportUserDto implements IExportUserDto {
    users: any[];

    constructor(data?: IExportUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.users = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users.push(item);
            }
        }
    }

    static fromJS(data: any): ExportUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        return data;
    }

    clone(): ExportUserDto {
        const json = this.toJSON();
        let result = new ExportUserDto();
        result.init(json);
        return result;
    }
}

export interface IExportUserDto {
    users: any[];
}

export class CreateManyUserDto implements ICreateManyUserDto {
    bulk: User[];

    constructor(data?: ICreateManyUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyUserDto {
        const json = this.toJSON();
        let result = new CreateManyUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUserDto {
    bulk: User[];
}

export class CreateManyAssignedESDto implements ICreateManyAssignedESDto {
    bulk: AssignedES[];

    constructor(data?: ICreateManyAssignedESDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(AssignedES.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyAssignedESDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyAssignedESDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyAssignedESDto {
        const json = this.toJSON();
        let result = new CreateManyAssignedESDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyAssignedESDto {
    bulk: AssignedES[];
}

export class ConsecutiveYear implements IConsecutiveYear {
    year: number;
    withCSI: boolean;

    constructor(data?: IConsecutiveYear) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.withCSI = _data["withCSI"];
        }
    }

    static fromJS(data: any): ConsecutiveYear {
        data = typeof data === 'object' ? data : {};
        let result = new ConsecutiveYear();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["withCSI"] = this.withCSI;
        return data;
    }

    clone(): ConsecutiveYear {
        const json = this.toJSON();
        let result = new ConsecutiveYear();
        result.init(json);
        return result;
    }
}

export interface IConsecutiveYear {
    year: number;
    withCSI: boolean;
}

export class ConsecutiveYears implements IConsecutiveYears {
    unitDetaisl: any[];
    puList: any[];
    years: ConsecutiveYear[];

    constructor(data?: IConsecutiveYears) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unitDetaisl = [];
            this.puList = [];
            this.years = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["unitDetaisl"])) {
                this.unitDetaisl = [] as any;
                for (let item of _data["unitDetaisl"])
                    this.unitDetaisl.push(item);
            }
            if (Array.isArray(_data["puList"])) {
                this.puList = [] as any;
                for (let item of _data["puList"])
                    this.puList.push(item);
            }
            if (Array.isArray(_data["years"])) {
                this.years = [] as any;
                for (let item of _data["years"])
                    this.years.push(ConsecutiveYear.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsecutiveYears {
        data = typeof data === 'object' ? data : {};
        let result = new ConsecutiveYears();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.unitDetaisl)) {
            data["unitDetaisl"] = [];
            for (let item of this.unitDetaisl)
                data["unitDetaisl"].push(item);
        }
        if (Array.isArray(this.puList)) {
            data["puList"] = [];
            for (let item of this.puList)
                data["puList"].push(item);
        }
        if (Array.isArray(this.years)) {
            data["years"] = [];
            for (let item of this.years)
                data["years"].push(item.toJSON());
        }
        return data;
    }

    clone(): ConsecutiveYears {
        const json = this.toJSON();
        let result = new ConsecutiveYears();
        result.init(json);
        return result;
    }
}

export interface IConsecutiveYears {
    unitDetaisl: any[];
    puList: any[];
    years: ConsecutiveYear[];
}

export class ParentChildCountDto implements IParentChildCountDto {
    parents: number;
    childs: number;

    constructor(data?: IParentChildCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parents = _data["parents"];
            this.childs = _data["childs"];
        }
    }

    static fromJS(data: any): ParentChildCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentChildCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parents"] = this.parents;
        data["childs"] = this.childs;
        return data;
    }

    clone(): ParentChildCountDto {
        const json = this.toJSON();
        let result = new ParentChildCountDto();
        result.init(json);
        return result;
    }
}

export interface IParentChildCountDto {
    parents: number;
    childs: number;
}

export class ByUnitIdsDto implements IByUnitIdsDto {
    unitIds: number[];
    projectId: number;
    unitId: number;
    year: number;

    constructor(data?: IByUnitIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unitIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["unitIds"])) {
                this.unitIds = [] as any;
                for (let item of _data["unitIds"])
                    this.unitIds.push(item);
            }
            this.projectId = _data["projectId"];
            this.unitId = _data["unitId"];
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): ByUnitIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ByUnitIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.unitIds)) {
            data["unitIds"] = [];
            for (let item of this.unitIds)
                data["unitIds"].push(item);
        }
        data["projectId"] = this.projectId;
        data["unitId"] = this.unitId;
        data["year"] = this.year;
        return data;
    }

    clone(): ByUnitIdsDto {
        const json = this.toJSON();
        let result = new ByUnitIdsDto();
        result.init(json);
        return result;
    }
}

export interface IByUnitIdsDto {
    unitIds: number[];
    projectId: number;
    unitId: number;
    year: number;
}

export class CreateManyUnitDto implements ICreateManyUnitDto {
    bulk: Unit[];

    constructor(data?: ICreateManyUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Unit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyUnitDto {
        const json = this.toJSON();
        let result = new CreateManyUnitDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUnitDto {
    bulk: Unit[];
}

export class GetManyLevelResponseDto implements IGetManyLevelResponseDto {
    data: Level[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyLevelResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Level.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyLevelResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyLevelResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyLevelResponseDto {
        const json = this.toJSON();
        let result = new GetManyLevelResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyLevelResponseDto {
    data: Level[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Level implements ILevel {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;

    constructor(data?: ILevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Level {
        data = typeof data === 'object' ? data : {};
        let result = new Level();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }

    clone(): Level {
        const json = this.toJSON();
        let result = new Level();
        result.init(json);
        return result;
    }
}

export interface ILevel {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
}

export class CreateManyLevelDto implements ICreateManyLevelDto {
    bulk: Level[];

    constructor(data?: ICreateManyLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Level.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyLevelDto {
        const json = this.toJSON();
        let result = new CreateManyLevelDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyLevelDto {
    bulk: Level[];
}

export class GetManyUnitDetailsResponseDto implements IGetManyUnitDetailsResponseDto {
    data: UnitDetails[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUnitDetailsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(UnitDetails.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUnitDetailsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUnitDetailsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUnitDetailsResponseDto {
        const json = this.toJSON();
        let result = new GetManyUnitDetailsResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUnitDetailsResponseDto {
    data: UnitDetails[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class UnitDetails implements IUnitDetails {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    address: string;
    addressLine2: string;
    addressLine3: string;
    email: string;
    code: string;
    telephone: string;
    employees: number;
    logopath: string;
    introduction: string;
    baseYear: number;
    baseYearEmission: number;
    faxNumber: string;
    registrationNumber: string;
    unit: Unit;
    unitDetaildto: Unit[];

    constructor(data?: IUnitDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unit = new Unit();
            this.unitDetaildto = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.address = _data["address"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.email = _data["email"];
            this.code = _data["code"];
            this.telephone = _data["telephone"];
            this.employees = _data["employees"];
            this.logopath = _data["logopath"];
            this.introduction = _data["introduction"];
            this.baseYear = _data["baseYear"];
            this.baseYearEmission = _data["baseYearEmission"];
            this.faxNumber = _data["faxNumber"];
            this.registrationNumber = _data["registrationNumber"];
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            if (Array.isArray(_data["unitDetaildto"])) {
                this.unitDetaildto = [] as any;
                for (let item of _data["unitDetaildto"])
                    this.unitDetaildto.push(Unit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UnitDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["address"] = this.address;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["email"] = this.email;
        data["code"] = this.code;
        data["telephone"] = this.telephone;
        data["employees"] = this.employees;
        data["logopath"] = this.logopath;
        data["introduction"] = this.introduction;
        data["baseYear"] = this.baseYear;
        data["baseYearEmission"] = this.baseYearEmission;
        data["faxNumber"] = this.faxNumber;
        data["registrationNumber"] = this.registrationNumber;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        if (Array.isArray(this.unitDetaildto)) {
            data["unitDetaildto"] = [];
            for (let item of this.unitDetaildto)
                data["unitDetaildto"].push(item.toJSON());
        }
        return data;
    }

    clone(): UnitDetails {
        const json = this.toJSON();
        let result = new UnitDetails();
        result.init(json);
        return result;
    }
}

export interface IUnitDetails {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    address: string;
    addressLine2: string;
    addressLine3: string;
    email: string;
    code: string;
    telephone: string;
    employees: number;
    logopath: string;
    introduction: string;
    baseYear: number;
    baseYearEmission: number;
    faxNumber: string;
    registrationNumber: string;
    unit: Unit;
    unitDetaildto: Unit[];
}

export class CreateManyUnitDetailsDto implements ICreateManyUnitDetailsDto {
    bulk: UnitDetails[];

    constructor(data?: ICreateManyUnitDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(UnitDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUnitDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUnitDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyUnitDetailsDto {
        const json = this.toJSON();
        let result = new CreateManyUnitDetailsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUnitDetailsDto {
    bulk: UnitDetails[];
}

export class CreateManyIndustryDto implements ICreateManyIndustryDto {
    bulk: Industry[];

    constructor(data?: ICreateManyIndustryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Industry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyIndustryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyIndustryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyIndustryDto {
        const json = this.toJSON();
        let result = new CreateManyIndustryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyIndustryDto {
    bulk: Industry[];
}

export class GetManyNumEmployeeResponseDto implements IGetManyNumEmployeeResponseDto {
    data: NumEmployee[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyNumEmployeeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(NumEmployee.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyNumEmployeeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyNumEmployeeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyNumEmployeeResponseDto {
        const json = this.toJSON();
        let result = new GetManyNumEmployeeResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyNumEmployeeResponseDto {
    data: NumEmployee[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class NumEmployee implements INumEmployee {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: string;
    totalEmployees: number;
    totalEmployeesPaid: number;
    totalRevenue: number;
    totalRevenue_unit: string;
    target: number;
    unitDetail: UnitDetails;
    dto: any;

    constructor(data?: INumEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unitDetail = new UnitDetails();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.totalEmployees = _data["totalEmployees"];
            this.totalEmployeesPaid = _data["totalEmployeesPaid"];
            this.totalRevenue = _data["totalRevenue"];
            this.totalRevenue_unit = _data["totalRevenue_unit"];
            this.target = _data["target"];
            this.unitDetail = _data["unitDetail"] ? UnitDetails.fromJS(_data["unitDetail"]) : new UnitDetails();
            this.dto = _data["dto"];
        }
    }

    static fromJS(data: any): NumEmployee {
        data = typeof data === 'object' ? data : {};
        let result = new NumEmployee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["totalEmployees"] = this.totalEmployees;
        data["totalEmployeesPaid"] = this.totalEmployeesPaid;
        data["totalRevenue"] = this.totalRevenue;
        data["totalRevenue_unit"] = this.totalRevenue_unit;
        data["target"] = this.target;
        data["unitDetail"] = this.unitDetail ? this.unitDetail.toJSON() : <any>undefined;
        data["dto"] = this.dto;
        return data;
    }

    clone(): NumEmployee {
        const json = this.toJSON();
        let result = new NumEmployee();
        result.init(json);
        return result;
    }
}

export interface INumEmployee {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: string;
    totalEmployees: number;
    totalEmployeesPaid: number;
    totalRevenue: number;
    totalRevenue_unit: string;
    target: number;
    unitDetail: UnitDetails;
    dto: any;
}

export class CreateManyNumEmployeeDto implements ICreateManyNumEmployeeDto {
    bulk: NumEmployee[];

    constructor(data?: ICreateManyNumEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(NumEmployee.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyNumEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyNumEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyNumEmployeeDto {
        const json = this.toJSON();
        let result = new CreateManyNumEmployeeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyNumEmployeeDto {
    bulk: NumEmployee[];
}

export class GetManyPrevReportResponseDto implements IGetManyPrevReportResponseDto {
    data: PrevReport[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPrevReportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PrevReport.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPrevReportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPrevReportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyPrevReportResponseDto {
        const json = this.toJSON();
        let result = new GetManyPrevReportResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPrevReportResponseDto {
    data: PrevReport[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PrevReport implements IPrevReport {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    unitDetail: UnitDetails;
    document: Documents;

    constructor(data?: IPrevReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unitDetail = new UnitDetails();
            this.document = new Documents();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.unitDetail = _data["unitDetail"] ? UnitDetails.fromJS(_data["unitDetail"]) : new UnitDetails();
            this.document = _data["document"] ? Documents.fromJS(_data["document"]) : new Documents();
        }
    }

    static fromJS(data: any): PrevReport {
        data = typeof data === 'object' ? data : {};
        let result = new PrevReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["unitDetail"] = this.unitDetail ? this.unitDetail.toJSON() : <any>undefined;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        return data;
    }

    clone(): PrevReport {
        const json = this.toJSON();
        let result = new PrevReport();
        result.init(json);
        return result;
    }
}

export interface IPrevReport {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    unitDetail: UnitDetails;
    document: Documents;
}

export class CreateManyPrevReportDto implements ICreateManyPrevReportDto {
    bulk: PrevReport[];

    constructor(data?: ICreateManyPrevReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PrevReport.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPrevReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPrevReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyPrevReportDto {
        const json = this.toJSON();
        let result = new CreateManyPrevReportDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPrevReportDto {
    bulk: PrevReport[];
}

export class GetManyPrevEmissionResponseDto implements IGetManyPrevEmissionResponseDto {
    data: PrevEmission[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPrevEmissionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PrevEmission.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPrevEmissionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPrevEmissionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyPrevEmissionResponseDto {
        const json = this.toJSON();
        let result = new GetManyPrevEmissionResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPrevEmissionResponseDto {
    data: PrevEmission[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PrevEmission implements IPrevEmission {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    unit: Unit;
    projectType: ProjectType;
    emissionSource: EmissionSource;
    ownership: string;
    e_sc: number;

    constructor(data?: IPrevEmission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unit = new Unit();
            this.projectType = new ProjectType();
            this.emissionSource = new EmissionSource();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.projectType = _data["projectType"] ? ProjectType.fromJS(_data["projectType"]) : new ProjectType();
            this.emissionSource = _data["emissionSource"] ? EmissionSource.fromJS(_data["emissionSource"]) : new EmissionSource();
            this.ownership = _data["ownership"];
            this.e_sc = _data["e_sc"];
        }
    }

    static fromJS(data: any): PrevEmission {
        data = typeof data === 'object' ? data : {};
        let result = new PrevEmission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["emissionSource"] = this.emissionSource ? this.emissionSource.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["e_sc"] = this.e_sc;
        return data;
    }

    clone(): PrevEmission {
        const json = this.toJSON();
        let result = new PrevEmission();
        result.init(json);
        return result;
    }
}

export interface IPrevEmission {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    unit: Unit;
    projectType: ProjectType;
    emissionSource: EmissionSource;
    ownership: string;
    e_sc: number;
}

export class CreateManyPrevEmissionDto implements ICreateManyPrevEmissionDto {
    bulk: PrevEmission[];

    constructor(data?: ICreateManyPrevEmissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PrevEmission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPrevEmissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPrevEmissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyPrevEmissionDto {
        const json = this.toJSON();
        let result = new CreateManyPrevEmissionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPrevEmissionDto {
    bulk: PrevEmission[];
}

export class GetManyUnitDetailMessageResponseDto implements IGetManyUnitDetailMessageResponseDto {
    data: UnitDetailMessage[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUnitDetailMessageResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(UnitDetailMessage.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUnitDetailMessageResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUnitDetailMessageResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUnitDetailMessageResponseDto {
        const json = this.toJSON();
        let result = new GetManyUnitDetailMessageResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUnitDetailMessageResponseDto {
    data: UnitDetailMessage[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class UnitDetailMessage implements IUnitDetailMessage {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    message: string;
    messageAction: UnitDetailMessageMessageAction;
    date: moment.Moment;
    unit: Unit;

    constructor(data?: IUnitDetailMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unit = new Unit();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.message = _data["message"];
            this.messageAction = _data["messageAction"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
        }
    }

    static fromJS(data: any): UnitDetailMessage {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDetailMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["message"] = this.message;
        data["messageAction"] = this.messageAction;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        return data;
    }

    clone(): UnitDetailMessage {
        const json = this.toJSON();
        let result = new UnitDetailMessage();
        result.init(json);
        return result;
    }
}

export interface IUnitDetailMessage {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    message: string;
    messageAction: UnitDetailMessageMessageAction;
    date: moment.Moment;
    unit: Unit;
}

export class CreateManyUnitDetailMessageDto implements ICreateManyUnitDetailMessageDto {
    bulk: UnitDetailMessage[];

    constructor(data?: ICreateManyUnitDetailMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(UnitDetailMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUnitDetailMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUnitDetailMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyUnitDetailMessageDto {
        const json = this.toJSON();
        let result = new CreateManyUnitDetailMessageDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUnitDetailMessageDto {
    bulk: UnitDetailMessage[];
}

export class CreateManyCountryDto implements ICreateManyCountryDto {
    bulk: Country[];

    constructor(data?: ICreateManyCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyCountryDto {
        const json = this.toJSON();
        let result = new CreateManyCountryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyCountryDto {
    bulk: Country[];
}

export class BulckDeletDto implements IBulckDeletDto {
    es: BulckDeletDtoEs;
    ids: number[];
    isPermant: boolean;

    constructor(data?: IBulckDeletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.es = _data["es"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
            this.isPermant = _data["isPermant"];
        }
    }

    static fromJS(data: any): BulckDeletDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulckDeletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["es"] = this.es;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["isPermant"] = this.isPermant;
        return data;
    }

    clone(): BulckDeletDto {
        const json = this.toJSON();
        let result = new BulckDeletDto();
        result.init(json);
        return result;
    }
}

export interface IBulckDeletDto {
    es: BulckDeletDtoEs;
    ids: number[];
    isPermant: boolean;
}

export class ManyActivityDataDto implements IManyActivityDataDto {
    projectId: number;
    unitIds: number[];
    userIds: number[];
    es: ManyActivityDataDtoEs;
    esList: EsList[];

    constructor(data?: IManyActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unitIds = [];
            this.userIds = [];
            this.esList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            if (Array.isArray(_data["unitIds"])) {
                this.unitIds = [] as any;
                for (let item of _data["unitIds"])
                    this.unitIds.push(item);
            }
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds.push(item);
            }
            this.es = _data["es"];
            if (Array.isArray(_data["esList"])) {
                this.esList = [] as any;
                for (let item of _data["esList"])
                    this.esList.push(item);
            }
        }
    }

    static fromJS(data: any): ManyActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManyActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        if (Array.isArray(this.unitIds)) {
            data["unitIds"] = [];
            for (let item of this.unitIds)
                data["unitIds"].push(item);
        }
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["es"] = this.es;
        if (Array.isArray(this.esList)) {
            data["esList"] = [];
            for (let item of this.esList)
                data["esList"].push(item);
        }
        return data;
    }

    clone(): ManyActivityDataDto {
        const json = this.toJSON();
        let result = new ManyActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IManyActivityDataDto {
    projectId: number;
    unitIds: number[];
    userIds: number[];
    es: ManyActivityDataDtoEs;
    esList: EsList[];
}

export class BulckCalculatio implements IBulckCalculatio {
    projectId: number;
    unitIds: number[];
    esList: EsList2[];

    constructor(data?: IBulckCalculatio) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unitIds = [];
            this.esList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            if (Array.isArray(_data["unitIds"])) {
                this.unitIds = [] as any;
                for (let item of _data["unitIds"])
                    this.unitIds.push(item);
            }
            if (Array.isArray(_data["esList"])) {
                this.esList = [] as any;
                for (let item of _data["esList"])
                    this.esList.push(item);
            }
        }
    }

    static fromJS(data: any): BulckCalculatio {
        data = typeof data === 'object' ? data : {};
        let result = new BulckCalculatio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        if (Array.isArray(this.unitIds)) {
            data["unitIds"] = [];
            for (let item of this.unitIds)
                data["unitIds"].push(item);
        }
        if (Array.isArray(this.esList)) {
            data["esList"] = [];
            for (let item of this.esList)
                data["esList"].push(item);
        }
        return data;
    }

    clone(): BulckCalculatio {
        const json = this.toJSON();
        let result = new BulckCalculatio();
        result.init(json);
        return result;
    }
}

export interface IBulckCalculatio {
    projectId: number;
    unitIds: number[];
    esList: EsList2[];
}

export class ProgressDetailDto implements IProgressDetailDto {
    projectId: number;
    unitId: number;
    esCode: ProgressDetailDtoEsCode;
    parameters: any[];
    isEc: boolean;
    ecDetails: any;

    constructor(data?: IProgressDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parameters = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.unitId = _data["unitId"];
            this.esCode = _data["esCode"];
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters.push(item);
            }
            this.isEc = _data["isEc"];
            this.ecDetails = _data["ecDetails"];
        }
    }

    static fromJS(data: any): ProgressDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgressDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["unitId"] = this.unitId;
        data["esCode"] = this.esCode;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item);
        }
        data["isEc"] = this.isEc;
        data["ecDetails"] = this.ecDetails;
        return data;
    }

    clone(): ProgressDetailDto {
        const json = this.toJSON();
        let result = new ProgressDetailDto();
        result.init(json);
        return result;
    }
}

export interface IProgressDetailDto {
    projectId: number;
    unitId: number;
    esCode: ProgressDetailDtoEsCode;
    parameters: any[];
    isEc: boolean;
    ecDetails: any;
}

export class ActivityDataDownloadDto implements IActivityDataDownloadDto {
    projectId: number;
    esCode: ActivityDataDownloadDtoEsCode;
    optional: any;

    constructor(data?: IActivityDataDownloadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.esCode = _data["esCode"];
            this.optional = _data["optional"];
        }
    }

    static fromJS(data: any): ActivityDataDownloadDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDataDownloadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["esCode"] = this.esCode;
        data["optional"] = this.optional;
        return data;
    }

    clone(): ActivityDataDownloadDto {
        const json = this.toJSON();
        let result = new ActivityDataDownloadDto();
        result.init(json);
        return result;
    }
}

export interface IActivityDataDownloadDto {
    projectId: number;
    esCode: ActivityDataDownloadDtoEsCode;
    optional: any;
}

export class GetManyElectricityActivityDataResponseDto implements IGetManyElectricityActivityDataResponseDto {
    data: ElectricityActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyElectricityActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ElectricityActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyElectricityActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyElectricityActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyElectricityActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyElectricityActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyElectricityActivityDataResponseDto {
    data: ElectricityActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ElectricityActivityData implements IElectricityActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    meterNo: string;
    month: number;
    year: number;
    consumption: number;
    consumption_unit: string;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: ElectricityActivityDataActivityDataStatus;

    constructor(data?: IElectricityActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.meterNo = _data["meterNo"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.consumption = _data["consumption"];
            this.consumption_unit = _data["consumption_unit"];
            this.emission = _data["emission"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): ElectricityActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new ElectricityActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["meterNo"] = this.meterNo;
        data["month"] = this.month;
        data["year"] = this.year;
        data["consumption"] = this.consumption;
        data["consumption_unit"] = this.consumption_unit;
        data["emission"] = this.emission;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): ElectricityActivityData {
        const json = this.toJSON();
        let result = new ElectricityActivityData();
        result.init(json);
        return result;
    }
}

export interface IElectricityActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    meterNo: string;
    month: number;
    year: number;
    consumption: number;
    consumption_unit: string;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: ElectricityActivityDataActivityDataStatus;
}

export class CreateManyElectricityActivityDataDto implements ICreateManyElectricityActivityDataDto {
    bulk: ElectricityActivityData[];

    constructor(data?: ICreateManyElectricityActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ElectricityActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyElectricityActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyElectricityActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyElectricityActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyElectricityActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyElectricityActivityDataDto {
    bulk: ElectricityActivityData[];
}

export class PesEmissionsDto implements IPesEmissionsDto {
    total: number;
    direct: number;
    indirect: number;
    other: number;
    es: EmissionSource;

    constructor(data?: IPesEmissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.es = new EmissionSource();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.es = _data["es"] ? EmissionSource.fromJS(_data["es"]) : new EmissionSource();
        }
    }

    static fromJS(data: any): PesEmissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PesEmissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["es"] = this.es ? this.es.toJSON() : <any>undefined;
        return data;
    }

    clone(): PesEmissionsDto {
        const json = this.toJSON();
        let result = new PesEmissionsDto();
        result.init(json);
        return result;
    }
}

export interface IPesEmissionsDto {
    total: number;
    direct: number;
    indirect: number;
    other: number;
    es: EmissionSource;
}

export class EmissionSourceOfProject implements IEmissionSourceOfProject {
    projetId: number;
    emissionSourceId: number;

    constructor(data?: IEmissionSourceOfProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projetId = _data["projetId"];
            this.emissionSourceId = _data["emissionSourceId"];
        }
    }

    static fromJS(data: any): EmissionSourceOfProject {
        data = typeof data === 'object' ? data : {};
        let result = new EmissionSourceOfProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projetId"] = this.projetId;
        data["emissionSourceId"] = this.emissionSourceId;
        return data;
    }

    clone(): EmissionSourceOfProject {
        const json = this.toJSON();
        let result = new EmissionSourceOfProject();
        result.init(json);
        return result;
    }
}

export interface IEmissionSourceOfProject {
    projetId: number;
    emissionSourceId: number;
}

export class EmissionSourceOfProjectUnit implements IEmissionSourceOfProjectUnit {
    projetUnitId: number;
    emissionSourceId: number;
    tier: EmissionSourceOfProjectUnitTier | undefined;
    scope: EmissionSourceOfProjectUnitScope;
    clasification: EmissionSourceOfProjectUnitClasification;
    mobile: boolean;
    stationery: boolean;

    constructor(data?: IEmissionSourceOfProjectUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projetUnitId = _data["projetUnitId"];
            this.emissionSourceId = _data["emissionSourceId"];
            this.tier = _data["tier"];
            this.scope = _data["scope"];
            this.clasification = _data["clasification"];
            this.mobile = _data["mobile"];
            this.stationery = _data["stationery"];
        }
    }

    static fromJS(data: any): EmissionSourceOfProjectUnit {
        data = typeof data === 'object' ? data : {};
        let result = new EmissionSourceOfProjectUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projetUnitId"] = this.projetUnitId;
        data["emissionSourceId"] = this.emissionSourceId;
        data["tier"] = this.tier;
        data["scope"] = this.scope;
        data["clasification"] = this.clasification;
        data["mobile"] = this.mobile;
        data["stationery"] = this.stationery;
        return data;
    }

    clone(): EmissionSourceOfProjectUnit {
        const json = this.toJSON();
        let result = new EmissionSourceOfProjectUnit();
        result.init(json);
        return result;
    }
}

export interface IEmissionSourceOfProjectUnit {
    projetUnitId: number;
    emissionSourceId: number;
    tier: EmissionSourceOfProjectUnitTier | undefined;
    scope: EmissionSourceOfProjectUnitScope;
    clasification: EmissionSourceOfProjectUnitClasification;
    mobile: boolean;
    stationery: boolean;
}

export class EmissionSourceListOfProject implements IEmissionSourceListOfProject {
    projetId: number;
    emissionSourceIdList: number[];

    constructor(data?: IEmissionSourceListOfProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.emissionSourceIdList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projetId = _data["projetId"];
            if (Array.isArray(_data["emissionSourceIdList"])) {
                this.emissionSourceIdList = [] as any;
                for (let item of _data["emissionSourceIdList"])
                    this.emissionSourceIdList.push(item);
            }
        }
    }

    static fromJS(data: any): EmissionSourceListOfProject {
        data = typeof data === 'object' ? data : {};
        let result = new EmissionSourceListOfProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projetId"] = this.projetId;
        if (Array.isArray(this.emissionSourceIdList)) {
            data["emissionSourceIdList"] = [];
            for (let item of this.emissionSourceIdList)
                data["emissionSourceIdList"].push(item);
        }
        return data;
    }

    clone(): EmissionSourceListOfProject {
        const json = this.toJSON();
        let result = new EmissionSourceListOfProject();
        result.init(json);
        return result;
    }
}

export interface IEmissionSourceListOfProject {
    projetId: number;
    emissionSourceIdList: number[];
}

export class ListOfEmissionSourceOfProjectUnit implements IListOfEmissionSourceOfProjectUnit {
    list: EmissionSourceOfProjectUnit[];

    constructor(data?: IListOfEmissionSourceOfProjectUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list.push(EmissionSourceOfProjectUnit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOfEmissionSourceOfProjectUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ListOfEmissionSourceOfProjectUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data;
    }

    clone(): ListOfEmissionSourceOfProjectUnit {
        const json = this.toJSON();
        let result = new ListOfEmissionSourceOfProjectUnit();
        result.init(json);
        return result;
    }
}

export interface IListOfEmissionSourceOfProjectUnit {
    list: EmissionSourceOfProjectUnit[];
}

export class OrgEmissionDto implements IOrgEmissionDto {
    activeYear: number;
    emissions: any;

    constructor(data?: IOrgEmissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activeYear = _data["activeYear"];
            this.emissions = _data["emissions"];
        }
    }

    static fromJS(data: any): OrgEmissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrgEmissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activeYear"] = this.activeYear;
        data["emissions"] = this.emissions;
        return data;
    }

    clone(): OrgEmissionDto {
        const json = this.toJSON();
        let result = new OrgEmissionDto();
        result.init(json);
        return result;
    }
}

export interface IOrgEmissionDto {
    activeYear: number;
    emissions: any;
}

export class ActiveClosedProjectDto implements IActiveClosedProjectDto {
    active: number;
    closed: number;

    constructor(data?: IActiveClosedProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.closed = _data["closed"];
        }
    }

    static fromJS(data: any): ActiveClosedProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveClosedProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["closed"] = this.closed;
        return data;
    }

    clone(): ActiveClosedProjectDto {
        const json = this.toJSON();
        let result = new ActiveClosedProjectDto();
        result.init(json);
        return result;
    }
}

export interface IActiveClosedProjectDto {
    active: number;
    closed: number;
}

export class CreateManyProjectDto implements ICreateManyProjectDto {
    bulk: Project[];

    constructor(data?: ICreateManyProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Project.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyProjectDto {
        const json = this.toJSON();
        let result = new CreateManyProjectDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProjectDto {
    bulk: Project[];
}

export class CreateManyProjectTypeDto implements ICreateManyProjectTypeDto {
    bulk: ProjectType[];

    constructor(data?: ICreateManyProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ProjectType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyProjectTypeDto {
        const json = this.toJSON();
        let result = new CreateManyProjectTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProjectTypeDto {
    bulk: ProjectType[];
}

export class CreateManyMethodologyDto implements ICreateManyMethodologyDto {
    bulk: Methodology[];

    constructor(data?: ICreateManyMethodologyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Methodology.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyMethodologyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyMethodologyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyMethodologyDto {
        const json = this.toJSON();
        let result = new CreateManyMethodologyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyMethodologyDto {
    bulk: Methodology[];
}

export class ProjectTypeDto implements IProjectTypeDto {
    unitIds: number[];
    projectType: string;

    constructor(data?: IProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unitIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["unitIds"])) {
                this.unitIds = [] as any;
                for (let item of _data["unitIds"])
                    this.unitIds.push(item);
            }
            this.projectType = _data["projectType"];
        }
    }

    static fromJS(data: any): ProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.unitIds)) {
            data["unitIds"] = [];
            for (let item of this.unitIds)
                data["unitIds"].push(item);
        }
        data["projectType"] = this.projectType;
        return data;
    }

    clone(): ProjectTypeDto {
        const json = this.toJSON();
        let result = new ProjectTypeDto();
        result.init(json);
        return result;
    }
}

export interface IProjectTypeDto {
    unitIds: number[];
    projectType: string;
}

export class CreateManyProjectUnitDto implements ICreateManyProjectUnitDto {
    bulk: ProjectUnit[];

    constructor(data?: ICreateManyProjectUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ProjectUnit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProjectUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProjectUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyProjectUnitDto {
        const json = this.toJSON();
        let result = new CreateManyProjectUnitDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProjectUnitDto {
    bulk: ProjectUnit[];
}

export class PuesDataReqActivityData implements IPuesDataReqActivityData {
    owenerShip: PuesDataReqActivityDataOwenerShip | undefined;
    mobile: boolean;
    stationary: boolean;
    paidByCompany: boolean;

    constructor(data?: IPuesDataReqActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.mobile = false;
            this.stationary = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.owenerShip = _data["owenerShip"];
            this.mobile = _data["mobile"] !== undefined ? _data["mobile"] : false;
            this.stationary = _data["stationary"] !== undefined ? _data["stationary"] : false;
            this.paidByCompany = _data["paidByCompany"];
        }
    }

    static fromJS(data: any): PuesDataReqActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new PuesDataReqActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["owenerShip"] = this.owenerShip;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["paidByCompany"] = this.paidByCompany;
        return data;
    }

    clone(): PuesDataReqActivityData {
        const json = this.toJSON();
        let result = new PuesDataReqActivityData();
        result.init(json);
        return result;
    }
}

export interface IPuesDataReqActivityData {
    owenerShip: PuesDataReqActivityDataOwenerShip | undefined;
    mobile: boolean;
    stationary: boolean;
    paidByCompany: boolean;
}

export class PuesDataReqDto implements IPuesDataReqDto {
    sourceName: PuesDataReqDtoSourceName;
    project: Project;
    user: User;
    unitId: number;
    activityInfo: PuesDataReqActivityData;

    constructor(data?: IPuesDataReqDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.project = new Project();
            this.user = new User();
            this.activityInfo = new PuesDataReqActivityData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceName = _data["sourceName"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unitId = _data["unitId"];
            this.activityInfo = _data["activityInfo"] ? PuesDataReqActivityData.fromJS(_data["activityInfo"]) : new PuesDataReqActivityData();
        }
    }

    static fromJS(data: any): PuesDataReqDto {
        data = typeof data === 'object' ? data : {};
        let result = new PuesDataReqDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceName"] = this.sourceName;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unitId"] = this.unitId;
        data["activityInfo"] = this.activityInfo ? this.activityInfo.toJSON() : <any>undefined;
        return data;
    }

    clone(): PuesDataReqDto {
        const json = this.toJSON();
        let result = new PuesDataReqDto();
        result.init(json);
        return result;
    }
}

export interface IPuesDataReqDto {
    sourceName: PuesDataReqDtoSourceName;
    project: Project;
    user: User;
    unitId: number;
    activityInfo: PuesDataReqActivityData;
}

export class PuesDataDto implements IPuesDataDto {
    clasification: PuesDataDtoClasification;
    tier: PuesDataDtoTier | undefined;
    sourceType: PuesDataDtoSourceType | undefined;
    industry: Industry;
    countryCode: string;

    constructor(data?: IPuesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.industry = new Industry();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clasification = _data["clasification"];
            this.tier = _data["tier"];
            this.sourceType = _data["sourceType"];
            this.industry = _data["industry"] ? Industry.fromJS(_data["industry"]) : new Industry();
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): PuesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new PuesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clasification"] = this.clasification;
        data["tier"] = this.tier;
        data["sourceType"] = this.sourceType;
        data["industry"] = this.industry ? this.industry.toJSON() : <any>undefined;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): PuesDataDto {
        const json = this.toJSON();
        let result = new PuesDataDto();
        result.init(json);
        return result;
    }
}

export interface IPuesDataDto {
    clasification: PuesDataDtoClasification;
    tier: PuesDataDtoTier | undefined;
    sourceType: PuesDataDtoSourceType | undefined;
    industry: Industry;
    countryCode: string;
}

export class EmissionSumDto implements IEmissionSumDto {
    sum: any;
    activeYear: string;

    constructor(data?: IEmissionSumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sum = _data["sum"];
            this.activeYear = _data["activeYear"];
        }
    }

    static fromJS(data: any): EmissionSumDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmissionSumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sum"] = this.sum;
        data["activeYear"] = this.activeYear;
        return data;
    }

    clone(): EmissionSumDto {
        const json = this.toJSON();
        let result = new EmissionSumDto();
        result.init(json);
        return result;
    }
}

export interface IEmissionSumDto {
    sum: any;
    activeYear: string;
}

export class ByProjectUnitIdsDto implements IByProjectUnitIdsDto {
    projectUnitIds: number[];

    constructor(data?: IByProjectUnitIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectUnitIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projectUnitIds"])) {
                this.projectUnitIds = [] as any;
                for (let item of _data["projectUnitIds"])
                    this.projectUnitIds.push(item);
            }
        }
    }

    static fromJS(data: any): ByProjectUnitIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ByProjectUnitIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projectUnitIds)) {
            data["projectUnitIds"] = [];
            for (let item of this.projectUnitIds)
                data["projectUnitIds"].push(item);
        }
        return data;
    }

    clone(): ByProjectUnitIdsDto {
        const json = this.toJSON();
        let result = new ByProjectUnitIdsDto();
        result.init(json);
        return result;
    }
}

export interface IByProjectUnitIdsDto {
    projectUnitIds: number[];
}

export class CreateManyProjectUnitEmissionSourceDto implements ICreateManyProjectUnitEmissionSourceDto {
    bulk: ProjectUnitEmissionSource[];

    constructor(data?: ICreateManyProjectUnitEmissionSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ProjectUnitEmissionSource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProjectUnitEmissionSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProjectUnitEmissionSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyProjectUnitEmissionSourceDto {
        const json = this.toJSON();
        let result = new CreateManyProjectUnitEmissionSourceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProjectUnitEmissionSourceDto {
    bulk: ProjectUnitEmissionSource[];
}

export class CreateManyEmissionSourceDto implements ICreateManyEmissionSourceDto {
    bulk: EmissionSource[];

    constructor(data?: ICreateManyEmissionSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(EmissionSource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyEmissionSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyEmissionSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyEmissionSourceDto {
        const json = this.toJSON();
        let result = new CreateManyEmissionSourceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyEmissionSourceDto {
    bulk: EmissionSource[];
}

export class CreateManyProjectEmissionSourceDto implements ICreateManyProjectEmissionSourceDto {
    bulk: ProjectEmissionSource[];

    constructor(data?: ICreateManyProjectEmissionSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ProjectEmissionSource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProjectEmissionSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProjectEmissionSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyProjectEmissionSourceDto {
        const json = this.toJSON();
        let result = new CreateManyProjectEmissionSourceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProjectEmissionSourceDto {
    bulk: ProjectEmissionSource[];
}

export class GetManyEsDatasourceResponseDto implements IGetManyEsDatasourceResponseDto {
    data: EsDatasource[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyEsDatasourceResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(EsDatasource.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyEsDatasourceResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyEsDatasourceResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyEsDatasourceResponseDto {
        const json = this.toJSON();
        let result = new GetManyEsDatasourceResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyEsDatasourceResponseDto {
    data: EsDatasource[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyReportResponseDto implements IGetManyReportResponseDto {
    data: Report[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyReportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Report.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyReportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyReportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyReportResponseDto {
        const json = this.toJSON();
        let result = new GetManyReportResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyReportResponseDto {
    data: Report[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyRecomendationResponseDto implements IGetManyRecomendationResponseDto {
    data: Recomendation[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyRecomendationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Recomendation.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyRecomendationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyRecomendationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyRecomendationResponseDto {
        const json = this.toJSON();
        let result = new GetManyRecomendationResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyRecomendationResponseDto {
    data: Recomendation[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Recomendation implements IRecomendation {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    title: string;
    descryption: string;

    constructor(data?: IRecomendation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.title = _data["title"];
            this.descryption = _data["descryption"];
        }
    }

    static fromJS(data: any): Recomendation {
        data = typeof data === 'object' ? data : {};
        let result = new Recomendation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["title"] = this.title;
        data["descryption"] = this.descryption;
        return data;
    }

    clone(): Recomendation {
        const json = this.toJSON();
        let result = new Recomendation();
        result.init(json);
        return result;
    }
}

export interface IRecomendation {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    title: string;
    descryption: string;
}

export class GetManyNextStepResponseDto implements IGetManyNextStepResponseDto {
    data: NextStep[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyNextStepResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(NextStep.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyNextStepResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyNextStepResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyNextStepResponseDto {
        const json = this.toJSON();
        let result = new GetManyNextStepResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyNextStepResponseDto {
    data: NextStep[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class NextStep implements INextStep {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    descryption: string;

    constructor(data?: INextStep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.descryption = _data["descryption"];
        }
    }

    static fromJS(data: any): NextStep {
        data = typeof data === 'object' ? data : {};
        let result = new NextStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["descryption"] = this.descryption;
        return data;
    }

    clone(): NextStep {
        const json = this.toJSON();
        let result = new NextStep();
        result.init(json);
        return result;
    }
}

export interface INextStep {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    descryption: string;
}

export class GetManyUncertaintyResponseDto implements IGetManyUncertaintyResponseDto {
    data: Uncertainty[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUncertaintyResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Uncertainty.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUncertaintyResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUncertaintyResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUncertaintyResponseDto {
        const json = this.toJSON();
        let result = new GetManyUncertaintyResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUncertaintyResponseDto {
    data: Uncertainty[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Uncertainty implements IUncertainty {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    descryption: string;
    ownership: string;
    emissionSource: EmissionSource;
    report: Report;

    constructor(data?: IUncertainty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.emissionSource = new EmissionSource();
            this.report = new Report();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.descryption = _data["descryption"];
            this.ownership = _data["ownership"];
            this.emissionSource = _data["emissionSource"] ? EmissionSource.fromJS(_data["emissionSource"]) : new EmissionSource();
            this.report = _data["report"] ? Report.fromJS(_data["report"]) : new Report();
        }
    }

    static fromJS(data: any): Uncertainty {
        data = typeof data === 'object' ? data : {};
        let result = new Uncertainty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["descryption"] = this.descryption;
        data["ownership"] = this.ownership;
        data["emissionSource"] = this.emissionSource ? this.emissionSource.toJSON() : <any>undefined;
        data["report"] = this.report ? this.report.toJSON() : <any>undefined;
        return data;
    }

    clone(): Uncertainty {
        const json = this.toJSON();
        let result = new Uncertainty();
        result.init(json);
        return result;
    }
}

export interface IUncertainty {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    descryption: string;
    ownership: string;
    emissionSource: EmissionSource;
    report: Report;
}

export class Report implements IReport {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    dissemination: string;
    dataGatheringMethods: string;
    attempt: number;
    iSOStandard: string;
    previousYearISOStandard: string;
    proposedDate: moment.Moment;
    proposalNumber: string;
    lessOrGreater: string;
    indirectLimit: number;
    unit: Unit;
    project: Project;
    recommendations: Recomendation[];
    nextSteps: NextStep[];
    uncertainty: Uncertainty[];
    standardAndApproach: string;
    allowClientGenerate: any;
    responsiblePerson: string;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unit = new Unit();
            this.project = new Project();
            this.recommendations = [];
            this.nextSteps = [];
            this.uncertainty = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.dissemination = _data["dissemination"];
            this.dataGatheringMethods = _data["dataGatheringMethods"];
            this.attempt = _data["attempt"];
            this.iSOStandard = _data["iSOStandard"];
            this.previousYearISOStandard = _data["previousYearISOStandard"];
            this.proposedDate = _data["proposedDate"] ? moment(_data["proposedDate"].toString()) : <any>undefined;
            this.proposalNumber = _data["proposalNumber"];
            this.lessOrGreater = _data["lessOrGreater"];
            this.indirectLimit = _data["indirectLimit"];
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            if (Array.isArray(_data["recommendations"])) {
                this.recommendations = [] as any;
                for (let item of _data["recommendations"])
                    this.recommendations.push(Recomendation.fromJS(item));
            }
            if (Array.isArray(_data["nextSteps"])) {
                this.nextSteps = [] as any;
                for (let item of _data["nextSteps"])
                    this.nextSteps.push(NextStep.fromJS(item));
            }
            if (Array.isArray(_data["uncertainty"])) {
                this.uncertainty = [] as any;
                for (let item of _data["uncertainty"])
                    this.uncertainty.push(Uncertainty.fromJS(item));
            }
            this.standardAndApproach = _data["standardAndApproach"];
            this.allowClientGenerate = _data["allowClientGenerate"];
            this.responsiblePerson = _data["responsiblePerson"];
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["dissemination"] = this.dissemination;
        data["dataGatheringMethods"] = this.dataGatheringMethods;
        data["attempt"] = this.attempt;
        data["iSOStandard"] = this.iSOStandard;
        data["previousYearISOStandard"] = this.previousYearISOStandard;
        data["proposedDate"] = this.proposedDate ? this.proposedDate.toISOString() : <any>undefined;
        data["proposalNumber"] = this.proposalNumber;
        data["lessOrGreater"] = this.lessOrGreater;
        data["indirectLimit"] = this.indirectLimit;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        if (Array.isArray(this.recommendations)) {
            data["recommendations"] = [];
            for (let item of this.recommendations)
                data["recommendations"].push(item.toJSON());
        }
        if (Array.isArray(this.nextSteps)) {
            data["nextSteps"] = [];
            for (let item of this.nextSteps)
                data["nextSteps"].push(item.toJSON());
        }
        if (Array.isArray(this.uncertainty)) {
            data["uncertainty"] = [];
            for (let item of this.uncertainty)
                data["uncertainty"].push(item.toJSON());
        }
        data["standardAndApproach"] = this.standardAndApproach;
        data["allowClientGenerate"] = this.allowClientGenerate;
        data["responsiblePerson"] = this.responsiblePerson;
        return data;
    }

    clone(): Report {
        const json = this.toJSON();
        let result = new Report();
        result.init(json);
        return result;
    }
}

export interface IReport {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    dissemination: string;
    dataGatheringMethods: string;
    attempt: number;
    iSOStandard: string;
    previousYearISOStandard: string;
    proposedDate: moment.Moment;
    proposalNumber: string;
    lessOrGreater: string;
    indirectLimit: number;
    unit: Unit;
    project: Project;
    recommendations: Recomendation[];
    nextSteps: NextStep[];
    uncertainty: Uncertainty[];
    standardAndApproach: string;
    allowClientGenerate: any;
    responsiblePerson: string;
}

export class GetManyEmissionCategoryResponseDto implements IGetManyEmissionCategoryResponseDto {
    data: EmissionCategory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyEmissionCategoryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(EmissionCategory.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyEmissionCategoryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyEmissionCategoryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyEmissionCategoryResponseDto {
        const json = this.toJSON();
        let result = new GetManyEmissionCategoryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyEmissionCategoryResponseDto {
    data: EmissionCategory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class EmissionCategory implements IEmissionCategory {
    id: number;
    code: string;
    name: string;

    constructor(data?: IEmissionCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EmissionCategory {
        data = typeof data === 'object' ? data : {};
        let result = new EmissionCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }

    clone(): EmissionCategory {
        const json = this.toJSON();
        let result = new EmissionCategory();
        result.init(json);
        return result;
    }
}

export interface IEmissionCategory {
    id: number;
    code: string;
    name: string;
}

export class EsDatasource implements IEsDatasource {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    hiredDataSource: string;
    rentedDataSource: string;
    ownDataSource: string;
    noneDataSource: string;
    emissionSource: EmissionSource;
    report: Report;
    hiredCategory: EmissionCategory;
    rentedCategory: EmissionCategory;
    ownCategory: EmissionCategory;
    noneCategory: EmissionCategory;

    constructor(data?: IEsDatasource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.emissionSource = new EmissionSource();
            this.report = new Report();
            this.hiredCategory = new EmissionCategory();
            this.rentedCategory = new EmissionCategory();
            this.ownCategory = new EmissionCategory();
            this.noneCategory = new EmissionCategory();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.hiredDataSource = _data["hiredDataSource"];
            this.rentedDataSource = _data["rentedDataSource"];
            this.ownDataSource = _data["ownDataSource"];
            this.noneDataSource = _data["noneDataSource"];
            this.emissionSource = _data["emissionSource"] ? EmissionSource.fromJS(_data["emissionSource"]) : new EmissionSource();
            this.report = _data["report"] ? Report.fromJS(_data["report"]) : new Report();
            this.hiredCategory = _data["hiredCategory"] ? EmissionCategory.fromJS(_data["hiredCategory"]) : new EmissionCategory();
            this.rentedCategory = _data["rentedCategory"] ? EmissionCategory.fromJS(_data["rentedCategory"]) : new EmissionCategory();
            this.ownCategory = _data["ownCategory"] ? EmissionCategory.fromJS(_data["ownCategory"]) : new EmissionCategory();
            this.noneCategory = _data["noneCategory"] ? EmissionCategory.fromJS(_data["noneCategory"]) : new EmissionCategory();
        }
    }

    static fromJS(data: any): EsDatasource {
        data = typeof data === 'object' ? data : {};
        let result = new EsDatasource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["hiredDataSource"] = this.hiredDataSource;
        data["rentedDataSource"] = this.rentedDataSource;
        data["ownDataSource"] = this.ownDataSource;
        data["noneDataSource"] = this.noneDataSource;
        data["emissionSource"] = this.emissionSource ? this.emissionSource.toJSON() : <any>undefined;
        data["report"] = this.report ? this.report.toJSON() : <any>undefined;
        data["hiredCategory"] = this.hiredCategory ? this.hiredCategory.toJSON() : <any>undefined;
        data["rentedCategory"] = this.rentedCategory ? this.rentedCategory.toJSON() : <any>undefined;
        data["ownCategory"] = this.ownCategory ? this.ownCategory.toJSON() : <any>undefined;
        data["noneCategory"] = this.noneCategory ? this.noneCategory.toJSON() : <any>undefined;
        return data;
    }

    clone(): EsDatasource {
        const json = this.toJSON();
        let result = new EsDatasource();
        result.init(json);
        return result;
    }
}

export interface IEsDatasource {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    hiredDataSource: string;
    rentedDataSource: string;
    ownDataSource: string;
    noneDataSource: string;
    emissionSource: EmissionSource;
    report: Report;
    hiredCategory: EmissionCategory;
    rentedCategory: EmissionCategory;
    ownCategory: EmissionCategory;
    noneCategory: EmissionCategory;
}

export class CreateManyEsDatasourceDto implements ICreateManyEsDatasourceDto {
    bulk: EsDatasource[];

    constructor(data?: ICreateManyEsDatasourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(EsDatasource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyEsDatasourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyEsDatasourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyEsDatasourceDto {
        const json = this.toJSON();
        let result = new CreateManyEsDatasourceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyEsDatasourceDto {
    bulk: EsDatasource[];
}

export class GetManyEsExcludeReasonResponseDto implements IGetManyEsExcludeReasonResponseDto {
    data: EsExcludeReason[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyEsExcludeReasonResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(EsExcludeReason.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyEsExcludeReasonResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyEsExcludeReasonResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyEsExcludeReasonResponseDto {
        const json = this.toJSON();
        let result = new GetManyEsExcludeReasonResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyEsExcludeReasonResponseDto {
    data: EsExcludeReason[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class EsExcludeReason implements IEsExcludeReason {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    reason: string;
    emissionSource: EmissionSource;
    report: Report;

    constructor(data?: IEsExcludeReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.emissionSource = new EmissionSource();
            this.report = new Report();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.reason = _data["reason"];
            this.emissionSource = _data["emissionSource"] ? EmissionSource.fromJS(_data["emissionSource"]) : new EmissionSource();
            this.report = _data["report"] ? Report.fromJS(_data["report"]) : new Report();
        }
    }

    static fromJS(data: any): EsExcludeReason {
        data = typeof data === 'object' ? data : {};
        let result = new EsExcludeReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["reason"] = this.reason;
        data["emissionSource"] = this.emissionSource ? this.emissionSource.toJSON() : <any>undefined;
        data["report"] = this.report ? this.report.toJSON() : <any>undefined;
        return data;
    }

    clone(): EsExcludeReason {
        const json = this.toJSON();
        let result = new EsExcludeReason();
        result.init(json);
        return result;
    }
}

export interface IEsExcludeReason {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    reason: string;
    emissionSource: EmissionSource;
    report: Report;
}

export class CreateManyEsExcludeReasonDto implements ICreateManyEsExcludeReasonDto {
    bulk: EsExcludeReason[];

    constructor(data?: ICreateManyEsExcludeReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(EsExcludeReason.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyEsExcludeReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyEsExcludeReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyEsExcludeReasonDto {
        const json = this.toJSON();
        let result = new CreateManyEsExcludeReasonDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyEsExcludeReasonDto {
    bulk: EsExcludeReason[];
}

export class CreateManyEmissionCategoryDto implements ICreateManyEmissionCategoryDto {
    bulk: EmissionCategory[];

    constructor(data?: ICreateManyEmissionCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(EmissionCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyEmissionCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyEmissionCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyEmissionCategoryDto {
        const json = this.toJSON();
        let result = new CreateManyEmissionCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyEmissionCategoryDto {
    bulk: EmissionCategory[];
}

export class GetManyTNDLossActivityDataResponseDto implements IGetManyTNDLossActivityDataResponseDto {
    data: TNDLossActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyTNDLossActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(TNDLossActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyTNDLossActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyTNDLossActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyTNDLossActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyTNDLossActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyTNDLossActivityDataResponseDto {
    data: TNDLossActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class TNDLossActivityData implements ITNDLossActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    meterNo: string;
    month: number;
    year: number;
    consumption: number;
    consumption_unit: string;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: TNDLossActivityDataActivityDataStatus;

    constructor(data?: ITNDLossActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.meterNo = _data["meterNo"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.consumption = _data["consumption"];
            this.consumption_unit = _data["consumption_unit"];
            this.emission = _data["emission"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): TNDLossActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new TNDLossActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["meterNo"] = this.meterNo;
        data["month"] = this.month;
        data["year"] = this.year;
        data["consumption"] = this.consumption;
        data["consumption_unit"] = this.consumption_unit;
        data["emission"] = this.emission;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): TNDLossActivityData {
        const json = this.toJSON();
        let result = new TNDLossActivityData();
        result.init(json);
        return result;
    }
}

export interface ITNDLossActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    meterNo: string;
    month: number;
    year: number;
    consumption: number;
    consumption_unit: string;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: TNDLossActivityDataActivityDataStatus;
}

export class CreateManyTNDLossActivityDataDto implements ICreateManyTNDLossActivityDataDto {
    bulk: TNDLossActivityData[];

    constructor(data?: ICreateManyTNDLossActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(TNDLossActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyTNDLossActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyTNDLossActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyTNDLossActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyTNDLossActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyTNDLossActivityDataDto {
    bulk: TNDLossActivityData[];
}

export class GetManyGeneratorActivityDataResponseDto implements IGetManyGeneratorActivityDataResponseDto {
    data: GeneratorActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyGeneratorActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(GeneratorActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyGeneratorActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyGeneratorActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyGeneratorActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyGeneratorActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyGeneratorActivityDataResponseDto {
    data: GeneratorActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GeneratorActivityData implements IGeneratorActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    fc: number;
    fc_unit: string;
    fuelType: string;
    generatorNumber: string;
    emission: number;
    nzType: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: GeneratorActivityDataActivityDataStatus;

    constructor(data?: IGeneratorActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.fc = _data["fc"];
            this.fc_unit = _data["fc_unit"];
            this.fuelType = _data["fuelType"];
            this.generatorNumber = _data["generatorNumber"];
            this.emission = _data["emission"];
            this.nzType = _data["nzType"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): GeneratorActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratorActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["fc"] = this.fc;
        data["fc_unit"] = this.fc_unit;
        data["fuelType"] = this.fuelType;
        data["generatorNumber"] = this.generatorNumber;
        data["emission"] = this.emission;
        data["nzType"] = this.nzType;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): GeneratorActivityData {
        const json = this.toJSON();
        let result = new GeneratorActivityData();
        result.init(json);
        return result;
    }
}

export interface IGeneratorActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    fc: number;
    fc_unit: string;
    fuelType: string;
    generatorNumber: string;
    emission: number;
    nzType: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: GeneratorActivityDataActivityDataStatus;
}

export class CreateManyGeneratorActivityDataDto implements ICreateManyGeneratorActivityDataDto {
    bulk: GeneratorActivityData[];

    constructor(data?: ICreateManyGeneratorActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(GeneratorActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyGeneratorActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyGeneratorActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyGeneratorActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyGeneratorActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyGeneratorActivityDataDto {
    bulk: GeneratorActivityData[];
}

export class GetManyFireExtinguisherActivityDataResponseDto implements IGetManyFireExtinguisherActivityDataResponseDto {
    data: FireExtinguisherActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFireExtinguisherActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FireExtinguisherActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFireExtinguisherActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFireExtinguisherActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFireExtinguisherActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyFireExtinguisherActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFireExtinguisherActivityDataResponseDto {
    data: FireExtinguisherActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class FireExtinguisherActivityData implements IFireExtinguisherActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    fireExtinguisherType: string;
    suppressionType: string;
    noOfTanks: number;
    weightPerTank: number;
    weightPerTank_unit: string;
    month: number;
    year: number;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FireExtinguisherActivityDataActivityDataStatus;

    constructor(data?: IFireExtinguisherActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.fireExtinguisherType = _data["fireExtinguisherType"];
            this.suppressionType = _data["suppressionType"];
            this.noOfTanks = _data["noOfTanks"];
            this.weightPerTank = _data["weightPerTank"];
            this.weightPerTank_unit = _data["weightPerTank_unit"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.emission = _data["emission"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): FireExtinguisherActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new FireExtinguisherActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["fireExtinguisherType"] = this.fireExtinguisherType;
        data["suppressionType"] = this.suppressionType;
        data["noOfTanks"] = this.noOfTanks;
        data["weightPerTank"] = this.weightPerTank;
        data["weightPerTank_unit"] = this.weightPerTank_unit;
        data["month"] = this.month;
        data["year"] = this.year;
        data["emission"] = this.emission;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): FireExtinguisherActivityData {
        const json = this.toJSON();
        let result = new FireExtinguisherActivityData();
        result.init(json);
        return result;
    }
}

export interface IFireExtinguisherActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    fireExtinguisherType: string;
    suppressionType: string;
    noOfTanks: number;
    weightPerTank: number;
    weightPerTank_unit: string;
    month: number;
    year: number;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FireExtinguisherActivityDataActivityDataStatus;
}

export class CreateManyFireExtinguisherActivityDataDto implements ICreateManyFireExtinguisherActivityDataDto {
    bulk: FireExtinguisherActivityData[];

    constructor(data?: ICreateManyFireExtinguisherActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FireExtinguisherActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFireExtinguisherActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFireExtinguisherActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFireExtinguisherActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyFireExtinguisherActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFireExtinguisherActivityDataDto {
    bulk: FireExtinguisherActivityData[];
}

export class GetManyRefrigerantActivityDataResponseDto implements IGetManyRefrigerantActivityDataResponseDto {
    data: RefrigerantActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyRefrigerantActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(RefrigerantActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyRefrigerantActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyRefrigerantActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyRefrigerantActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyRefrigerantActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyRefrigerantActivityDataResponseDto {
    data: RefrigerantActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class RefrigerantActivityData implements IRefrigerantActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    w_RG: number;
    w_RG_unit: string;
    gWP_RG: string;
    e_RL: number;
    month: number;
    activityType: string;
    assembly_Lf: number;
    annual_lR: number;
    time_R: number;
    p_capacity: number;
    p_r_recover: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: RefrigerantActivityDataActivityDataStatus;

    constructor(data?: IRefrigerantActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.w_RG = _data["w_RG"];
            this.w_RG_unit = _data["w_RG_unit"];
            this.gWP_RG = _data["gWP_RG"];
            this.e_RL = _data["e_RL"];
            this.month = _data["month"];
            this.activityType = _data["activityType"];
            this.assembly_Lf = _data["assembly_Lf"];
            this.annual_lR = _data["annual_lR"];
            this.time_R = _data["time_R"];
            this.p_capacity = _data["p_capacity"];
            this.p_r_recover = _data["p_r_recover"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): RefrigerantActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new RefrigerantActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["w_RG"] = this.w_RG;
        data["w_RG_unit"] = this.w_RG_unit;
        data["gWP_RG"] = this.gWP_RG;
        data["e_RL"] = this.e_RL;
        data["month"] = this.month;
        data["activityType"] = this.activityType;
        data["assembly_Lf"] = this.assembly_Lf;
        data["annual_lR"] = this.annual_lR;
        data["time_R"] = this.time_R;
        data["p_capacity"] = this.p_capacity;
        data["p_r_recover"] = this.p_r_recover;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): RefrigerantActivityData {
        const json = this.toJSON();
        let result = new RefrigerantActivityData();
        result.init(json);
        return result;
    }
}

export interface IRefrigerantActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    w_RG: number;
    w_RG_unit: string;
    gWP_RG: string;
    e_RL: number;
    month: number;
    activityType: string;
    assembly_Lf: number;
    annual_lR: number;
    time_R: number;
    p_capacity: number;
    p_r_recover: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: RefrigerantActivityDataActivityDataStatus;
}

export class CreateManyRefrigerantActivityDataDto implements ICreateManyRefrigerantActivityDataDto {
    bulk: RefrigerantActivityData[];

    constructor(data?: ICreateManyRefrigerantActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(RefrigerantActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyRefrigerantActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyRefrigerantActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyRefrigerantActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyRefrigerantActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyRefrigerantActivityDataDto {
    bulk: RefrigerantActivityData[];
}

export class GetManyWeldingEsActivityDataResponseDto implements IGetManyWeldingEsActivityDataResponseDto {
    data: WeldingEsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyWeldingEsActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(WeldingEsActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyWeldingEsActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyWeldingEsActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyWeldingEsActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyWeldingEsActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyWeldingEsActivityDataResponseDto {
    data: WeldingEsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class WeldingEsActivityData implements IWeldingEsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    ac: number;
    ac_unit: string;
    lc: number;
    lc_unit: string;
    month: number;
    emission: string;
    acetylene: number;
    liquidCo2: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WeldingEsActivityDataActivityDataStatus;

    constructor(data?: IWeldingEsActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.ac = _data["ac"];
            this.ac_unit = _data["ac_unit"];
            this.lc = _data["lc"];
            this.lc_unit = _data["lc_unit"];
            this.month = _data["month"];
            this.emission = _data["emission"];
            this.acetylene = _data["acetylene"];
            this.liquidCo2 = _data["liquidCo2"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): WeldingEsActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new WeldingEsActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["ac"] = this.ac;
        data["ac_unit"] = this.ac_unit;
        data["lc"] = this.lc;
        data["lc_unit"] = this.lc_unit;
        data["month"] = this.month;
        data["emission"] = this.emission;
        data["acetylene"] = this.acetylene;
        data["liquidCo2"] = this.liquidCo2;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): WeldingEsActivityData {
        const json = this.toJSON();
        let result = new WeldingEsActivityData();
        result.init(json);
        return result;
    }
}

export interface IWeldingEsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    ac: number;
    ac_unit: string;
    lc: number;
    lc_unit: string;
    month: number;
    emission: string;
    acetylene: number;
    liquidCo2: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WeldingEsActivityDataActivityDataStatus;
}

export class CreateManyWeldingEsActivityDataDto implements ICreateManyWeldingEsActivityDataDto {
    bulk: WeldingEsActivityData[];

    constructor(data?: ICreateManyWeldingEsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(WeldingEsActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyWeldingEsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyWeldingEsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyWeldingEsActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyWeldingEsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyWeldingEsActivityDataDto {
    bulk: WeldingEsActivityData[];
}

export class GetManyForkliftsActivityDataResponseDto implements IGetManyForkliftsActivityDataResponseDto {
    data: ForkliftsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyForkliftsActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ForkliftsActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyForkliftsActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyForkliftsActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyForkliftsActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyForkliftsActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyForkliftsActivityDataResponseDto {
    data: ForkliftsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ForkliftsActivityData implements IForkliftsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    consumption: number;
    consumption_unit: string;
    fuelType: string;
    emission: number;
    month: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: ForkliftsActivityDataActivityDataStatus;

    constructor(data?: IForkliftsActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.consumption = _data["consumption"];
            this.consumption_unit = _data["consumption_unit"];
            this.fuelType = _data["fuelType"];
            this.emission = _data["emission"];
            this.month = _data["month"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): ForkliftsActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new ForkliftsActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["consumption"] = this.consumption;
        data["consumption_unit"] = this.consumption_unit;
        data["fuelType"] = this.fuelType;
        data["emission"] = this.emission;
        data["month"] = this.month;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): ForkliftsActivityData {
        const json = this.toJSON();
        let result = new ForkliftsActivityData();
        result.init(json);
        return result;
    }
}

export interface IForkliftsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    consumption: number;
    consumption_unit: string;
    fuelType: string;
    emission: number;
    month: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: ForkliftsActivityDataActivityDataStatus;
}

export class CreateManyForkliftsActivityDataDto implements ICreateManyForkliftsActivityDataDto {
    bulk: ForkliftsActivityData[];

    constructor(data?: ICreateManyForkliftsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ForkliftsActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyForkliftsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyForkliftsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyForkliftsActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyForkliftsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyForkliftsActivityDataDto {
    bulk: ForkliftsActivityData[];
}

export class GetManyBoilerActivityDataResponseDto implements IGetManyBoilerActivityDataResponseDto {
    data: BoilerActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyBoilerActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(BoilerActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyBoilerActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyBoilerActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyBoilerActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyBoilerActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyBoilerActivityDataResponseDto {
    data: BoilerActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class BoilerActivityData implements IBoilerActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    purpose: string;
    fuelType: string;
    fuel: string;
    month: number;
    year: number;
    consumption: number;
    consumption_unit: string;
    emission: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: BoilerActivityDataActivityDataStatus;

    constructor(data?: IBoilerActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.purpose = _data["purpose"];
            this.fuelType = _data["fuelType"];
            this.fuel = _data["fuel"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.consumption = _data["consumption"];
            this.consumption_unit = _data["consumption_unit"];
            this.emission = _data["emission"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): BoilerActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new BoilerActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["purpose"] = this.purpose;
        data["fuelType"] = this.fuelType;
        data["fuel"] = this.fuel;
        data["month"] = this.month;
        data["year"] = this.year;
        data["consumption"] = this.consumption;
        data["consumption_unit"] = this.consumption_unit;
        data["emission"] = this.emission;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): BoilerActivityData {
        const json = this.toJSON();
        let result = new BoilerActivityData();
        result.init(json);
        return result;
    }
}

export interface IBoilerActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    purpose: string;
    fuelType: string;
    fuel: string;
    month: number;
    year: number;
    consumption: number;
    consumption_unit: string;
    emission: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: BoilerActivityDataActivityDataStatus;
}

export class CreateManyBoilerActivityDataDto implements ICreateManyBoilerActivityDataDto {
    bulk: BoilerActivityData[];

    constructor(data?: ICreateManyBoilerActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(BoilerActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyBoilerActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyBoilerActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyBoilerActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyBoilerActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyBoilerActivityDataDto {
    bulk: BoilerActivityData[];
}

export class GetManyWasteWaterTreatmentActivityDataResponseDto implements IGetManyWasteWaterTreatmentActivityDataResponseDto {
    data: WasteWaterTreatmentActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyWasteWaterTreatmentActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(WasteWaterTreatmentActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyWasteWaterTreatmentActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyWasteWaterTreatmentActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyWasteWaterTreatmentActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyWasteWaterTreatmentActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyWasteWaterTreatmentActivityDataResponseDto {
    data: WasteWaterTreatmentActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class WasteWaterTreatmentActivityData implements IWasteWaterTreatmentActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    wasteGenerated: number;
    wasteGenerated_unit: string;
    tip: number;
    tip_unit: string;
    cod: number;
    cod_unit: string;
    anaerobicDeepLagoon: string;
    sludgeRemoved: number;
    sludgeRemoved_unit: string;
    recoveredCh4: number;
    recoveredCh4_unit: string;
    month: number;
    emission: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WasteWaterTreatmentActivityDataActivityDataStatus;

    constructor(data?: IWasteWaterTreatmentActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.wasteGenerated = _data["wasteGenerated"];
            this.wasteGenerated_unit = _data["wasteGenerated_unit"];
            this.tip = _data["tip"];
            this.tip_unit = _data["tip_unit"];
            this.cod = _data["cod"];
            this.cod_unit = _data["cod_unit"];
            this.anaerobicDeepLagoon = _data["anaerobicDeepLagoon"];
            this.sludgeRemoved = _data["sludgeRemoved"];
            this.sludgeRemoved_unit = _data["sludgeRemoved_unit"];
            this.recoveredCh4 = _data["recoveredCh4"];
            this.recoveredCh4_unit = _data["recoveredCh4_unit"];
            this.month = _data["month"];
            this.emission = _data["emission"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): WasteWaterTreatmentActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new WasteWaterTreatmentActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["wasteGenerated"] = this.wasteGenerated;
        data["wasteGenerated_unit"] = this.wasteGenerated_unit;
        data["tip"] = this.tip;
        data["tip_unit"] = this.tip_unit;
        data["cod"] = this.cod;
        data["cod_unit"] = this.cod_unit;
        data["anaerobicDeepLagoon"] = this.anaerobicDeepLagoon;
        data["sludgeRemoved"] = this.sludgeRemoved;
        data["sludgeRemoved_unit"] = this.sludgeRemoved_unit;
        data["recoveredCh4"] = this.recoveredCh4;
        data["recoveredCh4_unit"] = this.recoveredCh4_unit;
        data["month"] = this.month;
        data["emission"] = this.emission;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): WasteWaterTreatmentActivityData {
        const json = this.toJSON();
        let result = new WasteWaterTreatmentActivityData();
        result.init(json);
        return result;
    }
}

export interface IWasteWaterTreatmentActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    wasteGenerated: number;
    wasteGenerated_unit: string;
    tip: number;
    tip_unit: string;
    cod: number;
    cod_unit: string;
    anaerobicDeepLagoon: string;
    sludgeRemoved: number;
    sludgeRemoved_unit: string;
    recoveredCh4: number;
    recoveredCh4_unit: string;
    month: number;
    emission: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WasteWaterTreatmentActivityDataActivityDataStatus;
}

export class CreateManyWasteWaterTreatmentActivityDataDto implements ICreateManyWasteWaterTreatmentActivityDataDto {
    bulk: WasteWaterTreatmentActivityData[];

    constructor(data?: ICreateManyWasteWaterTreatmentActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(WasteWaterTreatmentActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyWasteWaterTreatmentActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyWasteWaterTreatmentActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyWasteWaterTreatmentActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyWasteWaterTreatmentActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyWasteWaterTreatmentActivityDataDto {
    bulk: WasteWaterTreatmentActivityData[];
}

export class GetManyMunicipalWaterActivityDataResponseDto implements IGetManyMunicipalWaterActivityDataResponseDto {
    data: MunicipalWaterActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyMunicipalWaterActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(MunicipalWaterActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyMunicipalWaterActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyMunicipalWaterActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyMunicipalWaterActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyMunicipalWaterActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyMunicipalWaterActivityDataResponseDto {
    data: MunicipalWaterActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class MunicipalWaterActivityData implements IMunicipalWaterActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    consumption_unit: string;
    consumption: number;
    meterNo: string;
    category: string;
    month: number;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: MunicipalWaterActivityDataActivityDataStatus;

    constructor(data?: IMunicipalWaterActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.consumption_unit = _data["consumption_unit"];
            this.consumption = _data["consumption"];
            this.meterNo = _data["meterNo"];
            this.category = _data["category"];
            this.month = _data["month"];
            this.emission = _data["emission"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): MunicipalWaterActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new MunicipalWaterActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["consumption_unit"] = this.consumption_unit;
        data["consumption"] = this.consumption;
        data["meterNo"] = this.meterNo;
        data["category"] = this.category;
        data["month"] = this.month;
        data["emission"] = this.emission;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): MunicipalWaterActivityData {
        const json = this.toJSON();
        let result = new MunicipalWaterActivityData();
        result.init(json);
        return result;
    }
}

export interface IMunicipalWaterActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    consumption_unit: string;
    consumption: number;
    meterNo: string;
    category: string;
    month: number;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: MunicipalWaterActivityDataActivityDataStatus;
}

export class CreateManyMunicipalWaterActivityDataDto implements ICreateManyMunicipalWaterActivityDataDto {
    bulk: MunicipalWaterActivityData[];

    constructor(data?: ICreateManyMunicipalWaterActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(MunicipalWaterActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyMunicipalWaterActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyMunicipalWaterActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyMunicipalWaterActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyMunicipalWaterActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyMunicipalWaterActivityDataDto {
    bulk: MunicipalWaterActivityData[];
}

export class GetManyEvidenceRequestResponseDto implements IGetManyEvidenceRequestResponseDto {
    data: EvidenceRequest[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyEvidenceRequestResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(EvidenceRequest.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyEvidenceRequestResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyEvidenceRequestResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyEvidenceRequestResponseDto {
        const json = this.toJSON();
        let result = new GetManyEvidenceRequestResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyEvidenceRequestResponseDto {
    data: EvidenceRequest[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyParameterResponseDto implements IGetManyParameterResponseDto {
    data: Parameter[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyParameterResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Parameter.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyParameterResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyParameterResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyParameterResponseDto {
        const json = this.toJSON();
        let result = new GetManyParameterResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyParameterResponseDto {
    data: Parameter[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Parameter implements IParameter {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    isConstant: boolean;
    source: EmissionSource;

    constructor(data?: IParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.source = new EmissionSource();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.isConstant = _data["isConstant"];
            this.source = _data["source"] ? EmissionSource.fromJS(_data["source"]) : new EmissionSource();
        }
    }

    static fromJS(data: any): Parameter {
        data = typeof data === 'object' ? data : {};
        let result = new Parameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isConstant"] = this.isConstant;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        return data;
    }

    clone(): Parameter {
        const json = this.toJSON();
        let result = new Parameter();
        result.init(json);
        return result;
    }
}

export interface IParameter {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    isConstant: boolean;
    source: EmissionSource;
}

export class EvidenceRequest implements IEvidenceRequest {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    activityDataId: number;
    evidenceStatus: EvidenceRequestEvidenceStatus;
    comment: string;
    esCode: EvidenceRequestEsCode;
    month: number;
    parameter: Parameter;
    requestFrom: User;
    verifier: User;
    project: Project;

    constructor(data?: IEvidenceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parameter = new Parameter();
            this.requestFrom = new User();
            this.verifier = new User();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.activityDataId = _data["activityDataId"];
            this.evidenceStatus = _data["evidenceStatus"];
            this.comment = _data["comment"];
            this.esCode = _data["esCode"];
            this.month = _data["month"];
            this.parameter = _data["parameter"] ? Parameter.fromJS(_data["parameter"]) : new Parameter();
            this.requestFrom = _data["requestFrom"] ? User.fromJS(_data["requestFrom"]) : new User();
            this.verifier = _data["verifier"] ? User.fromJS(_data["verifier"]) : new User();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
        }
    }

    static fromJS(data: any): EvidenceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EvidenceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["activityDataId"] = this.activityDataId;
        data["evidenceStatus"] = this.evidenceStatus;
        data["comment"] = this.comment;
        data["esCode"] = this.esCode;
        data["month"] = this.month;
        data["parameter"] = this.parameter ? this.parameter.toJSON() : <any>undefined;
        data["requestFrom"] = this.requestFrom ? this.requestFrom.toJSON() : <any>undefined;
        data["verifier"] = this.verifier ? this.verifier.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data;
    }

    clone(): EvidenceRequest {
        const json = this.toJSON();
        let result = new EvidenceRequest();
        result.init(json);
        return result;
    }
}

export interface IEvidenceRequest {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    activityDataId: number;
    evidenceStatus: EvidenceRequestEvidenceStatus;
    comment: string;
    esCode: EvidenceRequestEsCode;
    month: number;
    parameter: Parameter;
    requestFrom: User;
    verifier: User;
    project: Project;
}

export class EvidenceRequestDto implements IEvidenceRequestDto {
    req: EvidenceRequest;
    projectId: number;
    activityDataId: number;
    code: string;

    constructor(data?: IEvidenceRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.req = new EvidenceRequest();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.req = _data["req"] ? EvidenceRequest.fromJS(_data["req"]) : new EvidenceRequest();
            this.projectId = _data["projectId"];
            this.activityDataId = _data["activityDataId"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): EvidenceRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvidenceRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["req"] = this.req ? this.req.toJSON() : <any>undefined;
        data["projectId"] = this.projectId;
        data["activityDataId"] = this.activityDataId;
        data["code"] = this.code;
        return data;
    }

    clone(): EvidenceRequestDto {
        const json = this.toJSON();
        let result = new EvidenceRequestDto();
        result.init(json);
        return result;
    }
}

export interface IEvidenceRequestDto {
    req: EvidenceRequest;
    projectId: number;
    activityDataId: number;
    code: string;
}

export class GetRequestsDto implements IGetRequestsDto {
    parameterId: number;
    month: number;
    activityDataId: number;
    esCode: GetRequestsDtoEsCode;
    status: GetRequestsDtoStatus;

    constructor(data?: IGetRequestsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parameterId = _data["parameterId"];
            this.month = _data["month"];
            this.activityDataId = _data["activityDataId"];
            this.esCode = _data["esCode"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetRequestsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRequestsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parameterId"] = this.parameterId;
        data["month"] = this.month;
        data["activityDataId"] = this.activityDataId;
        data["esCode"] = this.esCode;
        data["status"] = this.status;
        return data;
    }

    clone(): GetRequestsDto {
        const json = this.toJSON();
        let result = new GetRequestsDto();
        result.init(json);
        return result;
    }
}

export interface IGetRequestsDto {
    parameterId: number;
    month: number;
    activityDataId: number;
    esCode: GetRequestsDtoEsCode;
    status: GetRequestsDtoStatus;
}

export class ResponseDto implements IResponseDto {
    requests: EvidenceRequest[];
    isRequested: boolean;
    isApproved: boolean;
    isRejected: boolean;
    isUploaded: boolean;
    isReturned: boolean;

    constructor(data?: IResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.requests = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests.push(EvidenceRequest.fromJS(item));
            }
            this.isRequested = _data["isRequested"];
            this.isApproved = _data["isApproved"];
            this.isRejected = _data["isRejected"];
            this.isUploaded = _data["isUploaded"];
            this.isReturned = _data["isReturned"];
        }
    }

    static fromJS(data: any): ResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        data["isRequested"] = this.isRequested;
        data["isApproved"] = this.isApproved;
        data["isRejected"] = this.isRejected;
        data["isUploaded"] = this.isUploaded;
        data["isReturned"] = this.isReturned;
        return data;
    }

    clone(): ResponseDto {
        const json = this.toJSON();
        let result = new ResponseDto();
        result.init(json);
        return result;
    }
}

export interface IResponseDto {
    requests: EvidenceRequest[];
    isRequested: boolean;
    isApproved: boolean;
    isRejected: boolean;
    isUploaded: boolean;
    isReturned: boolean;
}

export class UploadDto implements IUploadDto {
    documentId: number;
    evidenceId: number;
    comment: string;

    constructor(data?: IUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentId = _data["documentId"];
            this.evidenceId = _data["evidenceId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): UploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["evidenceId"] = this.evidenceId;
        data["comment"] = this.comment;
        return data;
    }

    clone(): UploadDto {
        const json = this.toJSON();
        let result = new UploadDto();
        result.init(json);
        return result;
    }
}

export interface IUploadDto {
    documentId: number;
    evidenceId: number;
    comment: string;
}

export class UploadResDto implements IUploadResDto {
    status: boolean;
    message: string;

    constructor(data?: IUploadResDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): UploadResDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadResDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }

    clone(): UploadResDto {
        const json = this.toJSON();
        let result = new UploadResDto();
        result.init(json);
        return result;
    }
}

export interface IUploadResDto {
    status: boolean;
    message: string;
}

export class EnableVerificationReqDto implements IEnableVerificationReqDto {
    esCodes: EsCodes[];
    projectId: number;

    constructor(data?: IEnableVerificationReqDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.esCodes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["esCodes"])) {
                this.esCodes = [] as any;
                for (let item of _data["esCodes"])
                    this.esCodes.push(item);
            }
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): EnableVerificationReqDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnableVerificationReqDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.esCodes)) {
            data["esCodes"] = [];
            for (let item of this.esCodes)
                data["esCodes"].push(item);
        }
        data["projectId"] = this.projectId;
        return data;
    }

    clone(): EnableVerificationReqDto {
        const json = this.toJSON();
        let result = new EnableVerificationReqDto();
        result.init(json);
        return result;
    }
}

export interface IEnableVerificationReqDto {
    esCodes: EsCodes[];
    projectId: number;
}

export class EnableVerificationResDto implements IEnableVerificationResDto {
    status: string;
    isEnables: boolean;
    message: string;

    constructor(data?: IEnableVerificationResDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.isEnables = _data["isEnables"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): EnableVerificationResDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnableVerificationResDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["isEnables"] = this.isEnables;
        data["message"] = this.message;
        return data;
    }

    clone(): EnableVerificationResDto {
        const json = this.toJSON();
        let result = new EnableVerificationResDto();
        result.init(json);
        return result;
    }
}

export interface IEnableVerificationResDto {
    status: string;
    isEnables: boolean;
    message: string;
}

export class CreateManyEvidenceRequestDto implements ICreateManyEvidenceRequestDto {
    bulk: EvidenceRequest[];

    constructor(data?: ICreateManyEvidenceRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(EvidenceRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyEvidenceRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyEvidenceRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyEvidenceRequestDto {
        const json = this.toJSON();
        let result = new CreateManyEvidenceRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyEvidenceRequestDto {
    bulk: EvidenceRequest[];
}

export class GetManyEvidenceDocumentResponseDto implements IGetManyEvidenceDocumentResponseDto {
    data: EvidenceDocument[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyEvidenceDocumentResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(EvidenceDocument.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyEvidenceDocumentResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyEvidenceDocumentResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyEvidenceDocumentResponseDto {
        const json = this.toJSON();
        let result = new GetManyEvidenceDocumentResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyEvidenceDocumentResponseDto {
    data: EvidenceDocument[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class EvidenceDocument implements IEvidenceDocument {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    evidenceRequest: EvidenceRequest;
    document: Documents;
    comment: string;

    constructor(data?: IEvidenceDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.evidenceRequest = new EvidenceRequest();
            this.document = new Documents();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.evidenceRequest = _data["evidenceRequest"] ? EvidenceRequest.fromJS(_data["evidenceRequest"]) : new EvidenceRequest();
            this.document = _data["document"] ? Documents.fromJS(_data["document"]) : new Documents();
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): EvidenceDocument {
        data = typeof data === 'object' ? data : {};
        let result = new EvidenceDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["evidenceRequest"] = this.evidenceRequest ? this.evidenceRequest.toJSON() : <any>undefined;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data;
    }

    clone(): EvidenceDocument {
        const json = this.toJSON();
        let result = new EvidenceDocument();
        result.init(json);
        return result;
    }
}

export interface IEvidenceDocument {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    evidenceRequest: EvidenceRequest;
    document: Documents;
    comment: string;
}

export class CreateManyEvidenceDocumentDto implements ICreateManyEvidenceDocumentDto {
    bulk: EvidenceDocument[];

    constructor(data?: ICreateManyEvidenceDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(EvidenceDocument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyEvidenceDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyEvidenceDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyEvidenceDocumentDto {
        const json = this.toJSON();
        let result = new CreateManyEvidenceDocumentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyEvidenceDocumentDto {
    bulk: EvidenceDocument[];
}

export class GetManyWasteDisposalActivityDataResponseDto implements IGetManyWasteDisposalActivityDataResponseDto {
    data: WasteDisposalActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyWasteDisposalActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(WasteDisposalActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyWasteDisposalActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyWasteDisposalActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyWasteDisposalActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyWasteDisposalActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyWasteDisposalActivityDataResponseDto {
    data: WasteDisposalActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class WasteDisposalActivityData implements IWasteDisposalActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    disposalMethod: string;
    wasteType: string;
    amountDisposed: number;
    amountDisposed_unit: string;
    emission: number;
    month: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WasteDisposalActivityDataActivityDataStatus;

    constructor(data?: IWasteDisposalActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.disposalMethod = _data["disposalMethod"];
            this.wasteType = _data["wasteType"];
            this.amountDisposed = _data["amountDisposed"];
            this.amountDisposed_unit = _data["amountDisposed_unit"];
            this.emission = _data["emission"];
            this.month = _data["month"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): WasteDisposalActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new WasteDisposalActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["disposalMethod"] = this.disposalMethod;
        data["wasteType"] = this.wasteType;
        data["amountDisposed"] = this.amountDisposed;
        data["amountDisposed_unit"] = this.amountDisposed_unit;
        data["emission"] = this.emission;
        data["month"] = this.month;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): WasteDisposalActivityData {
        const json = this.toJSON();
        let result = new WasteDisposalActivityData();
        result.init(json);
        return result;
    }
}

export interface IWasteDisposalActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    disposalMethod: string;
    wasteType: string;
    amountDisposed: number;
    amountDisposed_unit: string;
    emission: number;
    month: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WasteDisposalActivityDataActivityDataStatus;
}

export class CreateManyWasteDisposalActivityDataDto implements ICreateManyWasteDisposalActivityDataDto {
    bulk: WasteDisposalActivityData[];

    constructor(data?: ICreateManyWasteDisposalActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(WasteDisposalActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyWasteDisposalActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyWasteDisposalActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyWasteDisposalActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyWasteDisposalActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyWasteDisposalActivityDataDto {
    bulk: WasteDisposalActivityData[];
}

export class GetManyCookingGasActivityDataResponseDto implements IGetManyCookingGasActivityDataResponseDto {
    data: CookingGasActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyCookingGasActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(CookingGasActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyCookingGasActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyCookingGasActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyCookingGasActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyCookingGasActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyCookingGasActivityDataResponseDto {
    data: CookingGasActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class CookingGasActivityData implements ICookingGasActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    fcn: number;
    fcn_unit: string;
    emission: string;
    emissionSource: string;
    gasType: string;
    month: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: CookingGasActivityDataActivityDataStatus;

    constructor(data?: ICookingGasActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.fcn = _data["fcn"];
            this.fcn_unit = _data["fcn_unit"];
            this.emission = _data["emission"];
            this.emissionSource = _data["emissionSource"];
            this.gasType = _data["gasType"];
            this.month = _data["month"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): CookingGasActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new CookingGasActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["fcn"] = this.fcn;
        data["fcn_unit"] = this.fcn_unit;
        data["emission"] = this.emission;
        data["emissionSource"] = this.emissionSource;
        data["gasType"] = this.gasType;
        data["month"] = this.month;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): CookingGasActivityData {
        const json = this.toJSON();
        let result = new CookingGasActivityData();
        result.init(json);
        return result;
    }
}

export interface ICookingGasActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    fcn: number;
    fcn_unit: string;
    emission: string;
    emissionSource: string;
    gasType: string;
    month: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: CookingGasActivityDataActivityDataStatus;
}

export class CreateManyCookingGasActivityDataDto implements ICreateManyCookingGasActivityDataDto {
    bulk: CookingGasActivityData[];

    constructor(data?: ICreateManyCookingGasActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(CookingGasActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyCookingGasActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyCookingGasActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyCookingGasActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyCookingGasActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyCookingGasActivityDataDto {
    bulk: CookingGasActivityData[];
}

export class GetManyFreightAirActivityDataResponseDto implements IGetManyFreightAirActivityDataResponseDto {
    data: FreightAirActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFreightAirActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FreightAirActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFreightAirActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFreightAirActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFreightAirActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyFreightAirActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFreightAirActivityDataResponseDto {
    data: FreightAirActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyAirPortResponseDto implements IGetManyAirPortResponseDto {
    data: AirPort[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyAirPortResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(AirPort.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyAirPortResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyAirPortResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyAirPortResponseDto {
        const json = this.toJSON();
        let result = new GetManyAirPortResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyAirPortResponseDto {
    data: AirPort[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class AirPort implements IAirPort {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    country: Country;

    constructor(data?: IAirPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.country = new Country();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
        }
    }

    static fromJS(data: any): AirPort {
        data = typeof data === 'object' ? data : {};
        let result = new AirPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }

    clone(): AirPort {
        const json = this.toJSON();
        let result = new AirPort();
        result.init(json);
        return result;
    }
}

export interface IAirPort {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    country: Country;
}

export class FreightAirActivityData implements IFreightAirActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleNo: string;
    method: string;
    domOrInt: string;
    cargoType: string;
    departureCountryOneWay: Country;
    destinationCountryOneWay: Country;
    departureCountryTwoWay: Country;
    destinationCountryTwoWay: Country;
    transist_oneWay_1: AirPort;
    transist_oneWay_2: AirPort;
    transist_oneWay_3: AirPort;
    transist_twoWay_1: AirPort;
    transist_twoWay_2: AirPort;
    transist_twoWay_3: AirPort;
    ownership: string;
    option: string;
    departureAirportOneWay: AirPort;
    destinationAirportOneWay: AirPort;
    departureAirportTwoWay: AirPort;
    destinationAirportTwoWay: AirPort;
    noOfTrips: number;
    distance_unit: string;
    month: number;
    upDistance_unit: string;
    downDistance_unit: string;
    upDistance: number;
    downDistance: number;
    totalDistanceTravelled: number;
    weight: number;
    upWeight: number;
    downWeight: number;
    upWeight_unit: string;
    downWeight_unit: string;
    cost: number;
    upCost: number;
    downCost: number;
    upCostPerKM: number;
    downCostPerKM: number;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightAirActivityDataActivityDataStatus;

    constructor(data?: IFreightAirActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.departureCountryOneWay = new Country();
            this.destinationCountryOneWay = new Country();
            this.departureCountryTwoWay = new Country();
            this.destinationCountryTwoWay = new Country();
            this.transist_oneWay_1 = new AirPort();
            this.transist_oneWay_2 = new AirPort();
            this.transist_oneWay_3 = new AirPort();
            this.transist_twoWay_1 = new AirPort();
            this.transist_twoWay_2 = new AirPort();
            this.transist_twoWay_3 = new AirPort();
            this.departureAirportOneWay = new AirPort();
            this.destinationAirportOneWay = new AirPort();
            this.departureAirportTwoWay = new AirPort();
            this.destinationAirportTwoWay = new AirPort();
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.paidByCompany = _data["paidByCompany"];
            this.vehicleNo = _data["vehicleNo"];
            this.method = _data["method"];
            this.domOrInt = _data["domOrInt"];
            this.cargoType = _data["cargoType"];
            this.departureCountryOneWay = _data["departureCountryOneWay"] ? Country.fromJS(_data["departureCountryOneWay"]) : new Country();
            this.destinationCountryOneWay = _data["destinationCountryOneWay"] ? Country.fromJS(_data["destinationCountryOneWay"]) : new Country();
            this.departureCountryTwoWay = _data["departureCountryTwoWay"] ? Country.fromJS(_data["departureCountryTwoWay"]) : new Country();
            this.destinationCountryTwoWay = _data["destinationCountryTwoWay"] ? Country.fromJS(_data["destinationCountryTwoWay"]) : new Country();
            this.transist_oneWay_1 = _data["transist_oneWay_1"] ? AirPort.fromJS(_data["transist_oneWay_1"]) : new AirPort();
            this.transist_oneWay_2 = _data["transist_oneWay_2"] ? AirPort.fromJS(_data["transist_oneWay_2"]) : new AirPort();
            this.transist_oneWay_3 = _data["transist_oneWay_3"] ? AirPort.fromJS(_data["transist_oneWay_3"]) : new AirPort();
            this.transist_twoWay_1 = _data["transist_twoWay_1"] ? AirPort.fromJS(_data["transist_twoWay_1"]) : new AirPort();
            this.transist_twoWay_2 = _data["transist_twoWay_2"] ? AirPort.fromJS(_data["transist_twoWay_2"]) : new AirPort();
            this.transist_twoWay_3 = _data["transist_twoWay_3"] ? AirPort.fromJS(_data["transist_twoWay_3"]) : new AirPort();
            this.ownership = _data["ownership"];
            this.option = _data["option"];
            this.departureAirportOneWay = _data["departureAirportOneWay"] ? AirPort.fromJS(_data["departureAirportOneWay"]) : new AirPort();
            this.destinationAirportOneWay = _data["destinationAirportOneWay"] ? AirPort.fromJS(_data["destinationAirportOneWay"]) : new AirPort();
            this.departureAirportTwoWay = _data["departureAirportTwoWay"] ? AirPort.fromJS(_data["departureAirportTwoWay"]) : new AirPort();
            this.destinationAirportTwoWay = _data["destinationAirportTwoWay"] ? AirPort.fromJS(_data["destinationAirportTwoWay"]) : new AirPort();
            this.noOfTrips = _data["noOfTrips"];
            this.distance_unit = _data["distance_unit"];
            this.month = _data["month"];
            this.upDistance_unit = _data["upDistance_unit"];
            this.downDistance_unit = _data["downDistance_unit"];
            this.upDistance = _data["upDistance"];
            this.downDistance = _data["downDistance"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.weight = _data["weight"];
            this.upWeight = _data["upWeight"];
            this.downWeight = _data["downWeight"];
            this.upWeight_unit = _data["upWeight_unit"];
            this.downWeight_unit = _data["downWeight_unit"];
            this.cost = _data["cost"];
            this.upCost = _data["upCost"];
            this.downCost = _data["downCost"];
            this.upCostPerKM = _data["upCostPerKM"];
            this.downCostPerKM = _data["downCostPerKM"];
            this.emission = _data["emission"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): FreightAirActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new FreightAirActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["paidByCompany"] = this.paidByCompany;
        data["vehicleNo"] = this.vehicleNo;
        data["method"] = this.method;
        data["domOrInt"] = this.domOrInt;
        data["cargoType"] = this.cargoType;
        data["departureCountryOneWay"] = this.departureCountryOneWay ? this.departureCountryOneWay.toJSON() : <any>undefined;
        data["destinationCountryOneWay"] = this.destinationCountryOneWay ? this.destinationCountryOneWay.toJSON() : <any>undefined;
        data["departureCountryTwoWay"] = this.departureCountryTwoWay ? this.departureCountryTwoWay.toJSON() : <any>undefined;
        data["destinationCountryTwoWay"] = this.destinationCountryTwoWay ? this.destinationCountryTwoWay.toJSON() : <any>undefined;
        data["transist_oneWay_1"] = this.transist_oneWay_1 ? this.transist_oneWay_1.toJSON() : <any>undefined;
        data["transist_oneWay_2"] = this.transist_oneWay_2 ? this.transist_oneWay_2.toJSON() : <any>undefined;
        data["transist_oneWay_3"] = this.transist_oneWay_3 ? this.transist_oneWay_3.toJSON() : <any>undefined;
        data["transist_twoWay_1"] = this.transist_twoWay_1 ? this.transist_twoWay_1.toJSON() : <any>undefined;
        data["transist_twoWay_2"] = this.transist_twoWay_2 ? this.transist_twoWay_2.toJSON() : <any>undefined;
        data["transist_twoWay_3"] = this.transist_twoWay_3 ? this.transist_twoWay_3.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["option"] = this.option;
        data["departureAirportOneWay"] = this.departureAirportOneWay ? this.departureAirportOneWay.toJSON() : <any>undefined;
        data["destinationAirportOneWay"] = this.destinationAirportOneWay ? this.destinationAirportOneWay.toJSON() : <any>undefined;
        data["departureAirportTwoWay"] = this.departureAirportTwoWay ? this.departureAirportTwoWay.toJSON() : <any>undefined;
        data["destinationAirportTwoWay"] = this.destinationAirportTwoWay ? this.destinationAirportTwoWay.toJSON() : <any>undefined;
        data["noOfTrips"] = this.noOfTrips;
        data["distance_unit"] = this.distance_unit;
        data["month"] = this.month;
        data["upDistance_unit"] = this.upDistance_unit;
        data["downDistance_unit"] = this.downDistance_unit;
        data["upDistance"] = this.upDistance;
        data["downDistance"] = this.downDistance;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["weight"] = this.weight;
        data["upWeight"] = this.upWeight;
        data["downWeight"] = this.downWeight;
        data["upWeight_unit"] = this.upWeight_unit;
        data["downWeight_unit"] = this.downWeight_unit;
        data["cost"] = this.cost;
        data["upCost"] = this.upCost;
        data["downCost"] = this.downCost;
        data["upCostPerKM"] = this.upCostPerKM;
        data["downCostPerKM"] = this.downCostPerKM;
        data["emission"] = this.emission;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): FreightAirActivityData {
        const json = this.toJSON();
        let result = new FreightAirActivityData();
        result.init(json);
        return result;
    }
}

export interface IFreightAirActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleNo: string;
    method: string;
    domOrInt: string;
    cargoType: string;
    departureCountryOneWay: Country;
    destinationCountryOneWay: Country;
    departureCountryTwoWay: Country;
    destinationCountryTwoWay: Country;
    transist_oneWay_1: AirPort;
    transist_oneWay_2: AirPort;
    transist_oneWay_3: AirPort;
    transist_twoWay_1: AirPort;
    transist_twoWay_2: AirPort;
    transist_twoWay_3: AirPort;
    ownership: string;
    option: string;
    departureAirportOneWay: AirPort;
    destinationAirportOneWay: AirPort;
    departureAirportTwoWay: AirPort;
    destinationAirportTwoWay: AirPort;
    noOfTrips: number;
    distance_unit: string;
    month: number;
    upDistance_unit: string;
    downDistance_unit: string;
    upDistance: number;
    downDistance: number;
    totalDistanceTravelled: number;
    weight: number;
    upWeight: number;
    downWeight: number;
    upWeight_unit: string;
    downWeight_unit: string;
    cost: number;
    upCost: number;
    downCost: number;
    upCostPerKM: number;
    downCostPerKM: number;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightAirActivityDataActivityDataStatus;
}

export class CreateManyFreightAirActivityDataDto implements ICreateManyFreightAirActivityDataDto {
    bulk: FreightAirActivityData[];

    constructor(data?: ICreateManyFreightAirActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FreightAirActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFreightAirActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFreightAirActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFreightAirActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyFreightAirActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFreightAirActivityDataDto {
    bulk: FreightAirActivityData[];
}

export class GetManyFreightRailActivityDataResponseDto implements IGetManyFreightRailActivityDataResponseDto {
    data: FreightRailActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFreightRailActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FreightRailActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFreightRailActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFreightRailActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFreightRailActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyFreightRailActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFreightRailActivityDataResponseDto {
    data: FreightRailActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyRailPortResponseDto implements IGetManyRailPortResponseDto {
    data: RailPort[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyRailPortResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(RailPort.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyRailPortResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyRailPortResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyRailPortResponseDto {
        const json = this.toJSON();
        let result = new GetManyRailPortResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyRailPortResponseDto {
    data: RailPort[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class RailPort implements IRailPort {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    country: Country;

    constructor(data?: IRailPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.country = new Country();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
        }
    }

    static fromJS(data: any): RailPort {
        data = typeof data === 'object' ? data : {};
        let result = new RailPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }

    clone(): RailPort {
        const json = this.toJSON();
        let result = new RailPort();
        result.init(json);
        return result;
    }
}

export interface IRailPort {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    country: Country;
}

export class FreightRailActivityData implements IFreightRailActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleNo: string;
    method: string;
    option: string;
    domOrInt: string;
    cargoType: string;
    departureStationUp: RailPort;
    destinationStationUp: RailPort;
    departureStationDown: RailPort;
    destinationStationDown: RailPort;
    ownership: string;
    noOfTrips: number;
    month: number;
    fuelConsumption_unit: string;
    distance_unit: string;
    weight: number;
    fuelType: string;
    fuelConsumption: number;
    distanceUp: number;
    distanceDown: number;
    weightUp: number;
    weightDown: number;
    distanceUp_unit: string;
    distanceDown_unit: string;
    weightUp_unit: string;
    weightDown_unit: string;
    upCostPerKM: number;
    downCostPerKM: number;
    upCost: number;
    downCost: number;
    activity: string;
    type: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightRailActivityDataActivityDataStatus;

    constructor(data?: IFreightRailActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.departureStationUp = new RailPort();
            this.destinationStationUp = new RailPort();
            this.departureStationDown = new RailPort();
            this.destinationStationDown = new RailPort();
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.paidByCompany = _data["paidByCompany"];
            this.vehicleNo = _data["vehicleNo"];
            this.method = _data["method"];
            this.option = _data["option"];
            this.domOrInt = _data["domOrInt"];
            this.cargoType = _data["cargoType"];
            this.departureStationUp = _data["departureStationUp"] ? RailPort.fromJS(_data["departureStationUp"]) : new RailPort();
            this.destinationStationUp = _data["destinationStationUp"] ? RailPort.fromJS(_data["destinationStationUp"]) : new RailPort();
            this.departureStationDown = _data["departureStationDown"] ? RailPort.fromJS(_data["departureStationDown"]) : new RailPort();
            this.destinationStationDown = _data["destinationStationDown"] ? RailPort.fromJS(_data["destinationStationDown"]) : new RailPort();
            this.ownership = _data["ownership"];
            this.noOfTrips = _data["noOfTrips"];
            this.month = _data["month"];
            this.fuelConsumption_unit = _data["fuelConsumption_unit"];
            this.distance_unit = _data["distance_unit"];
            this.weight = _data["weight"];
            this.fuelType = _data["fuelType"];
            this.fuelConsumption = _data["fuelConsumption"];
            this.distanceUp = _data["distanceUp"];
            this.distanceDown = _data["distanceDown"];
            this.weightUp = _data["weightUp"];
            this.weightDown = _data["weightDown"];
            this.distanceUp_unit = _data["distanceUp_unit"];
            this.distanceDown_unit = _data["distanceDown_unit"];
            this.weightUp_unit = _data["weightUp_unit"];
            this.weightDown_unit = _data["weightDown_unit"];
            this.upCostPerKM = _data["upCostPerKM"];
            this.downCostPerKM = _data["downCostPerKM"];
            this.upCost = _data["upCost"];
            this.downCost = _data["downCost"];
            this.activity = _data["activity"];
            this.type = _data["type"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): FreightRailActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new FreightRailActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["paidByCompany"] = this.paidByCompany;
        data["vehicleNo"] = this.vehicleNo;
        data["method"] = this.method;
        data["option"] = this.option;
        data["domOrInt"] = this.domOrInt;
        data["cargoType"] = this.cargoType;
        data["departureStationUp"] = this.departureStationUp ? this.departureStationUp.toJSON() : <any>undefined;
        data["destinationStationUp"] = this.destinationStationUp ? this.destinationStationUp.toJSON() : <any>undefined;
        data["departureStationDown"] = this.departureStationDown ? this.departureStationDown.toJSON() : <any>undefined;
        data["destinationStationDown"] = this.destinationStationDown ? this.destinationStationDown.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["noOfTrips"] = this.noOfTrips;
        data["month"] = this.month;
        data["fuelConsumption_unit"] = this.fuelConsumption_unit;
        data["distance_unit"] = this.distance_unit;
        data["weight"] = this.weight;
        data["fuelType"] = this.fuelType;
        data["fuelConsumption"] = this.fuelConsumption;
        data["distanceUp"] = this.distanceUp;
        data["distanceDown"] = this.distanceDown;
        data["weightUp"] = this.weightUp;
        data["weightDown"] = this.weightDown;
        data["distanceUp_unit"] = this.distanceUp_unit;
        data["distanceDown_unit"] = this.distanceDown_unit;
        data["weightUp_unit"] = this.weightUp_unit;
        data["weightDown_unit"] = this.weightDown_unit;
        data["upCostPerKM"] = this.upCostPerKM;
        data["downCostPerKM"] = this.downCostPerKM;
        data["upCost"] = this.upCost;
        data["downCost"] = this.downCost;
        data["activity"] = this.activity;
        data["type"] = this.type;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): FreightRailActivityData {
        const json = this.toJSON();
        let result = new FreightRailActivityData();
        result.init(json);
        return result;
    }
}

export interface IFreightRailActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleNo: string;
    method: string;
    option: string;
    domOrInt: string;
    cargoType: string;
    departureStationUp: RailPort;
    destinationStationUp: RailPort;
    departureStationDown: RailPort;
    destinationStationDown: RailPort;
    ownership: string;
    noOfTrips: number;
    month: number;
    fuelConsumption_unit: string;
    distance_unit: string;
    weight: number;
    fuelType: string;
    fuelConsumption: number;
    distanceUp: number;
    distanceDown: number;
    weightUp: number;
    weightDown: number;
    distanceUp_unit: string;
    distanceDown_unit: string;
    weightUp_unit: string;
    weightDown_unit: string;
    upCostPerKM: number;
    downCostPerKM: number;
    upCost: number;
    downCost: number;
    activity: string;
    type: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightRailActivityDataActivityDataStatus;
}

export class CreateManyFreightRailActivityDataDto implements ICreateManyFreightRailActivityDataDto {
    bulk: FreightRailActivityData[];

    constructor(data?: ICreateManyFreightRailActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FreightRailActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFreightRailActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFreightRailActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFreightRailActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyFreightRailActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFreightRailActivityDataDto {
    bulk: FreightRailActivityData[];
}

export class GetManyFreightRoadActivityDataResponseDto implements IGetManyFreightRoadActivityDataResponseDto {
    data: FreightRoadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFreightRoadActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FreightRoadActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFreightRoadActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFreightRoadActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFreightRoadActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyFreightRoadActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFreightRoadActivityDataResponseDto {
    data: FreightRoadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class FreightRoadActivityData implements IFreightRoadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleNo: string;
    method: string;
    ownership: string;
    isShared: boolean;
    share: number;
    cargoType: string;
    option: string;
    domOrInt: string;
    upWeight: number;
    downWeight: number;
    upWeight_unit: string;
    downWeight_unit: string;
    upCost: number;
    downCost: number;
    upCostPerKM: number;
    downCostPerKM: number;
    noOfTrips: number;
    month: number;
    upDistance_unit: string;
    downDistance_unit: string;
    upDistance: number;
    downDistance: number;
    fuelConsumption_unit: string;
    fuelType: string;
    fuelConsumption: number;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightRoadActivityDataActivityDataStatus;

    constructor(data?: IFreightRoadActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.paidByCompany = _data["paidByCompany"];
            this.vehicleNo = _data["vehicleNo"];
            this.method = _data["method"];
            this.ownership = _data["ownership"];
            this.isShared = _data["isShared"];
            this.share = _data["share"];
            this.cargoType = _data["cargoType"];
            this.option = _data["option"];
            this.domOrInt = _data["domOrInt"];
            this.upWeight = _data["upWeight"];
            this.downWeight = _data["downWeight"];
            this.upWeight_unit = _data["upWeight_unit"];
            this.downWeight_unit = _data["downWeight_unit"];
            this.upCost = _data["upCost"];
            this.downCost = _data["downCost"];
            this.upCostPerKM = _data["upCostPerKM"];
            this.downCostPerKM = _data["downCostPerKM"];
            this.noOfTrips = _data["noOfTrips"];
            this.month = _data["month"];
            this.upDistance_unit = _data["upDistance_unit"];
            this.downDistance_unit = _data["downDistance_unit"];
            this.upDistance = _data["upDistance"];
            this.downDistance = _data["downDistance"];
            this.fuelConsumption_unit = _data["fuelConsumption_unit"];
            this.fuelType = _data["fuelType"];
            this.fuelConsumption = _data["fuelConsumption"];
            this.fuelEconomy = _data["fuelEconomy"];
            this.fuelEconomy_unit = _data["fuelEconomy_unit"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): FreightRoadActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new FreightRoadActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["paidByCompany"] = this.paidByCompany;
        data["vehicleNo"] = this.vehicleNo;
        data["method"] = this.method;
        data["ownership"] = this.ownership;
        data["isShared"] = this.isShared;
        data["share"] = this.share;
        data["cargoType"] = this.cargoType;
        data["option"] = this.option;
        data["domOrInt"] = this.domOrInt;
        data["upWeight"] = this.upWeight;
        data["downWeight"] = this.downWeight;
        data["upWeight_unit"] = this.upWeight_unit;
        data["downWeight_unit"] = this.downWeight_unit;
        data["upCost"] = this.upCost;
        data["downCost"] = this.downCost;
        data["upCostPerKM"] = this.upCostPerKM;
        data["downCostPerKM"] = this.downCostPerKM;
        data["noOfTrips"] = this.noOfTrips;
        data["month"] = this.month;
        data["upDistance_unit"] = this.upDistance_unit;
        data["downDistance_unit"] = this.downDistance_unit;
        data["upDistance"] = this.upDistance;
        data["downDistance"] = this.downDistance;
        data["fuelConsumption_unit"] = this.fuelConsumption_unit;
        data["fuelType"] = this.fuelType;
        data["fuelConsumption"] = this.fuelConsumption;
        data["fuelEconomy"] = this.fuelEconomy;
        data["fuelEconomy_unit"] = this.fuelEconomy_unit;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): FreightRoadActivityData {
        const json = this.toJSON();
        let result = new FreightRoadActivityData();
        result.init(json);
        return result;
    }
}

export interface IFreightRoadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleNo: string;
    method: string;
    ownership: string;
    isShared: boolean;
    share: number;
    cargoType: string;
    option: string;
    domOrInt: string;
    upWeight: number;
    downWeight: number;
    upWeight_unit: string;
    downWeight_unit: string;
    upCost: number;
    downCost: number;
    upCostPerKM: number;
    downCostPerKM: number;
    noOfTrips: number;
    month: number;
    upDistance_unit: string;
    downDistance_unit: string;
    upDistance: number;
    downDistance: number;
    fuelConsumption_unit: string;
    fuelType: string;
    fuelConsumption: number;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightRoadActivityDataActivityDataStatus;
}

export class CreateManyFreightRoadActivityDataDto implements ICreateManyFreightRoadActivityDataDto {
    bulk: FreightRoadActivityData[];

    constructor(data?: ICreateManyFreightRoadActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FreightRoadActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFreightRoadActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFreightRoadActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFreightRoadActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyFreightRoadActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFreightRoadActivityDataDto {
    bulk: FreightRoadActivityData[];
}

export class GetManyFreightWaterActivityDataResponseDto implements IGetManyFreightWaterActivityDataResponseDto {
    data: FreightWaterActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFreightWaterActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FreightWaterActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFreightWaterActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFreightWaterActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFreightWaterActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyFreightWaterActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFreightWaterActivityDataResponseDto {
    data: FreightWaterActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManySeaPortResponseDto implements IGetManySeaPortResponseDto {
    data: SeaPort[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManySeaPortResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(SeaPort.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManySeaPortResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManySeaPortResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManySeaPortResponseDto {
        const json = this.toJSON();
        let result = new GetManySeaPortResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManySeaPortResponseDto {
    data: SeaPort[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class SeaPort implements ISeaPort {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    country: Country;

    constructor(data?: ISeaPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.country = new Country();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
        }
    }

    static fromJS(data: any): SeaPort {
        data = typeof data === 'object' ? data : {};
        let result = new SeaPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }

    clone(): SeaPort {
        const json = this.toJSON();
        let result = new SeaPort();
        result.init(json);
        return result;
    }
}

export interface ISeaPort {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
    country: Country;
}

export class FreightWaterActivityData implements IFreightWaterActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleNo: string;
    method: string;
    domOrInt: string;
    cargoType: string;
    departureCountryOneWay: Country;
    destinationCountryOneWay: Country;
    departureCountryTwoWay: Country;
    destinationCountryTwoWay: Country;
    transist_oneWay_1: SeaPort;
    transist_oneWay_2: SeaPort;
    transist_oneWay_3: SeaPort;
    transist_twoWay_1: SeaPort;
    transist_twoWay_2: SeaPort;
    transist_twoWay_3: SeaPort;
    ownership: string;
    option: string;
    upWeight: number;
    downWeight: number;
    upWeight_unit: string;
    downWeight_unit: string;
    upCost: number;
    downCost: number;
    departurePortOneWay: SeaPort;
    destinationPortOneWay: SeaPort;
    departurePortTwoWay: SeaPort;
    destinationPortTwoWay: SeaPort;
    noOfTrips: number;
    month: number;
    upDistance_unit: string;
    downDistance_unit: string;
    upDistance: number;
    downDistance: number;
    upCostPerKM: number;
    downCostPerKM: number;
    activity: string;
    size: string;
    type: string;
    vezel: string;
    fuel_unit: string;
    distance_unit: string;
    fuelType: string;
    fuelConsumption: number;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightWaterActivityDataActivityDataStatus;

    constructor(data?: IFreightWaterActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.departureCountryOneWay = new Country();
            this.destinationCountryOneWay = new Country();
            this.departureCountryTwoWay = new Country();
            this.destinationCountryTwoWay = new Country();
            this.transist_oneWay_1 = new SeaPort();
            this.transist_oneWay_2 = new SeaPort();
            this.transist_oneWay_3 = new SeaPort();
            this.transist_twoWay_1 = new SeaPort();
            this.transist_twoWay_2 = new SeaPort();
            this.transist_twoWay_3 = new SeaPort();
            this.departurePortOneWay = new SeaPort();
            this.destinationPortOneWay = new SeaPort();
            this.departurePortTwoWay = new SeaPort();
            this.destinationPortTwoWay = new SeaPort();
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.paidByCompany = _data["paidByCompany"];
            this.vehicleNo = _data["vehicleNo"];
            this.method = _data["method"];
            this.domOrInt = _data["domOrInt"];
            this.cargoType = _data["cargoType"];
            this.departureCountryOneWay = _data["departureCountryOneWay"] ? Country.fromJS(_data["departureCountryOneWay"]) : new Country();
            this.destinationCountryOneWay = _data["destinationCountryOneWay"] ? Country.fromJS(_data["destinationCountryOneWay"]) : new Country();
            this.departureCountryTwoWay = _data["departureCountryTwoWay"] ? Country.fromJS(_data["departureCountryTwoWay"]) : new Country();
            this.destinationCountryTwoWay = _data["destinationCountryTwoWay"] ? Country.fromJS(_data["destinationCountryTwoWay"]) : new Country();
            this.transist_oneWay_1 = _data["transist_oneWay_1"] ? SeaPort.fromJS(_data["transist_oneWay_1"]) : new SeaPort();
            this.transist_oneWay_2 = _data["transist_oneWay_2"] ? SeaPort.fromJS(_data["transist_oneWay_2"]) : new SeaPort();
            this.transist_oneWay_3 = _data["transist_oneWay_3"] ? SeaPort.fromJS(_data["transist_oneWay_3"]) : new SeaPort();
            this.transist_twoWay_1 = _data["transist_twoWay_1"] ? SeaPort.fromJS(_data["transist_twoWay_1"]) : new SeaPort();
            this.transist_twoWay_2 = _data["transist_twoWay_2"] ? SeaPort.fromJS(_data["transist_twoWay_2"]) : new SeaPort();
            this.transist_twoWay_3 = _data["transist_twoWay_3"] ? SeaPort.fromJS(_data["transist_twoWay_3"]) : new SeaPort();
            this.ownership = _data["ownership"];
            this.option = _data["option"];
            this.upWeight = _data["upWeight"];
            this.downWeight = _data["downWeight"];
            this.upWeight_unit = _data["upWeight_unit"];
            this.downWeight_unit = _data["downWeight_unit"];
            this.upCost = _data["upCost"];
            this.downCost = _data["downCost"];
            this.departurePortOneWay = _data["departurePortOneWay"] ? SeaPort.fromJS(_data["departurePortOneWay"]) : new SeaPort();
            this.destinationPortOneWay = _data["destinationPortOneWay"] ? SeaPort.fromJS(_data["destinationPortOneWay"]) : new SeaPort();
            this.departurePortTwoWay = _data["departurePortTwoWay"] ? SeaPort.fromJS(_data["departurePortTwoWay"]) : new SeaPort();
            this.destinationPortTwoWay = _data["destinationPortTwoWay"] ? SeaPort.fromJS(_data["destinationPortTwoWay"]) : new SeaPort();
            this.noOfTrips = _data["noOfTrips"];
            this.month = _data["month"];
            this.upDistance_unit = _data["upDistance_unit"];
            this.downDistance_unit = _data["downDistance_unit"];
            this.upDistance = _data["upDistance"];
            this.downDistance = _data["downDistance"];
            this.upCostPerKM = _data["upCostPerKM"];
            this.downCostPerKM = _data["downCostPerKM"];
            this.activity = _data["activity"];
            this.size = _data["size"];
            this.type = _data["type"];
            this.vezel = _data["vezel"];
            this.fuel_unit = _data["fuel_unit"];
            this.distance_unit = _data["distance_unit"];
            this.fuelType = _data["fuelType"];
            this.fuelConsumption = _data["fuelConsumption"];
            this.emission = _data["emission"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): FreightWaterActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new FreightWaterActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["paidByCompany"] = this.paidByCompany;
        data["vehicleNo"] = this.vehicleNo;
        data["method"] = this.method;
        data["domOrInt"] = this.domOrInt;
        data["cargoType"] = this.cargoType;
        data["departureCountryOneWay"] = this.departureCountryOneWay ? this.departureCountryOneWay.toJSON() : <any>undefined;
        data["destinationCountryOneWay"] = this.destinationCountryOneWay ? this.destinationCountryOneWay.toJSON() : <any>undefined;
        data["departureCountryTwoWay"] = this.departureCountryTwoWay ? this.departureCountryTwoWay.toJSON() : <any>undefined;
        data["destinationCountryTwoWay"] = this.destinationCountryTwoWay ? this.destinationCountryTwoWay.toJSON() : <any>undefined;
        data["transist_oneWay_1"] = this.transist_oneWay_1 ? this.transist_oneWay_1.toJSON() : <any>undefined;
        data["transist_oneWay_2"] = this.transist_oneWay_2 ? this.transist_oneWay_2.toJSON() : <any>undefined;
        data["transist_oneWay_3"] = this.transist_oneWay_3 ? this.transist_oneWay_3.toJSON() : <any>undefined;
        data["transist_twoWay_1"] = this.transist_twoWay_1 ? this.transist_twoWay_1.toJSON() : <any>undefined;
        data["transist_twoWay_2"] = this.transist_twoWay_2 ? this.transist_twoWay_2.toJSON() : <any>undefined;
        data["transist_twoWay_3"] = this.transist_twoWay_3 ? this.transist_twoWay_3.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["option"] = this.option;
        data["upWeight"] = this.upWeight;
        data["downWeight"] = this.downWeight;
        data["upWeight_unit"] = this.upWeight_unit;
        data["downWeight_unit"] = this.downWeight_unit;
        data["upCost"] = this.upCost;
        data["downCost"] = this.downCost;
        data["departurePortOneWay"] = this.departurePortOneWay ? this.departurePortOneWay.toJSON() : <any>undefined;
        data["destinationPortOneWay"] = this.destinationPortOneWay ? this.destinationPortOneWay.toJSON() : <any>undefined;
        data["departurePortTwoWay"] = this.departurePortTwoWay ? this.departurePortTwoWay.toJSON() : <any>undefined;
        data["destinationPortTwoWay"] = this.destinationPortTwoWay ? this.destinationPortTwoWay.toJSON() : <any>undefined;
        data["noOfTrips"] = this.noOfTrips;
        data["month"] = this.month;
        data["upDistance_unit"] = this.upDistance_unit;
        data["downDistance_unit"] = this.downDistance_unit;
        data["upDistance"] = this.upDistance;
        data["downDistance"] = this.downDistance;
        data["upCostPerKM"] = this.upCostPerKM;
        data["downCostPerKM"] = this.downCostPerKM;
        data["activity"] = this.activity;
        data["size"] = this.size;
        data["type"] = this.type;
        data["vezel"] = this.vezel;
        data["fuel_unit"] = this.fuel_unit;
        data["distance_unit"] = this.distance_unit;
        data["fuelType"] = this.fuelType;
        data["fuelConsumption"] = this.fuelConsumption;
        data["emission"] = this.emission;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): FreightWaterActivityData {
        const json = this.toJSON();
        let result = new FreightWaterActivityData();
        result.init(json);
        return result;
    }
}

export interface IFreightWaterActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleNo: string;
    method: string;
    domOrInt: string;
    cargoType: string;
    departureCountryOneWay: Country;
    destinationCountryOneWay: Country;
    departureCountryTwoWay: Country;
    destinationCountryTwoWay: Country;
    transist_oneWay_1: SeaPort;
    transist_oneWay_2: SeaPort;
    transist_oneWay_3: SeaPort;
    transist_twoWay_1: SeaPort;
    transist_twoWay_2: SeaPort;
    transist_twoWay_3: SeaPort;
    ownership: string;
    option: string;
    upWeight: number;
    downWeight: number;
    upWeight_unit: string;
    downWeight_unit: string;
    upCost: number;
    downCost: number;
    departurePortOneWay: SeaPort;
    destinationPortOneWay: SeaPort;
    departurePortTwoWay: SeaPort;
    destinationPortTwoWay: SeaPort;
    noOfTrips: number;
    month: number;
    upDistance_unit: string;
    downDistance_unit: string;
    upDistance: number;
    downDistance: number;
    upCostPerKM: number;
    downCostPerKM: number;
    activity: string;
    size: string;
    type: string;
    vezel: string;
    fuel_unit: string;
    distance_unit: string;
    fuelType: string;
    fuelConsumption: number;
    emission: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightWaterActivityDataActivityDataStatus;
}

export class CreateManyFreightWaterActivityDataDto implements ICreateManyFreightWaterActivityDataDto {
    bulk: FreightWaterActivityData[];

    constructor(data?: ICreateManyFreightWaterActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FreightWaterActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFreightWaterActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFreightWaterActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFreightWaterActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyFreightWaterActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFreightWaterActivityDataDto {
    bulk: FreightWaterActivityData[];
}

export class GetManyFreightOffroadActivityDataResponseDto implements IGetManyFreightOffroadActivityDataResponseDto {
    data: FreightOffroadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFreightOffroadActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FreightOffroadActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFreightOffroadActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFreightOffroadActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFreightOffroadActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyFreightOffroadActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFreightOffroadActivityDataResponseDto {
    data: FreightOffroadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class FreightOffroadActivityData implements IFreightOffroadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleModel: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    option: string;
    noOfTrips: number;
    domOrInt: string;
    cargoType: string;
    totalDistanceTravelled: number;
    weight: number;
    fuelConsumption_unit: string;
    distance_unit: string;
    fuelType: string;
    stroke: string;
    fuelConsumption: number;
    industry: string;
    month: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightOffroadActivityDataActivityDataStatus;

    constructor(data?: IFreightOffroadActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.paidByCompany = _data["paidByCompany"];
            this.vehicleModel = _data["vehicleModel"];
            this.vehicleNo = _data["vehicleNo"];
            this.method = _data["method"];
            this.ownership = _data["ownership"];
            this.option = _data["option"];
            this.noOfTrips = _data["noOfTrips"];
            this.domOrInt = _data["domOrInt"];
            this.cargoType = _data["cargoType"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.weight = _data["weight"];
            this.fuelConsumption_unit = _data["fuelConsumption_unit"];
            this.distance_unit = _data["distance_unit"];
            this.fuelType = _data["fuelType"];
            this.stroke = _data["stroke"];
            this.fuelConsumption = _data["fuelConsumption"];
            this.industry = _data["industry"];
            this.month = _data["month"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): FreightOffroadActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new FreightOffroadActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["paidByCompany"] = this.paidByCompany;
        data["vehicleModel"] = this.vehicleModel;
        data["vehicleNo"] = this.vehicleNo;
        data["method"] = this.method;
        data["ownership"] = this.ownership;
        data["option"] = this.option;
        data["noOfTrips"] = this.noOfTrips;
        data["domOrInt"] = this.domOrInt;
        data["cargoType"] = this.cargoType;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["weight"] = this.weight;
        data["fuelConsumption_unit"] = this.fuelConsumption_unit;
        data["distance_unit"] = this.distance_unit;
        data["fuelType"] = this.fuelType;
        data["stroke"] = this.stroke;
        data["fuelConsumption"] = this.fuelConsumption;
        data["industry"] = this.industry;
        data["month"] = this.month;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): FreightOffroadActivityData {
        const json = this.toJSON();
        let result = new FreightOffroadActivityData();
        result.init(json);
        return result;
    }
}

export interface IFreightOffroadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    paidByCompany: boolean;
    vehicleModel: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    option: string;
    noOfTrips: number;
    domOrInt: string;
    cargoType: string;
    totalDistanceTravelled: number;
    weight: number;
    fuelConsumption_unit: string;
    distance_unit: string;
    fuelType: string;
    stroke: string;
    fuelConsumption: number;
    industry: string;
    month: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FreightOffroadActivityDataActivityDataStatus;
}

export class CreateManyFreightOffroadActivityDataDto implements ICreateManyFreightOffroadActivityDataDto {
    bulk: FreightOffroadActivityData[];

    constructor(data?: ICreateManyFreightOffroadActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FreightOffroadActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFreightOffroadActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFreightOffroadActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFreightOffroadActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyFreightOffroadActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFreightOffroadActivityDataDto {
    bulk: FreightOffroadActivityData[];
}

export class GetManyPassengerRoadActivityDataResponseDto implements IGetManyPassengerRoadActivityDataResponseDto {
    data: PassengerRoadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPassengerRoadActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PassengerRoadActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPassengerRoadActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPassengerRoadActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyPassengerRoadActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyPassengerRoadActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPassengerRoadActivityDataResponseDto {
    data: PassengerRoadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PassengerRoadActivityData implements IPassengerRoadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    transportMethod: string;
    employeeName: string;
    domOrInt: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    hiredFuelType: string;
    workingDays: number;
    directTransportMode: string;
    petrolConsumption: number;
    petrolConsumption_unit: string;
    dieselConsumption: number;
    dieselConsumption_unit: string;
    noEmissionMode: string;
    publicMode: string;
    privateMode: string;
    hiredMode: string;
    noEmissionDistance: number;
    noEmissionDistance_unit: string;
    publicDistance: number;
    publicDistance_unit: string;
    privateDistance: number;
    privateDistance_unit: string;
    hiredDistance: number;
    hiredDistance_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    hiredFuelEconomy: number;
    hiredFuelEconomy_unit: string;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerRoadActivityDataActivityDataStatus;

    constructor(data?: IPassengerRoadActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.transportMethod = _data["transportMethod"];
            this.employeeName = _data["employeeName"];
            this.domOrInt = _data["domOrInt"];
            this.vehicleNo = _data["vehicleNo"];
            this.method = _data["method"];
            this.ownership = _data["ownership"];
            this.noOfTrips = _data["noOfTrips"];
            this.option = _data["option"];
            this.month = _data["month"];
            this.fuelType = _data["fuelType"];
            this.hiredFuelType = _data["hiredFuelType"];
            this.workingDays = _data["workingDays"];
            this.directTransportMode = _data["directTransportMode"];
            this.petrolConsumption = _data["petrolConsumption"];
            this.petrolConsumption_unit = _data["petrolConsumption_unit"];
            this.dieselConsumption = _data["dieselConsumption"];
            this.dieselConsumption_unit = _data["dieselConsumption_unit"];
            this.noEmissionMode = _data["noEmissionMode"];
            this.publicMode = _data["publicMode"];
            this.privateMode = _data["privateMode"];
            this.hiredMode = _data["hiredMode"];
            this.noEmissionDistance = _data["noEmissionDistance"];
            this.noEmissionDistance_unit = _data["noEmissionDistance_unit"];
            this.publicDistance = _data["publicDistance"];
            this.publicDistance_unit = _data["publicDistance_unit"];
            this.privateDistance = _data["privateDistance"];
            this.privateDistance_unit = _data["privateDistance_unit"];
            this.hiredDistance = _data["hiredDistance"];
            this.hiredDistance_unit = _data["hiredDistance_unit"];
            this.fuelEconomy = _data["fuelEconomy"];
            this.fuelEconomy_unit = _data["fuelEconomy_unit"];
            this.hiredFuelEconomy = _data["hiredFuelEconomy"];
            this.hiredFuelEconomy_unit = _data["hiredFuelEconomy_unit"];
            this.paidByCompany = _data["paidByCompany"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): PassengerRoadActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new PassengerRoadActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["transportMethod"] = this.transportMethod;
        data["employeeName"] = this.employeeName;
        data["domOrInt"] = this.domOrInt;
        data["vehicleNo"] = this.vehicleNo;
        data["method"] = this.method;
        data["ownership"] = this.ownership;
        data["noOfTrips"] = this.noOfTrips;
        data["option"] = this.option;
        data["month"] = this.month;
        data["fuelType"] = this.fuelType;
        data["hiredFuelType"] = this.hiredFuelType;
        data["workingDays"] = this.workingDays;
        data["directTransportMode"] = this.directTransportMode;
        data["petrolConsumption"] = this.petrolConsumption;
        data["petrolConsumption_unit"] = this.petrolConsumption_unit;
        data["dieselConsumption"] = this.dieselConsumption;
        data["dieselConsumption_unit"] = this.dieselConsumption_unit;
        data["noEmissionMode"] = this.noEmissionMode;
        data["publicMode"] = this.publicMode;
        data["privateMode"] = this.privateMode;
        data["hiredMode"] = this.hiredMode;
        data["noEmissionDistance"] = this.noEmissionDistance;
        data["noEmissionDistance_unit"] = this.noEmissionDistance_unit;
        data["publicDistance"] = this.publicDistance;
        data["publicDistance_unit"] = this.publicDistance_unit;
        data["privateDistance"] = this.privateDistance;
        data["privateDistance_unit"] = this.privateDistance_unit;
        data["hiredDistance"] = this.hiredDistance;
        data["hiredDistance_unit"] = this.hiredDistance_unit;
        data["fuelEconomy"] = this.fuelEconomy;
        data["fuelEconomy_unit"] = this.fuelEconomy_unit;
        data["hiredFuelEconomy"] = this.hiredFuelEconomy;
        data["hiredFuelEconomy_unit"] = this.hiredFuelEconomy_unit;
        data["paidByCompany"] = this.paidByCompany;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): PassengerRoadActivityData {
        const json = this.toJSON();
        let result = new PassengerRoadActivityData();
        result.init(json);
        return result;
    }
}

export interface IPassengerRoadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    transportMethod: string;
    employeeName: string;
    domOrInt: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    hiredFuelType: string;
    workingDays: number;
    directTransportMode: string;
    petrolConsumption: number;
    petrolConsumption_unit: string;
    dieselConsumption: number;
    dieselConsumption_unit: string;
    noEmissionMode: string;
    publicMode: string;
    privateMode: string;
    hiredMode: string;
    noEmissionDistance: number;
    noEmissionDistance_unit: string;
    publicDistance: number;
    publicDistance_unit: string;
    privateDistance: number;
    privateDistance_unit: string;
    hiredDistance: number;
    hiredDistance_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    hiredFuelEconomy: number;
    hiredFuelEconomy_unit: string;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerRoadActivityDataActivityDataStatus;
}

export class CreateManyPassengerRoadActivityDataDto implements ICreateManyPassengerRoadActivityDataDto {
    bulk: PassengerRoadActivityData[];

    constructor(data?: ICreateManyPassengerRoadActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PassengerRoadActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPassengerRoadActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPassengerRoadActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyPassengerRoadActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyPassengerRoadActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPassengerRoadActivityDataDto {
    bulk: PassengerRoadActivityData[];
}

export class GetManyEmployeeNameResponseDto implements IGetManyEmployeeNameResponseDto {
    data: EmployeeName[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyEmployeeNameResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(EmployeeName.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyEmployeeNameResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyEmployeeNameResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyEmployeeNameResponseDto {
        const json = this.toJSON();
        let result = new GetManyEmployeeNameResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyEmployeeNameResponseDto {
    data: EmployeeName[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class EmployeeName implements IEmployeeName {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    empId: string;
    code: string;
    unit: Unit;

    constructor(data?: IEmployeeName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unit = new Unit();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.empId = _data["empId"];
            this.code = _data["code"];
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
        }
    }

    static fromJS(data: any): EmployeeName {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["empId"] = this.empId;
        data["code"] = this.code;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        return data;
    }

    clone(): EmployeeName {
        const json = this.toJSON();
        let result = new EmployeeName();
        result.init(json);
        return result;
    }
}

export interface IEmployeeName {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    empId: string;
    code: string;
    unit: Unit;
}

export class CreateManyEmployeeNameDto implements ICreateManyEmployeeNameDto {
    bulk: EmployeeName[];

    constructor(data?: ICreateManyEmployeeNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(EmployeeName.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyEmployeeNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyEmployeeNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyEmployeeNameDto {
        const json = this.toJSON();
        let result = new CreateManyEmployeeNameDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyEmployeeNameDto {
    bulk: EmployeeName[];
}

export class GetManyPassengerOffroadActivityDataResponseDto implements IGetManyPassengerOffroadActivityDataResponseDto {
    data: PassengerOffroadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPassengerOffroadActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PassengerOffroadActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPassengerOffroadActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPassengerOffroadActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyPassengerOffroadActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyPassengerOffroadActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPassengerOffroadActivityDataResponseDto {
    data: PassengerOffroadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PassengerOffroadActivityData implements IPassengerOffroadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    stroke: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    fuelConsumption: number;
    fuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    paidByCompany: boolean;
    industry: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerOffroadActivityDataActivityDataStatus;

    constructor(data?: IPassengerOffroadActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.domOrInt = _data["domOrInt"];
            this.vehicleNo = _data["vehicleNo"];
            this.method = _data["method"];
            this.ownership = _data["ownership"];
            this.noOfTrips = _data["noOfTrips"];
            this.option = _data["option"];
            this.month = _data["month"];
            this.fuelType = _data["fuelType"];
            this.stroke = _data["stroke"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.totalDistanceTravelled_unit = _data["totalDistanceTravelled_unit"];
            this.fuelConsumption = _data["fuelConsumption"];
            this.fuelConsumption_unit = _data["fuelConsumption_unit"];
            this.fuelEconomy = _data["fuelEconomy"];
            this.fuelEconomy_unit = _data["fuelEconomy_unit"];
            this.paidByCompany = _data["paidByCompany"];
            this.industry = _data["industry"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): PassengerOffroadActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new PassengerOffroadActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["domOrInt"] = this.domOrInt;
        data["vehicleNo"] = this.vehicleNo;
        data["method"] = this.method;
        data["ownership"] = this.ownership;
        data["noOfTrips"] = this.noOfTrips;
        data["option"] = this.option;
        data["month"] = this.month;
        data["fuelType"] = this.fuelType;
        data["stroke"] = this.stroke;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["totalDistanceTravelled_unit"] = this.totalDistanceTravelled_unit;
        data["fuelConsumption"] = this.fuelConsumption;
        data["fuelConsumption_unit"] = this.fuelConsumption_unit;
        data["fuelEconomy"] = this.fuelEconomy;
        data["fuelEconomy_unit"] = this.fuelEconomy_unit;
        data["paidByCompany"] = this.paidByCompany;
        data["industry"] = this.industry;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): PassengerOffroadActivityData {
        const json = this.toJSON();
        let result = new PassengerOffroadActivityData();
        result.init(json);
        return result;
    }
}

export interface IPassengerOffroadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    stroke: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    fuelConsumption: number;
    fuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    paidByCompany: boolean;
    industry: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerOffroadActivityDataActivityDataStatus;
}

export class CreateManyPassengerOffroadActivityDataDto implements ICreateManyPassengerOffroadActivityDataDto {
    bulk: PassengerOffroadActivityData[];

    constructor(data?: ICreateManyPassengerOffroadActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PassengerOffroadActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPassengerOffroadActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPassengerOffroadActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyPassengerOffroadActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyPassengerOffroadActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPassengerOffroadActivityDataDto {
    bulk: PassengerOffroadActivityData[];
}

export class GetManyPassengerRailActivityDataResponseDto implements IGetManyPassengerRailActivityDataResponseDto {
    data: PassengerRailActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPassengerRailActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PassengerRailActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPassengerRailActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPassengerRailActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyPassengerRailActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyPassengerRailActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPassengerRailActivityDataResponseDto {
    data: PassengerRailActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PassengerRailActivityData implements IPassengerRailActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    fuelConsumption: number;
    fuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerRailActivityDataActivityDataStatus;

    constructor(data?: IPassengerRailActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.domOrInt = _data["domOrInt"];
            this.vehicleNo = _data["vehicleNo"];
            this.method = _data["method"];
            this.ownership = _data["ownership"];
            this.noOfTrips = _data["noOfTrips"];
            this.option = _data["option"];
            this.month = _data["month"];
            this.fuelType = _data["fuelType"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.totalDistanceTravelled_unit = _data["totalDistanceTravelled_unit"];
            this.fuelConsumption = _data["fuelConsumption"];
            this.fuelConsumption_unit = _data["fuelConsumption_unit"];
            this.fuelEconomy = _data["fuelEconomy"];
            this.fuelEconomy_unit = _data["fuelEconomy_unit"];
            this.paidByCompany = _data["paidByCompany"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): PassengerRailActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new PassengerRailActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["domOrInt"] = this.domOrInt;
        data["vehicleNo"] = this.vehicleNo;
        data["method"] = this.method;
        data["ownership"] = this.ownership;
        data["noOfTrips"] = this.noOfTrips;
        data["option"] = this.option;
        data["month"] = this.month;
        data["fuelType"] = this.fuelType;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["totalDistanceTravelled_unit"] = this.totalDistanceTravelled_unit;
        data["fuelConsumption"] = this.fuelConsumption;
        data["fuelConsumption_unit"] = this.fuelConsumption_unit;
        data["fuelEconomy"] = this.fuelEconomy;
        data["fuelEconomy_unit"] = this.fuelEconomy_unit;
        data["paidByCompany"] = this.paidByCompany;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): PassengerRailActivityData {
        const json = this.toJSON();
        let result = new PassengerRailActivityData();
        result.init(json);
        return result;
    }
}

export interface IPassengerRailActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    fuelConsumption: number;
    fuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerRailActivityDataActivityDataStatus;
}

export class CreateManyPassengerRailActivityDataDto implements ICreateManyPassengerRailActivityDataDto {
    bulk: PassengerRailActivityData[];

    constructor(data?: ICreateManyPassengerRailActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PassengerRailActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPassengerRailActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPassengerRailActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyPassengerRailActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyPassengerRailActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPassengerRailActivityDataDto {
    bulk: PassengerRailActivityData[];
}

export class GetManyPassengerAirActivityDataResponseDto implements IGetManyPassengerAirActivityDataResponseDto {
    data: PassengerAirActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPassengerAirActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PassengerAirActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPassengerAirActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPassengerAirActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyPassengerAirActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyPassengerAirActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPassengerAirActivityDataResponseDto {
    data: PassengerAirActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PassengerAirActivityData implements IPassengerAirActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    cabinClass: string;
    departurePort: string;
    transist1: string;
    transist2: string;
    destinationPort: string;
    noOfEmployees: number;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerAirActivityDataActivityDataStatus;

    constructor(data?: IPassengerAirActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.domOrInt = _data["domOrInt"];
            this.vehicleNo = _data["vehicleNo"];
            this.ownership = _data["ownership"];
            this.noOfTrips = _data["noOfTrips"];
            this.option = _data["option"];
            this.month = _data["month"];
            this.cabinClass = _data["cabinClass"];
            this.departurePort = _data["departurePort"];
            this.transist1 = _data["transist1"];
            this.transist2 = _data["transist2"];
            this.destinationPort = _data["destinationPort"];
            this.noOfEmployees = _data["noOfEmployees"];
            this.paidByCompany = _data["paidByCompany"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): PassengerAirActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new PassengerAirActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["domOrInt"] = this.domOrInt;
        data["vehicleNo"] = this.vehicleNo;
        data["ownership"] = this.ownership;
        data["noOfTrips"] = this.noOfTrips;
        data["option"] = this.option;
        data["month"] = this.month;
        data["cabinClass"] = this.cabinClass;
        data["departurePort"] = this.departurePort;
        data["transist1"] = this.transist1;
        data["transist2"] = this.transist2;
        data["destinationPort"] = this.destinationPort;
        data["noOfEmployees"] = this.noOfEmployees;
        data["paidByCompany"] = this.paidByCompany;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): PassengerAirActivityData {
        const json = this.toJSON();
        let result = new PassengerAirActivityData();
        result.init(json);
        return result;
    }
}

export interface IPassengerAirActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    cabinClass: string;
    departurePort: string;
    transist1: string;
    transist2: string;
    destinationPort: string;
    noOfEmployees: number;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerAirActivityDataActivityDataStatus;
}

export class IcaoDto implements IIcaoDto {
    url: string;
    body: any;

    constructor(data?: IIcaoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): IcaoDto {
        data = typeof data === 'object' ? data : {};
        let result = new IcaoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["body"] = this.body;
        return data;
    }

    clone(): IcaoDto {
        const json = this.toJSON();
        let result = new IcaoDto();
        result.init(json);
        return result;
    }
}

export interface IIcaoDto {
    url: string;
    body: any;
}

export class CreateManyPassengerAirActivityDataDto implements ICreateManyPassengerAirActivityDataDto {
    bulk: PassengerAirActivityData[];

    constructor(data?: ICreateManyPassengerAirActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PassengerAirActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPassengerAirActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPassengerAirActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyPassengerAirActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyPassengerAirActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPassengerAirActivityDataDto {
    bulk: PassengerAirActivityData[];
}

export class GetManyPassengerWaterActivityDataResponseDto implements IGetManyPassengerWaterActivityDataResponseDto {
    data: PassengerWaterActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPassengerWaterActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PassengerWaterActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPassengerWaterActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPassengerWaterActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyPassengerWaterActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyPassengerWaterActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPassengerWaterActivityDataResponseDto {
    data: PassengerWaterActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PassengerWaterActivityData implements IPassengerWaterActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    model: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    fuelConsumption: number;
    fuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerWaterActivityDataActivityDataStatus;

    constructor(data?: IPassengerWaterActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.domOrInt = _data["domOrInt"];
            this.vehicleNo = _data["vehicleNo"];
            this.model = _data["model"];
            this.method = _data["method"];
            this.ownership = _data["ownership"];
            this.noOfTrips = _data["noOfTrips"];
            this.option = _data["option"];
            this.month = _data["month"];
            this.fuelType = _data["fuelType"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.totalDistanceTravelled_unit = _data["totalDistanceTravelled_unit"];
            this.fuelConsumption = _data["fuelConsumption"];
            this.fuelConsumption_unit = _data["fuelConsumption_unit"];
            this.fuelEconomy = _data["fuelEconomy"];
            this.fuelEconomy_unit = _data["fuelEconomy_unit"];
            this.paidByCompany = _data["paidByCompany"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): PassengerWaterActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new PassengerWaterActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["domOrInt"] = this.domOrInt;
        data["vehicleNo"] = this.vehicleNo;
        data["model"] = this.model;
        data["method"] = this.method;
        data["ownership"] = this.ownership;
        data["noOfTrips"] = this.noOfTrips;
        data["option"] = this.option;
        data["month"] = this.month;
        data["fuelType"] = this.fuelType;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["totalDistanceTravelled_unit"] = this.totalDistanceTravelled_unit;
        data["fuelConsumption"] = this.fuelConsumption;
        data["fuelConsumption_unit"] = this.fuelConsumption_unit;
        data["fuelEconomy"] = this.fuelEconomy;
        data["fuelEconomy_unit"] = this.fuelEconomy_unit;
        data["paidByCompany"] = this.paidByCompany;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): PassengerWaterActivityData {
        const json = this.toJSON();
        let result = new PassengerWaterActivityData();
        result.init(json);
        return result;
    }
}

export interface IPassengerWaterActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    model: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    fuelConsumption: number;
    fuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PassengerWaterActivityDataActivityDataStatus;
}

export class CreateManyPassengerWaterActivityDataDto implements ICreateManyPassengerWaterActivityDataDto {
    bulk: PassengerWaterActivityData[];

    constructor(data?: ICreateManyPassengerWaterActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PassengerWaterActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPassengerWaterActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPassengerWaterActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyPassengerWaterActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyPassengerWaterActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPassengerWaterActivityDataDto {
    bulk: PassengerWaterActivityData[];
}

export class GetManyBusinessTravelActivityDataResponseDto implements IGetManyBusinessTravelActivityDataResponseDto {
    data: BusinessTravelActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyBusinessTravelActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(BusinessTravelActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyBusinessTravelActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyBusinessTravelActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyBusinessTravelActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyBusinessTravelActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyBusinessTravelActivityDataResponseDto {
    data: BusinessTravelActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class BusinessTravelActivityData implements IBusinessTravelActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    transportMethod: string;
    domOrInt: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    btFuelConsumption: number;
    btFuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    cost: number;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: BusinessTravelActivityDataActivityDataStatus;

    constructor(data?: IBusinessTravelActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.transportMethod = _data["transportMethod"];
            this.domOrInt = _data["domOrInt"];
            this.vehicleNo = _data["vehicleNo"];
            this.method = _data["method"];
            this.ownership = _data["ownership"];
            this.noOfTrips = _data["noOfTrips"];
            this.option = _data["option"];
            this.month = _data["month"];
            this.fuelType = _data["fuelType"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.totalDistanceTravelled_unit = _data["totalDistanceTravelled_unit"];
            this.btFuelConsumption = _data["btFuelConsumption"];
            this.btFuelConsumption_unit = _data["btFuelConsumption_unit"];
            this.fuelEconomy = _data["fuelEconomy"];
            this.fuelEconomy_unit = _data["fuelEconomy_unit"];
            this.cost = _data["cost"];
            this.paidByCompany = _data["paidByCompany"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): BusinessTravelActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessTravelActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["transportMethod"] = this.transportMethod;
        data["domOrInt"] = this.domOrInt;
        data["vehicleNo"] = this.vehicleNo;
        data["method"] = this.method;
        data["ownership"] = this.ownership;
        data["noOfTrips"] = this.noOfTrips;
        data["option"] = this.option;
        data["month"] = this.month;
        data["fuelType"] = this.fuelType;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["totalDistanceTravelled_unit"] = this.totalDistanceTravelled_unit;
        data["btFuelConsumption"] = this.btFuelConsumption;
        data["btFuelConsumption_unit"] = this.btFuelConsumption_unit;
        data["fuelEconomy"] = this.fuelEconomy;
        data["fuelEconomy_unit"] = this.fuelEconomy_unit;
        data["cost"] = this.cost;
        data["paidByCompany"] = this.paidByCompany;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): BusinessTravelActivityData {
        const json = this.toJSON();
        let result = new BusinessTravelActivityData();
        result.init(json);
        return result;
    }
}

export interface IBusinessTravelActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    transportMethod: string;
    domOrInt: string;
    vehicleNo: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    btFuelConsumption: number;
    btFuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    cost: number;
    paidByCompany: boolean;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: BusinessTravelActivityDataActivityDataStatus;
}

export class CreateManyBusinessTravelActivityDataDto implements ICreateManyBusinessTravelActivityDataDto {
    bulk: BusinessTravelActivityData[];

    constructor(data?: ICreateManyBusinessTravelActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(BusinessTravelActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyBusinessTravelActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyBusinessTravelActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyBusinessTravelActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyBusinessTravelActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyBusinessTravelActivityDataDto {
    bulk: BusinessTravelActivityData[];
}

export class GetManyOffroadMachineryOffroadActivityDataResponseDto implements IGetManyOffroadMachineryOffroadActivityDataResponseDto {
    data: OffroadMachineryOffroadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyOffroadMachineryOffroadActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(OffroadMachineryOffroadActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyOffroadMachineryOffroadActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyOffroadMachineryOffroadActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyOffroadMachineryOffroadActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyOffroadMachineryOffroadActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyOffroadMachineryOffroadActivityDataResponseDto {
    data: OffroadMachineryOffroadActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class OffroadMachineryOffroadActivityData implements IOffroadMachineryOffroadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    vehicleModel: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    stroke: string;
    totalDistanceTravelled: number;
    distance_unit: string;
    fuelConsumption: number;
    fuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    paidByCompany: boolean;
    industry: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: OffroadMachineryOffroadActivityDataActivityDataStatus;

    constructor(data?: IOffroadMachineryOffroadActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.domOrInt = _data["domOrInt"];
            this.vehicleNo = _data["vehicleNo"];
            this.vehicleModel = _data["vehicleModel"];
            this.method = _data["method"];
            this.ownership = _data["ownership"];
            this.noOfTrips = _data["noOfTrips"];
            this.option = _data["option"];
            this.month = _data["month"];
            this.fuelType = _data["fuelType"];
            this.stroke = _data["stroke"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.distance_unit = _data["distance_unit"];
            this.fuelConsumption = _data["fuelConsumption"];
            this.fuelConsumption_unit = _data["fuelConsumption_unit"];
            this.fuelEconomy = _data["fuelEconomy"];
            this.fuelEconomy_unit = _data["fuelEconomy_unit"];
            this.paidByCompany = _data["paidByCompany"];
            this.industry = _data["industry"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): OffroadMachineryOffroadActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new OffroadMachineryOffroadActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["domOrInt"] = this.domOrInt;
        data["vehicleNo"] = this.vehicleNo;
        data["vehicleModel"] = this.vehicleModel;
        data["method"] = this.method;
        data["ownership"] = this.ownership;
        data["noOfTrips"] = this.noOfTrips;
        data["option"] = this.option;
        data["month"] = this.month;
        data["fuelType"] = this.fuelType;
        data["stroke"] = this.stroke;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["distance_unit"] = this.distance_unit;
        data["fuelConsumption"] = this.fuelConsumption;
        data["fuelConsumption_unit"] = this.fuelConsumption_unit;
        data["fuelEconomy"] = this.fuelEconomy;
        data["fuelEconomy_unit"] = this.fuelEconomy_unit;
        data["paidByCompany"] = this.paidByCompany;
        data["industry"] = this.industry;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): OffroadMachineryOffroadActivityData {
        const json = this.toJSON();
        let result = new OffroadMachineryOffroadActivityData();
        result.init(json);
        return result;
    }
}

export interface IOffroadMachineryOffroadActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    domOrInt: string;
    vehicleNo: string;
    vehicleModel: string;
    method: string;
    ownership: string;
    noOfTrips: number;
    option: string;
    month: number;
    fuelType: string;
    stroke: string;
    totalDistanceTravelled: number;
    distance_unit: string;
    fuelConsumption: number;
    fuelConsumption_unit: string;
    fuelEconomy: number;
    fuelEconomy_unit: string;
    paidByCompany: boolean;
    industry: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: OffroadMachineryOffroadActivityDataActivityDataStatus;
}

export class CreateManyOffroadMachineryOffroadActivityDataDto implements ICreateManyOffroadMachineryOffroadActivityDataDto {
    bulk: OffroadMachineryOffroadActivityData[];

    constructor(data?: ICreateManyOffroadMachineryOffroadActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(OffroadMachineryOffroadActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyOffroadMachineryOffroadActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyOffroadMachineryOffroadActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyOffroadMachineryOffroadActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyOffroadMachineryOffroadActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyOffroadMachineryOffroadActivityDataDto {
    bulk: OffroadMachineryOffroadActivityData[];
}

export class SupplierData implements ISupplierData {
    id: number;
    typeName: string;
    supplierType: string;
    supplierQuantity: number;
    supplierQuantity_unit: string;
    supplierEF: number;
    supplierEF_unit: string;

    constructor(data?: ISupplierData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.supplierType = _data["supplierType"];
            this.supplierQuantity = _data["supplierQuantity"];
            this.supplierQuantity_unit = _data["supplierQuantity_unit"];
            this.supplierEF = _data["supplierEF"];
            this.supplierEF_unit = _data["supplierEF_unit"];
        }
    }

    static fromJS(data: any): SupplierData {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["supplierType"] = this.supplierType;
        data["supplierQuantity"] = this.supplierQuantity;
        data["supplierQuantity_unit"] = this.supplierQuantity_unit;
        data["supplierEF"] = this.supplierEF;
        data["supplierEF_unit"] = this.supplierEF_unit;
        return data;
    }

    clone(): SupplierData {
        const json = this.toJSON();
        let result = new SupplierData();
        result.init(json);
        return result;
    }
}

export interface ISupplierData {
    id: number;
    typeName: string;
    supplierType: string;
    supplierQuantity: number;
    supplierQuantity_unit: string;
    supplierEF: number;
    supplierEF_unit: string;
}

export class SupplierSpecificMethod implements ISupplierSpecificMethod {
    supplierData: SupplierData[];

    constructor(data?: ISupplierSpecificMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.supplierData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["supplierData"])) {
                this.supplierData = [] as any;
                for (let item of _data["supplierData"])
                    this.supplierData.push(SupplierData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SupplierSpecificMethod {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierSpecificMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.supplierData)) {
            data["supplierData"] = [];
            for (let item of this.supplierData)
                data["supplierData"].push(item.toJSON());
        }
        return data;
    }

    clone(): SupplierSpecificMethod {
        const json = this.toJSON();
        let result = new SupplierSpecificMethod();
        result.init(json);
        return result;
    }
}

export interface ISupplierSpecificMethod {
    supplierData: SupplierData[];
}

export class PurchaseData implements IPurchaseData {
    id: number;
    typeName: string;
    purchaseType: string;
    purchaseEmission: number;
    purchaseEmission_unit: string;

    constructor(data?: IPurchaseData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.purchaseType = _data["purchaseType"];
            this.purchaseEmission = _data["purchaseEmission"];
            this.purchaseEmission_unit = _data["purchaseEmission_unit"];
        }
    }

    static fromJS(data: any): PurchaseData {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["purchaseType"] = this.purchaseType;
        data["purchaseEmission"] = this.purchaseEmission;
        data["purchaseEmission_unit"] = this.purchaseEmission_unit;
        return data;
    }

    clone(): PurchaseData {
        const json = this.toJSON();
        let result = new PurchaseData();
        result.init(json);
        return result;
    }
}

export interface IPurchaseData {
    id: number;
    typeName: string;
    purchaseType: string;
    purchaseEmission: number;
    purchaseEmission_unit: string;
}

export class MaterialData implements IMaterialData {
    id: number;
    typeName: string;
    materialType: string;
    materialAmount: number;
    materialAmount_unit: string;
    materialEF: number;
    materialEF_unit: string;

    constructor(data?: IMaterialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.materialType = _data["materialType"];
            this.materialAmount = _data["materialAmount"];
            this.materialAmount_unit = _data["materialAmount_unit"];
            this.materialEF = _data["materialEF"];
            this.materialEF_unit = _data["materialEF_unit"];
        }
    }

    static fromJS(data: any): MaterialData {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["materialType"] = this.materialType;
        data["materialAmount"] = this.materialAmount;
        data["materialAmount_unit"] = this.materialAmount_unit;
        data["materialEF"] = this.materialEF;
        data["materialEF_unit"] = this.materialEF_unit;
        return data;
    }

    clone(): MaterialData {
        const json = this.toJSON();
        let result = new MaterialData();
        result.init(json);
        return result;
    }
}

export interface IMaterialData {
    id: number;
    typeName: string;
    materialType: string;
    materialAmount: number;
    materialAmount_unit: string;
    materialEF: number;
    materialEF_unit: string;
}

export class MaterialTransportData implements IMaterialTransportData {
    id: number;
    typeName: string;
    materialTransType: string;
    distance: number;
    distance_unit: string;
    materialTransAmount: number;
    materialTransAmount_unit: string;
    materialTransEF: number;
    materialTransEF_unit: string;

    constructor(data?: IMaterialTransportData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.materialTransType = _data["materialTransType"];
            this.distance = _data["distance"];
            this.distance_unit = _data["distance_unit"];
            this.materialTransAmount = _data["materialTransAmount"];
            this.materialTransAmount_unit = _data["materialTransAmount_unit"];
            this.materialTransEF = _data["materialTransEF"];
            this.materialTransEF_unit = _data["materialTransEF_unit"];
        }
    }

    static fromJS(data: any): MaterialTransportData {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialTransportData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["materialTransType"] = this.materialTransType;
        data["distance"] = this.distance;
        data["distance_unit"] = this.distance_unit;
        data["materialTransAmount"] = this.materialTransAmount;
        data["materialTransAmount_unit"] = this.materialTransAmount_unit;
        data["materialTransEF"] = this.materialTransEF;
        data["materialTransEF_unit"] = this.materialTransEF_unit;
        return data;
    }

    clone(): MaterialTransportData {
        const json = this.toJSON();
        let result = new MaterialTransportData();
        result.init(json);
        return result;
    }
}

export interface IMaterialTransportData {
    id: number;
    typeName: string;
    materialTransType: string;
    distance: number;
    distance_unit: string;
    materialTransAmount: number;
    materialTransAmount_unit: string;
    materialTransEF: number;
    materialTransEF_unit: string;
}

export class WasteData implements IWasteData {
    id: number;
    typeName: string;
    wasteType: string;
    wasteAmount: number;
    wasteAmount_unit: string;
    waste_activity: WasteDataWaste_activity;
    gas_type: string;
    wasteBasis: string;
    biologicalTreatmentSystem: string;
    wasteCategory: string;
    typeOfWaste: string;
    mswType: string;
    treatmentDischargeType: string;
    approach: string;
    climateZone: string;
    efType: string;
    efCategory: string;
    waste: string;
    disposalMethod: string;

    constructor(data?: IWasteData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.wasteType = _data["wasteType"];
            this.wasteAmount = _data["wasteAmount"];
            this.wasteAmount_unit = _data["wasteAmount_unit"];
            this.waste_activity = _data["waste_activity"];
            this.gas_type = _data["gas_type"];
            this.wasteBasis = _data["wasteBasis"];
            this.biologicalTreatmentSystem = _data["biologicalTreatmentSystem"];
            this.wasteCategory = _data["wasteCategory"];
            this.typeOfWaste = _data["typeOfWaste"];
            this.mswType = _data["mswType"];
            this.treatmentDischargeType = _data["treatmentDischargeType"];
            this.approach = _data["approach"];
            this.climateZone = _data["climateZone"];
            this.efType = _data["efType"];
            this.efCategory = _data["efCategory"];
            this.waste = _data["waste"];
            this.disposalMethod = _data["disposalMethod"];
        }
    }

    static fromJS(data: any): WasteData {
        data = typeof data === 'object' ? data : {};
        let result = new WasteData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["wasteType"] = this.wasteType;
        data["wasteAmount"] = this.wasteAmount;
        data["wasteAmount_unit"] = this.wasteAmount_unit;
        data["waste_activity"] = this.waste_activity;
        data["gas_type"] = this.gas_type;
        data["wasteBasis"] = this.wasteBasis;
        data["biologicalTreatmentSystem"] = this.biologicalTreatmentSystem;
        data["wasteCategory"] = this.wasteCategory;
        data["typeOfWaste"] = this.typeOfWaste;
        data["mswType"] = this.mswType;
        data["treatmentDischargeType"] = this.treatmentDischargeType;
        data["approach"] = this.approach;
        data["climateZone"] = this.climateZone;
        data["efType"] = this.efType;
        data["efCategory"] = this.efCategory;
        data["waste"] = this.waste;
        data["disposalMethod"] = this.disposalMethod;
        return data;
    }

    clone(): WasteData {
        const json = this.toJSON();
        let result = new WasteData();
        result.init(json);
        return result;
    }
}

export interface IWasteData {
    id: number;
    typeName: string;
    wasteType: string;
    wasteAmount: number;
    wasteAmount_unit: string;
    waste_activity: WasteDataWaste_activity;
    gas_type: string;
    wasteBasis: string;
    biologicalTreatmentSystem: string;
    wasteCategory: string;
    typeOfWaste: string;
    mswType: string;
    treatmentDischargeType: string;
    approach: string;
    climateZone: string;
    efType: string;
    efCategory: string;
    waste: string;
    disposalMethod: string;
}

export class WasteOtherData implements IWasteOtherData {
    id: number;
    typeName: string;
    otherEmission: number;
    otherEmission_unit: string;

    constructor(data?: IWasteOtherData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.otherEmission = _data["otherEmission"];
            this.otherEmission_unit = _data["otherEmission_unit"];
        }
    }

    static fromJS(data: any): WasteOtherData {
        data = typeof data === 'object' ? data : {};
        let result = new WasteOtherData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["otherEmission"] = this.otherEmission;
        data["otherEmission_unit"] = this.otherEmission_unit;
        return data;
    }

    clone(): WasteOtherData {
        const json = this.toJSON();
        let result = new WasteOtherData();
        result.init(json);
        return result;
    }
}

export interface IWasteOtherData {
    id: number;
    typeName: string;
    otherEmission: number;
    otherEmission_unit: string;
}

export class HybridMethod implements IHybridMethod {
    purchaseData: PurchaseData[];
    materialData: MaterialData[];
    materialTrasportData: MaterialTransportData[];
    wasteData: WasteData[];
    otherData: WasteOtherData[];

    constructor(data?: IHybridMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.purchaseData = [];
            this.materialData = [];
            this.materialTrasportData = [];
            this.wasteData = [];
            this.otherData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["purchaseData"])) {
                this.purchaseData = [] as any;
                for (let item of _data["purchaseData"])
                    this.purchaseData.push(PurchaseData.fromJS(item));
            }
            if (Array.isArray(_data["materialData"])) {
                this.materialData = [] as any;
                for (let item of _data["materialData"])
                    this.materialData.push(MaterialData.fromJS(item));
            }
            if (Array.isArray(_data["materialTrasportData"])) {
                this.materialTrasportData = [] as any;
                for (let item of _data["materialTrasportData"])
                    this.materialTrasportData.push(MaterialTransportData.fromJS(item));
            }
            if (Array.isArray(_data["wasteData"])) {
                this.wasteData = [] as any;
                for (let item of _data["wasteData"])
                    this.wasteData.push(WasteData.fromJS(item));
            }
            if (Array.isArray(_data["otherData"])) {
                this.otherData = [] as any;
                for (let item of _data["otherData"])
                    this.otherData.push(WasteOtherData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HybridMethod {
        data = typeof data === 'object' ? data : {};
        let result = new HybridMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.purchaseData)) {
            data["purchaseData"] = [];
            for (let item of this.purchaseData)
                data["purchaseData"].push(item.toJSON());
        }
        if (Array.isArray(this.materialData)) {
            data["materialData"] = [];
            for (let item of this.materialData)
                data["materialData"].push(item.toJSON());
        }
        if (Array.isArray(this.materialTrasportData)) {
            data["materialTrasportData"] = [];
            for (let item of this.materialTrasportData)
                data["materialTrasportData"].push(item.toJSON());
        }
        if (Array.isArray(this.wasteData)) {
            data["wasteData"] = [];
            for (let item of this.wasteData)
                data["wasteData"].push(item.toJSON());
        }
        if (Array.isArray(this.otherData)) {
            data["otherData"] = [];
            for (let item of this.otherData)
                data["otherData"].push(item.toJSON());
        }
        return data;
    }

    clone(): HybridMethod {
        const json = this.toJSON();
        let result = new HybridMethod();
        result.init(json);
        return result;
    }
}

export interface IHybridMethod {
    purchaseData: PurchaseData[];
    materialData: MaterialData[];
    materialTrasportData: MaterialTransportData[];
    wasteData: WasteData[];
    otherData: WasteOtherData[];
}

export class AverageData implements IAverageData {
    id: number;
    typeName: string;
    averageType: string;
    averageAmount: number;
    averageAmount_unit: string;
    averageEF: number;
    averageEF_unit: string;

    constructor(data?: IAverageData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.averageType = _data["averageType"];
            this.averageAmount = _data["averageAmount"];
            this.averageAmount_unit = _data["averageAmount_unit"];
            this.averageEF = _data["averageEF"];
            this.averageEF_unit = _data["averageEF_unit"];
        }
    }

    static fromJS(data: any): AverageData {
        data = typeof data === 'object' ? data : {};
        let result = new AverageData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["averageType"] = this.averageType;
        data["averageAmount"] = this.averageAmount;
        data["averageAmount_unit"] = this.averageAmount_unit;
        data["averageEF"] = this.averageEF;
        data["averageEF_unit"] = this.averageEF_unit;
        return data;
    }

    clone(): AverageData {
        const json = this.toJSON();
        let result = new AverageData();
        result.init(json);
        return result;
    }
}

export interface IAverageData {
    id: number;
    typeName: string;
    averageType: string;
    averageAmount: number;
    averageAmount_unit: string;
    averageEF: number;
    averageEF_unit: string;
}

export class AverageMethod implements IAverageMethod {
    averageData: AverageData[];

    constructor(data?: IAverageMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.averageData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["averageData"])) {
                this.averageData = [] as any;
                for (let item of _data["averageData"])
                    this.averageData.push(AverageData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AverageMethod {
        data = typeof data === 'object' ? data : {};
        let result = new AverageMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.averageData)) {
            data["averageData"] = [];
            for (let item of this.averageData)
                data["averageData"].push(item.toJSON());
        }
        return data;
    }

    clone(): AverageMethod {
        const json = this.toJSON();
        let result = new AverageMethod();
        result.init(json);
        return result;
    }
}

export interface IAverageMethod {
    averageData: AverageData[];
}

export class SpendData implements ISpendData {
    id: number;
    typeName: string;
    spendType: string;
    spendAmount: number;
    spendAmount_unit: string;
    spendEF: number;
    spendEF_unit: string;

    constructor(data?: ISpendData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.spendType = _data["spendType"];
            this.spendAmount = _data["spendAmount"];
            this.spendAmount_unit = _data["spendAmount_unit"];
            this.spendEF = _data["spendEF"];
            this.spendEF_unit = _data["spendEF_unit"];
        }
    }

    static fromJS(data: any): SpendData {
        data = typeof data === 'object' ? data : {};
        let result = new SpendData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["spendType"] = this.spendType;
        data["spendAmount"] = this.spendAmount;
        data["spendAmount_unit"] = this.spendAmount_unit;
        data["spendEF"] = this.spendEF;
        data["spendEF_unit"] = this.spendEF_unit;
        return data;
    }

    clone(): SpendData {
        const json = this.toJSON();
        let result = new SpendData();
        result.init(json);
        return result;
    }
}

export interface ISpendData {
    id: number;
    typeName: string;
    spendType: string;
    spendAmount: number;
    spendAmount_unit: string;
    spendEF: number;
    spendEF_unit: string;
}

export class SpendBasedMethod implements ISpendBasedMethod {
    spendData: SpendData[];

    constructor(data?: ISpendBasedMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.spendData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["spendData"])) {
                this.spendData = [] as any;
                for (let item of _data["spendData"])
                    this.spendData.push(SpendData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpendBasedMethod {
        data = typeof data === 'object' ? data : {};
        let result = new SpendBasedMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.spendData)) {
            data["spendData"] = [];
            for (let item of this.spendData)
                data["spendData"].push(item.toJSON());
        }
        return data;
    }

    clone(): SpendBasedMethod {
        const json = this.toJSON();
        let result = new SpendBasedMethod();
        result.init(json);
        return result;
    }
}

export interface ISpendBasedMethod {
    spendData: SpendData[];
}

export class CreatePurchasedGoodsAndServiceDto implements ICreatePurchasedGoodsAndServiceDto {
    month: number;
    year: number;
    method: CreatePurchasedGoodsAndServiceDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: CreatePurchasedGoodsAndServiceDtoActivityDataStatus;
    groupNo: string;
    supplierSpecificMethod: SupplierSpecificMethod;
    hybridMethod: HybridMethod;
    averageDataMethod: AverageMethod;
    spendBasedMethod: SpendBasedMethod;

    constructor(data?: ICreatePurchasedGoodsAndServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.supplierSpecificMethod = new SupplierSpecificMethod();
            this.hybridMethod = new HybridMethod();
            this.averageDataMethod = new AverageMethod();
            this.spendBasedMethod = new SpendBasedMethod();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.supplierSpecificMethod = _data["supplierSpecificMethod"] ? SupplierSpecificMethod.fromJS(_data["supplierSpecificMethod"]) : new SupplierSpecificMethod();
            this.hybridMethod = _data["hybridMethod"] ? HybridMethod.fromJS(_data["hybridMethod"]) : new HybridMethod();
            this.averageDataMethod = _data["averageDataMethod"] ? AverageMethod.fromJS(_data["averageDataMethod"]) : new AverageMethod();
            this.spendBasedMethod = _data["spendBasedMethod"] ? SpendBasedMethod.fromJS(_data["spendBasedMethod"]) : new SpendBasedMethod();
        }
    }

    static fromJS(data: any): CreatePurchasedGoodsAndServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchasedGoodsAndServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["supplierSpecificMethod"] = this.supplierSpecificMethod ? this.supplierSpecificMethod.toJSON() : <any>undefined;
        data["hybridMethod"] = this.hybridMethod ? this.hybridMethod.toJSON() : <any>undefined;
        data["averageDataMethod"] = this.averageDataMethod ? this.averageDataMethod.toJSON() : <any>undefined;
        data["spendBasedMethod"] = this.spendBasedMethod ? this.spendBasedMethod.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreatePurchasedGoodsAndServiceDto {
        const json = this.toJSON();
        let result = new CreatePurchasedGoodsAndServiceDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePurchasedGoodsAndServiceDto {
    month: number;
    year: number;
    method: CreatePurchasedGoodsAndServiceDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: CreatePurchasedGoodsAndServiceDtoActivityDataStatus;
    groupNo: string;
    supplierSpecificMethod: SupplierSpecificMethod;
    hybridMethod: HybridMethod;
    averageDataMethod: AverageMethod;
    spendBasedMethod: SpendBasedMethod;
}

export class GetManyPurchasedGoodsAndServicesActivityDataResponseDto implements IGetManyPurchasedGoodsAndServicesActivityDataResponseDto {
    data: PurchasedGoodsAndServicesActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPurchasedGoodsAndServicesActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PurchasedGoodsAndServicesActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPurchasedGoodsAndServicesActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPurchasedGoodsAndServicesActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyPurchasedGoodsAndServicesActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyPurchasedGoodsAndServicesActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPurchasedGoodsAndServicesActivityDataResponseDto {
    data: PurchasedGoodsAndServicesActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PurchasedGoodsAndServicesActivityData implements IPurchasedGoodsAndServicesActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    month: number;
    groupNo: string;
    mode: PurchasedGoodsAndServicesActivityDataMode;
    typeName: string;
    supplierType: string;
    supplierQuantity: number;
    supplierQuantity_unit: string;
    supplierEF: number;
    supplierEF_unit: string;
    purchaseEmission: number;
    purchaseType: string;
    purchaseEmission_unit: string;
    materialType: string;
    materialAmount: number;
    materialAmount_unit: string;
    materialEF: number;
    materialEF_unit: string;
    materialTransType: string;
    distance: number;
    distance_unit: string;
    materialTransAmount: number;
    materialTransAmount_unit: string;
    materialTransEF: number;
    materialTransEF_unit: string;
    otherEmission: number;
    otherEmission_unit: string;
    wasteType: string;
    wasteAmount: number;
    wasteAmount_unit: string;
    averageType: string;
    averageAmount: number;
    averageAmount_unit: string;
    averageEF: number;
    averageEF_unit: string;
    spendType: string;
    spendAmount: number;
    spendAmount_unit: string;
    spendEF: number;
    spendEF_unit: string;
    waste_activity: PurchasedGoodsAndServicesActivityDataWaste_activity;
    gas_type: string;
    wasteBasis: string;
    biologicalTreatmentSystem: string;
    wasteCategory: string;
    typeOfWaste: string;
    mswType: string;
    treatmentDischargeType: string;
    approach: string;
    climateZone: string;
    efType: string;
    efCategory: string;
    waste: string;
    disposalMethod: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PurchasedGoodsAndServicesActivityDataActivityDataStatus;

    constructor(data?: IPurchasedGoodsAndServicesActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.groupNo = _data["groupNo"];
            this.mode = _data["mode"];
            this.typeName = _data["typeName"];
            this.supplierType = _data["supplierType"];
            this.supplierQuantity = _data["supplierQuantity"];
            this.supplierQuantity_unit = _data["supplierQuantity_unit"];
            this.supplierEF = _data["supplierEF"];
            this.supplierEF_unit = _data["supplierEF_unit"];
            this.purchaseEmission = _data["purchaseEmission"];
            this.purchaseType = _data["purchaseType"];
            this.purchaseEmission_unit = _data["purchaseEmission_unit"];
            this.materialType = _data["materialType"];
            this.materialAmount = _data["materialAmount"];
            this.materialAmount_unit = _data["materialAmount_unit"];
            this.materialEF = _data["materialEF"];
            this.materialEF_unit = _data["materialEF_unit"];
            this.materialTransType = _data["materialTransType"];
            this.distance = _data["distance"];
            this.distance_unit = _data["distance_unit"];
            this.materialTransAmount = _data["materialTransAmount"];
            this.materialTransAmount_unit = _data["materialTransAmount_unit"];
            this.materialTransEF = _data["materialTransEF"];
            this.materialTransEF_unit = _data["materialTransEF_unit"];
            this.otherEmission = _data["otherEmission"];
            this.otherEmission_unit = _data["otherEmission_unit"];
            this.wasteType = _data["wasteType"];
            this.wasteAmount = _data["wasteAmount"];
            this.wasteAmount_unit = _data["wasteAmount_unit"];
            this.averageType = _data["averageType"];
            this.averageAmount = _data["averageAmount"];
            this.averageAmount_unit = _data["averageAmount_unit"];
            this.averageEF = _data["averageEF"];
            this.averageEF_unit = _data["averageEF_unit"];
            this.spendType = _data["spendType"];
            this.spendAmount = _data["spendAmount"];
            this.spendAmount_unit = _data["spendAmount_unit"];
            this.spendEF = _data["spendEF"];
            this.spendEF_unit = _data["spendEF_unit"];
            this.waste_activity = _data["waste_activity"];
            this.gas_type = _data["gas_type"];
            this.wasteBasis = _data["wasteBasis"];
            this.biologicalTreatmentSystem = _data["biologicalTreatmentSystem"];
            this.wasteCategory = _data["wasteCategory"];
            this.typeOfWaste = _data["typeOfWaste"];
            this.mswType = _data["mswType"];
            this.treatmentDischargeType = _data["treatmentDischargeType"];
            this.approach = _data["approach"];
            this.climateZone = _data["climateZone"];
            this.efType = _data["efType"];
            this.efCategory = _data["efCategory"];
            this.waste = _data["waste"];
            this.disposalMethod = _data["disposalMethod"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): PurchasedGoodsAndServicesActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new PurchasedGoodsAndServicesActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["month"] = this.month;
        data["groupNo"] = this.groupNo;
        data["mode"] = this.mode;
        data["typeName"] = this.typeName;
        data["supplierType"] = this.supplierType;
        data["supplierQuantity"] = this.supplierQuantity;
        data["supplierQuantity_unit"] = this.supplierQuantity_unit;
        data["supplierEF"] = this.supplierEF;
        data["supplierEF_unit"] = this.supplierEF_unit;
        data["purchaseEmission"] = this.purchaseEmission;
        data["purchaseType"] = this.purchaseType;
        data["purchaseEmission_unit"] = this.purchaseEmission_unit;
        data["materialType"] = this.materialType;
        data["materialAmount"] = this.materialAmount;
        data["materialAmount_unit"] = this.materialAmount_unit;
        data["materialEF"] = this.materialEF;
        data["materialEF_unit"] = this.materialEF_unit;
        data["materialTransType"] = this.materialTransType;
        data["distance"] = this.distance;
        data["distance_unit"] = this.distance_unit;
        data["materialTransAmount"] = this.materialTransAmount;
        data["materialTransAmount_unit"] = this.materialTransAmount_unit;
        data["materialTransEF"] = this.materialTransEF;
        data["materialTransEF_unit"] = this.materialTransEF_unit;
        data["otherEmission"] = this.otherEmission;
        data["otherEmission_unit"] = this.otherEmission_unit;
        data["wasteType"] = this.wasteType;
        data["wasteAmount"] = this.wasteAmount;
        data["wasteAmount_unit"] = this.wasteAmount_unit;
        data["averageType"] = this.averageType;
        data["averageAmount"] = this.averageAmount;
        data["averageAmount_unit"] = this.averageAmount_unit;
        data["averageEF"] = this.averageEF;
        data["averageEF_unit"] = this.averageEF_unit;
        data["spendType"] = this.spendType;
        data["spendAmount"] = this.spendAmount;
        data["spendAmount_unit"] = this.spendAmount_unit;
        data["spendEF"] = this.spendEF;
        data["spendEF_unit"] = this.spendEF_unit;
        data["waste_activity"] = this.waste_activity;
        data["gas_type"] = this.gas_type;
        data["wasteBasis"] = this.wasteBasis;
        data["biologicalTreatmentSystem"] = this.biologicalTreatmentSystem;
        data["wasteCategory"] = this.wasteCategory;
        data["typeOfWaste"] = this.typeOfWaste;
        data["mswType"] = this.mswType;
        data["treatmentDischargeType"] = this.treatmentDischargeType;
        data["approach"] = this.approach;
        data["climateZone"] = this.climateZone;
        data["efType"] = this.efType;
        data["efCategory"] = this.efCategory;
        data["waste"] = this.waste;
        data["disposalMethod"] = this.disposalMethod;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): PurchasedGoodsAndServicesActivityData {
        const json = this.toJSON();
        let result = new PurchasedGoodsAndServicesActivityData();
        result.init(json);
        return result;
    }
}

export interface IPurchasedGoodsAndServicesActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    month: number;
    groupNo: string;
    mode: PurchasedGoodsAndServicesActivityDataMode;
    typeName: string;
    supplierType: string;
    supplierQuantity: number;
    supplierQuantity_unit: string;
    supplierEF: number;
    supplierEF_unit: string;
    purchaseEmission: number;
    purchaseType: string;
    purchaseEmission_unit: string;
    materialType: string;
    materialAmount: number;
    materialAmount_unit: string;
    materialEF: number;
    materialEF_unit: string;
    materialTransType: string;
    distance: number;
    distance_unit: string;
    materialTransAmount: number;
    materialTransAmount_unit: string;
    materialTransEF: number;
    materialTransEF_unit: string;
    otherEmission: number;
    otherEmission_unit: string;
    wasteType: string;
    wasteAmount: number;
    wasteAmount_unit: string;
    averageType: string;
    averageAmount: number;
    averageAmount_unit: string;
    averageEF: number;
    averageEF_unit: string;
    spendType: string;
    spendAmount: number;
    spendAmount_unit: string;
    spendEF: number;
    spendEF_unit: string;
    waste_activity: PurchasedGoodsAndServicesActivityDataWaste_activity;
    gas_type: string;
    wasteBasis: string;
    biologicalTreatmentSystem: string;
    wasteCategory: string;
    typeOfWaste: string;
    mswType: string;
    treatmentDischargeType: string;
    approach: string;
    climateZone: string;
    efType: string;
    efCategory: string;
    waste: string;
    disposalMethod: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: PurchasedGoodsAndServicesActivityDataActivityDataStatus;
}

export class CreateManyPurchasedGoodsAndServicesActivityDataDto implements ICreateManyPurchasedGoodsAndServicesActivityDataDto {
    bulk: PurchasedGoodsAndServicesActivityData[];

    constructor(data?: ICreateManyPurchasedGoodsAndServicesActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PurchasedGoodsAndServicesActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPurchasedGoodsAndServicesActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPurchasedGoodsAndServicesActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyPurchasedGoodsAndServicesActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyPurchasedGoodsAndServicesActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPurchasedGoodsAndServicesActivityDataDto {
    bulk: PurchasedGoodsAndServicesActivityData[];
}

export class ScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData implements IScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData {
    id: number;
    company: string;
    scpoeOne: number;
    scpoeOne_unit: string;
    scpoeTwo: number;
    scpoeTwo_unit: string;

    constructor(data?: IScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company = _data["company"];
            this.scpoeOne = _data["scpoeOne"];
            this.scpoeOne_unit = _data["scpoeOne_unit"];
            this.scpoeTwo = _data["scpoeTwo"];
            this.scpoeTwo_unit = _data["scpoeTwo_unit"];
        }
    }

    static fromJS(data: any): ScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new ScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company;
        data["scpoeOne"] = this.scpoeOne;
        data["scpoeOne_unit"] = this.scpoeOne_unit;
        data["scpoeTwo"] = this.scpoeTwo;
        data["scpoeTwo_unit"] = this.scpoeTwo_unit;
        return data;
    }

    clone(): ScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData {
        const json = this.toJSON();
        let result = new ScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData {
    id: number;
    company: string;
    scpoeOne: number;
    scpoeOne_unit: string;
    scpoeTwo: number;
    scpoeTwo_unit: string;
}

export class SupplierSpecificWasteGeneratedInOperationsEmissionSourceData implements ISupplierSpecificWasteGeneratedInOperationsEmissionSourceData {
    scope_data: ScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData[];

    constructor(data?: ISupplierSpecificWasteGeneratedInOperationsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scope_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["scope_data"])) {
                this.scope_data = [] as any;
                for (let item of _data["scope_data"])
                    this.scope_data.push(ScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SupplierSpecificWasteGeneratedInOperationsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierSpecificWasteGeneratedInOperationsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.scope_data)) {
            data["scope_data"] = [];
            for (let item of this.scope_data)
                data["scope_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): SupplierSpecificWasteGeneratedInOperationsEmissionSourceData {
        const json = this.toJSON();
        let result = new SupplierSpecificWasteGeneratedInOperationsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface ISupplierSpecificWasteGeneratedInOperationsEmissionSourceData {
    scope_data: ScopeSupplierSpecificWasteGeneratedInOperationsEmissionSourceData[];
}

export class WasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData implements IWasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData {
    id: number;
    wasteType: string;
    disposalType: string;
    treatmentMethod: string;
    wasteTypeEF: number;
    wasteProdused: number;
    wasteProdused_unit: string;

    constructor(data?: IWasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.wasteType = _data["wasteType"];
            this.disposalType = _data["disposalType"];
            this.treatmentMethod = _data["treatmentMethod"];
            this.wasteTypeEF = _data["wasteTypeEF"];
            this.wasteProdused = _data["wasteProdused"];
            this.wasteProdused_unit = _data["wasteProdused_unit"];
        }
    }

    static fromJS(data: any): WasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new WasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wasteType"] = this.wasteType;
        data["disposalType"] = this.disposalType;
        data["treatmentMethod"] = this.treatmentMethod;
        data["wasteTypeEF"] = this.wasteTypeEF;
        data["wasteProdused"] = this.wasteProdused;
        data["wasteProdused_unit"] = this.wasteProdused_unit;
        return data;
    }

    clone(): WasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData {
        const json = this.toJSON();
        let result = new WasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IWasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData {
    id: number;
    wasteType: string;
    disposalType: string;
    treatmentMethod: string;
    wasteTypeEF: number;
    wasteProdused: number;
    wasteProdused_unit: string;
}

export class WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData implements IWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData {
    solid_or_water: WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceDataSolid_or_water;
    waste_data: WasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData[];

    constructor(data?: IWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.waste_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.solid_or_water = _data["solid_or_water"];
            if (Array.isArray(_data["waste_data"])) {
                this.waste_data = [] as any;
                for (let item of _data["waste_data"])
                    this.waste_data.push(WasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["solid_or_water"] = this.solid_or_water;
        if (Array.isArray(this.waste_data)) {
            data["waste_data"] = [];
            for (let item of this.waste_data)
                data["waste_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData {
        const json = this.toJSON();
        let result = new WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData {
    solid_or_water: WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceDataSolid_or_water;
    waste_data: WasteWasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData[];
}

export class WasteAverageDataWasteGeneratedInOperationsEmissionSourceData implements IWasteAverageDataWasteGeneratedInOperationsEmissionSourceData {
    id: number;
    treatmentMethod: string;
    treatmentMethodEF: number;
    massOfWaste: number;
    massOfWaste_unit: string;
    proportionOfWaste: number;

    constructor(data?: IWasteAverageDataWasteGeneratedInOperationsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.treatmentMethod = _data["treatmentMethod"];
            this.treatmentMethodEF = _data["treatmentMethodEF"];
            this.massOfWaste = _data["massOfWaste"];
            this.massOfWaste_unit = _data["massOfWaste_unit"];
            this.proportionOfWaste = _data["proportionOfWaste"];
        }
    }

    static fromJS(data: any): WasteAverageDataWasteGeneratedInOperationsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new WasteAverageDataWasteGeneratedInOperationsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["treatmentMethod"] = this.treatmentMethod;
        data["treatmentMethodEF"] = this.treatmentMethodEF;
        data["massOfWaste"] = this.massOfWaste;
        data["massOfWaste_unit"] = this.massOfWaste_unit;
        data["proportionOfWaste"] = this.proportionOfWaste;
        return data;
    }

    clone(): WasteAverageDataWasteGeneratedInOperationsEmissionSourceData {
        const json = this.toJSON();
        let result = new WasteAverageDataWasteGeneratedInOperationsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IWasteAverageDataWasteGeneratedInOperationsEmissionSourceData {
    id: number;
    treatmentMethod: string;
    treatmentMethodEF: number;
    massOfWaste: number;
    massOfWaste_unit: string;
    proportionOfWaste: number;
}

export class AverageDataWasteGeneratedInOperationsEmissionSourceData implements IAverageDataWasteGeneratedInOperationsEmissionSourceData {
    waste_data: WasteAverageDataWasteGeneratedInOperationsEmissionSourceData[];

    constructor(data?: IAverageDataWasteGeneratedInOperationsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.waste_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["waste_data"])) {
                this.waste_data = [] as any;
                for (let item of _data["waste_data"])
                    this.waste_data.push(WasteAverageDataWasteGeneratedInOperationsEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AverageDataWasteGeneratedInOperationsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new AverageDataWasteGeneratedInOperationsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.waste_data)) {
            data["waste_data"] = [];
            for (let item of this.waste_data)
                data["waste_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): AverageDataWasteGeneratedInOperationsEmissionSourceData {
        const json = this.toJSON();
        let result = new AverageDataWasteGeneratedInOperationsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IAverageDataWasteGeneratedInOperationsEmissionSourceData {
    waste_data: WasteAverageDataWasteGeneratedInOperationsEmissionSourceData[];
}

export class WasteGeneratedInOperationsActivityDataDto implements IWasteGeneratedInOperationsActivityDataDto {
    month: number;
    year: number;
    method: WasteGeneratedInOperationsActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WasteGeneratedInOperationsActivityDataDtoActivityDataStatus;
    groupNo: string;
    supplier_specific_emission_source_data: SupplierSpecificWasteGeneratedInOperationsEmissionSourceData;
    waste_type_specific_emission_source_data: WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData;
    average_data_emission_source_data: AverageDataWasteGeneratedInOperationsEmissionSourceData;

    constructor(data?: IWasteGeneratedInOperationsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.supplier_specific_emission_source_data = new SupplierSpecificWasteGeneratedInOperationsEmissionSourceData();
            this.waste_type_specific_emission_source_data = new WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData();
            this.average_data_emission_source_data = new AverageDataWasteGeneratedInOperationsEmissionSourceData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.supplier_specific_emission_source_data = _data["supplier_specific_emission_source_data"] ? SupplierSpecificWasteGeneratedInOperationsEmissionSourceData.fromJS(_data["supplier_specific_emission_source_data"]) : new SupplierSpecificWasteGeneratedInOperationsEmissionSourceData();
            this.waste_type_specific_emission_source_data = _data["waste_type_specific_emission_source_data"] ? WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData.fromJS(_data["waste_type_specific_emission_source_data"]) : new WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData();
            this.average_data_emission_source_data = _data["average_data_emission_source_data"] ? AverageDataWasteGeneratedInOperationsEmissionSourceData.fromJS(_data["average_data_emission_source_data"]) : new AverageDataWasteGeneratedInOperationsEmissionSourceData();
        }
    }

    static fromJS(data: any): WasteGeneratedInOperationsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new WasteGeneratedInOperationsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["supplier_specific_emission_source_data"] = this.supplier_specific_emission_source_data ? this.supplier_specific_emission_source_data.toJSON() : <any>undefined;
        data["waste_type_specific_emission_source_data"] = this.waste_type_specific_emission_source_data ? this.waste_type_specific_emission_source_data.toJSON() : <any>undefined;
        data["average_data_emission_source_data"] = this.average_data_emission_source_data ? this.average_data_emission_source_data.toJSON() : <any>undefined;
        return data;
    }

    clone(): WasteGeneratedInOperationsActivityDataDto {
        const json = this.toJSON();
        let result = new WasteGeneratedInOperationsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IWasteGeneratedInOperationsActivityDataDto {
    month: number;
    year: number;
    method: WasteGeneratedInOperationsActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WasteGeneratedInOperationsActivityDataDtoActivityDataStatus;
    groupNo: string;
    supplier_specific_emission_source_data: SupplierSpecificWasteGeneratedInOperationsEmissionSourceData;
    waste_type_specific_emission_source_data: WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceData;
    average_data_emission_source_data: AverageDataWasteGeneratedInOperationsEmissionSourceData;
}

export class GetManyWasteGeneratedInOperationsActivityDataResponseDto implements IGetManyWasteGeneratedInOperationsActivityDataResponseDto {
    data: WasteGeneratedInOperationsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyWasteGeneratedInOperationsActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(WasteGeneratedInOperationsActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyWasteGeneratedInOperationsActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyWasteGeneratedInOperationsActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyWasteGeneratedInOperationsActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyWasteGeneratedInOperationsActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyWasteGeneratedInOperationsActivityDataResponseDto {
    data: WasteGeneratedInOperationsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class WasteGeneratedInOperationsActivityData implements IWasteGeneratedInOperationsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: WasteGeneratedInOperationsActivityDataMethod;
    company: string;
    scpoeOne: number;
    scpoeOne_unit: string;
    scpoeTwo: number;
    scpoeTwo_unit: string;
    solid_or_water: WasteGeneratedInOperationsActivityDataSolid_or_water;
    wasteType: string;
    disposalType: string;
    wasteProdused: number;
    wasteProdused_unit: string;
    treatmentMethod: string;
    massOfWaste: number;
    massOfWaste_unit: string;
    proportionOfWaste: number;
    emission: number;
    user_input_ef: any;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WasteGeneratedInOperationsActivityDataActivityDataStatus;

    constructor(data?: IWasteGeneratedInOperationsActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.company = _data["company"];
            this.scpoeOne = _data["scpoeOne"];
            this.scpoeOne_unit = _data["scpoeOne_unit"];
            this.scpoeTwo = _data["scpoeTwo"];
            this.scpoeTwo_unit = _data["scpoeTwo_unit"];
            this.solid_or_water = _data["solid_or_water"];
            this.wasteType = _data["wasteType"];
            this.disposalType = _data["disposalType"];
            this.wasteProdused = _data["wasteProdused"];
            this.wasteProdused_unit = _data["wasteProdused_unit"];
            this.treatmentMethod = _data["treatmentMethod"];
            this.massOfWaste = _data["massOfWaste"];
            this.massOfWaste_unit = _data["massOfWaste_unit"];
            this.proportionOfWaste = _data["proportionOfWaste"];
            this.emission = _data["emission"];
            this.user_input_ef = _data["user_input_ef"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): WasteGeneratedInOperationsActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new WasteGeneratedInOperationsActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["company"] = this.company;
        data["scpoeOne"] = this.scpoeOne;
        data["scpoeOne_unit"] = this.scpoeOne_unit;
        data["scpoeTwo"] = this.scpoeTwo;
        data["scpoeTwo_unit"] = this.scpoeTwo_unit;
        data["solid_or_water"] = this.solid_or_water;
        data["wasteType"] = this.wasteType;
        data["disposalType"] = this.disposalType;
        data["wasteProdused"] = this.wasteProdused;
        data["wasteProdused_unit"] = this.wasteProdused_unit;
        data["treatmentMethod"] = this.treatmentMethod;
        data["massOfWaste"] = this.massOfWaste;
        data["massOfWaste_unit"] = this.massOfWaste_unit;
        data["proportionOfWaste"] = this.proportionOfWaste;
        data["emission"] = this.emission;
        data["user_input_ef"] = this.user_input_ef;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): WasteGeneratedInOperationsActivityData {
        const json = this.toJSON();
        let result = new WasteGeneratedInOperationsActivityData();
        result.init(json);
        return result;
    }
}

export interface IWasteGeneratedInOperationsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: WasteGeneratedInOperationsActivityDataMethod;
    company: string;
    scpoeOne: number;
    scpoeOne_unit: string;
    scpoeTwo: number;
    scpoeTwo_unit: string;
    solid_or_water: WasteGeneratedInOperationsActivityDataSolid_or_water;
    wasteType: string;
    disposalType: string;
    wasteProdused: number;
    wasteProdused_unit: string;
    treatmentMethod: string;
    massOfWaste: number;
    massOfWaste_unit: string;
    proportionOfWaste: number;
    emission: number;
    user_input_ef: any;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: WasteGeneratedInOperationsActivityDataActivityDataStatus;
}

export class CreateManyWasteGeneratedInOperationsActivityDataDto implements ICreateManyWasteGeneratedInOperationsActivityDataDto {
    bulk: WasteGeneratedInOperationsActivityData[];

    constructor(data?: ICreateManyWasteGeneratedInOperationsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(WasteGeneratedInOperationsActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyWasteGeneratedInOperationsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyWasteGeneratedInOperationsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyWasteGeneratedInOperationsActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyWasteGeneratedInOperationsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyWasteGeneratedInOperationsActivityDataDto {
    bulk: WasteGeneratedInOperationsActivityData[];
}

export class FuelBsedData implements IFuelBsedData {
    id: number;
    fuelType: string | undefined;
    consumption: number | undefined;
    consumption_unit: string;
    user_input_ef: number | undefined;

    constructor(data?: IFuelBsedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fuelType = _data["fuelType"];
            this.consumption = _data["consumption"];
            this.consumption_unit = _data["consumption_unit"];
            this.user_input_ef = _data["user_input_ef"];
        }
    }

    static fromJS(data: any): FuelBsedData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelBsedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fuelType"] = this.fuelType;
        data["consumption"] = this.consumption;
        data["consumption_unit"] = this.consumption_unit;
        data["user_input_ef"] = this.user_input_ef;
        return data;
    }

    clone(): FuelBsedData {
        const json = this.toJSON();
        let result = new FuelBsedData();
        result.init(json);
        return result;
    }
}

export interface IFuelBsedData {
    id: number;
    fuelType: string | undefined;
    consumption: number | undefined;
    consumption_unit: string;
    user_input_ef: number | undefined;
}

export class ElecBasedData implements IElecBasedData {
    id: number;
    fuelType: string | undefined;
    consumption: number | undefined;
    consumption_unit: string;
    user_input_ef: number | undefined;

    constructor(data?: IElecBasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fuelType = _data["fuelType"];
            this.consumption = _data["consumption"];
            this.consumption_unit = _data["consumption_unit"];
            this.user_input_ef = _data["user_input_ef"];
        }
    }

    static fromJS(data: any): ElecBasedData {
        data = typeof data === 'object' ? data : {};
        let result = new ElecBasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fuelType"] = this.fuelType;
        data["consumption"] = this.consumption;
        data["consumption_unit"] = this.consumption_unit;
        data["user_input_ef"] = this.user_input_ef;
        return data;
    }

    clone(): ElecBasedData {
        const json = this.toJSON();
        let result = new ElecBasedData();
        result.init(json);
        return result;
    }
}

export interface IElecBasedData {
    id: number;
    fuelType: string | undefined;
    consumption: number | undefined;
    consumption_unit: string;
    user_input_ef: number | undefined;
}

export class TanddBasedData implements ITanddBasedData {
    id: number;
    fuelType: string | undefined;
    consumption: number | undefined;
    consumption_unit: string;
    user_input_ef: number | undefined;

    constructor(data?: ITanddBasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fuelType = _data["fuelType"];
            this.consumption = _data["consumption"];
            this.consumption_unit = _data["consumption_unit"];
            this.user_input_ef = _data["user_input_ef"];
        }
    }

    static fromJS(data: any): TanddBasedData {
        data = typeof data === 'object' ? data : {};
        let result = new TanddBasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fuelType"] = this.fuelType;
        data["consumption"] = this.consumption;
        data["consumption_unit"] = this.consumption_unit;
        data["user_input_ef"] = this.user_input_ef;
        return data;
    }

    clone(): TanddBasedData {
        const json = this.toJSON();
        let result = new TanddBasedData();
        result.init(json);
        return result;
    }
}

export interface ITanddBasedData {
    id: number;
    fuelType: string | undefined;
    consumption: number | undefined;
    consumption_unit: string;
    user_input_ef: number | undefined;
}

export class PurchsoldBasedData implements IPurchsoldBasedData {
    id: number;
    fuelType: string | undefined;
    consumption: number | undefined;
    consumption_unit: string;
    user_input_ef: number | undefined;

    constructor(data?: IPurchsoldBasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fuelType = _data["fuelType"];
            this.consumption = _data["consumption"];
            this.consumption_unit = _data["consumption_unit"];
            this.user_input_ef = _data["user_input_ef"];
        }
    }

    static fromJS(data: any): PurchsoldBasedData {
        data = typeof data === 'object' ? data : {};
        let result = new PurchsoldBasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fuelType"] = this.fuelType;
        data["consumption"] = this.consumption;
        data["consumption_unit"] = this.consumption_unit;
        data["user_input_ef"] = this.user_input_ef;
        return data;
    }

    clone(): PurchsoldBasedData {
        const json = this.toJSON();
        let result = new PurchsoldBasedData();
        result.init(json);
        return result;
    }
}

export interface IPurchsoldBasedData {
    id: number;
    fuelType: string | undefined;
    consumption: number | undefined;
    consumption_unit: string;
    user_input_ef: number | undefined;
}

export class FuelEnergyRelatedActivitiesActivityDataDto implements IFuelEnergyRelatedActivitiesActivityDataDto {
    month: number;
    year: number;
    activityType: string;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    groupNo: string;
    methodA_data: FuelBsedData[];
    methodB_data: ElecBasedData[];
    methodC_data: TanddBasedData[];
    methodD_data: PurchsoldBasedData[];

    constructor(data?: IFuelEnergyRelatedActivitiesActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.methodA_data = [];
            this.methodB_data = [];
            this.methodC_data = [];
            this.methodD_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.activityType = _data["activityType"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.groupNo = _data["groupNo"];
            if (Array.isArray(_data["methodA_data"])) {
                this.methodA_data = [] as any;
                for (let item of _data["methodA_data"])
                    this.methodA_data.push(FuelBsedData.fromJS(item));
            }
            if (Array.isArray(_data["methodB_data"])) {
                this.methodB_data = [] as any;
                for (let item of _data["methodB_data"])
                    this.methodB_data.push(ElecBasedData.fromJS(item));
            }
            if (Array.isArray(_data["methodC_data"])) {
                this.methodC_data = [] as any;
                for (let item of _data["methodC_data"])
                    this.methodC_data.push(TanddBasedData.fromJS(item));
            }
            if (Array.isArray(_data["methodD_data"])) {
                this.methodD_data = [] as any;
                for (let item of _data["methodD_data"])
                    this.methodD_data.push(PurchsoldBasedData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FuelEnergyRelatedActivitiesActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FuelEnergyRelatedActivitiesActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["activityType"] = this.activityType;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["groupNo"] = this.groupNo;
        if (Array.isArray(this.methodA_data)) {
            data["methodA_data"] = [];
            for (let item of this.methodA_data)
                data["methodA_data"].push(item.toJSON());
        }
        if (Array.isArray(this.methodB_data)) {
            data["methodB_data"] = [];
            for (let item of this.methodB_data)
                data["methodB_data"].push(item.toJSON());
        }
        if (Array.isArray(this.methodC_data)) {
            data["methodC_data"] = [];
            for (let item of this.methodC_data)
                data["methodC_data"].push(item.toJSON());
        }
        if (Array.isArray(this.methodD_data)) {
            data["methodD_data"] = [];
            for (let item of this.methodD_data)
                data["methodD_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): FuelEnergyRelatedActivitiesActivityDataDto {
        const json = this.toJSON();
        let result = new FuelEnergyRelatedActivitiesActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IFuelEnergyRelatedActivitiesActivityDataDto {
    month: number;
    year: number;
    activityType: string;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    groupNo: string;
    methodA_data: FuelBsedData[];
    methodB_data: ElecBasedData[];
    methodC_data: TanddBasedData[];
    methodD_data: PurchsoldBasedData[];
}

export class GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto implements IGetManyFuelEnergyRelatedActivitiesActivityDataResponseDto {
    data: FuelEnergyRelatedActivitiesActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFuelEnergyRelatedActivitiesActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FuelEnergyRelatedActivitiesActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyFuelEnergyRelatedActivitiesActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFuelEnergyRelatedActivitiesActivityDataResponseDto {
    data: FuelEnergyRelatedActivitiesActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class FuelEnergyRelatedActivitiesActivityData implements IFuelEnergyRelatedActivitiesActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    fuelType: string;
    month: number;
    year: number;
    activityType: string;
    groupNo: string;
    consumption: number;
    consumption_unit: string;
    emission: number;
    user_input_ef: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FuelEnergyRelatedActivitiesActivityDataActivityDataStatus;

    constructor(data?: IFuelEnergyRelatedActivitiesActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.fuelType = _data["fuelType"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.activityType = _data["activityType"];
            this.groupNo = _data["groupNo"];
            this.consumption = _data["consumption"];
            this.consumption_unit = _data["consumption_unit"];
            this.emission = _data["emission"];
            this.user_input_ef = _data["user_input_ef"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): FuelEnergyRelatedActivitiesActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelEnergyRelatedActivitiesActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["fuelType"] = this.fuelType;
        data["month"] = this.month;
        data["year"] = this.year;
        data["activityType"] = this.activityType;
        data["groupNo"] = this.groupNo;
        data["consumption"] = this.consumption;
        data["consumption_unit"] = this.consumption_unit;
        data["emission"] = this.emission;
        data["user_input_ef"] = this.user_input_ef;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): FuelEnergyRelatedActivitiesActivityData {
        const json = this.toJSON();
        let result = new FuelEnergyRelatedActivitiesActivityData();
        result.init(json);
        return result;
    }
}

export interface IFuelEnergyRelatedActivitiesActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    fuelType: string;
    month: number;
    year: number;
    activityType: string;
    groupNo: string;
    consumption: number;
    consumption_unit: string;
    emission: number;
    user_input_ef: number;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FuelEnergyRelatedActivitiesActivityDataActivityDataStatus;
}

export class CreateManyFuelEnergyRelatedActivitiesActivityDataDto implements ICreateManyFuelEnergyRelatedActivitiesActivityDataDto {
    bulk: FuelEnergyRelatedActivitiesActivityData[];

    constructor(data?: ICreateManyFuelEnergyRelatedActivitiesActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FuelEnergyRelatedActivitiesActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFuelEnergyRelatedActivitiesActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFuelEnergyRelatedActivitiesActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFuelEnergyRelatedActivitiesActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyFuelEnergyRelatedActivitiesActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFuelEnergyRelatedActivitiesActivityDataDto {
    bulk: FuelEnergyRelatedActivitiesActivityData[];
}

export class MethodABasedData implements IMethodABasedData {
    id: number;
    scp1scpe2EmissionsOfEquityInvestment: number | undefined;
    shareOfEquity: number | undefined;
    scp1scpe2EmissionsOfEquityInvestment_unit: string;

    constructor(data?: IMethodABasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.scp1scpe2EmissionsOfEquityInvestment = _data["scp1scpe2EmissionsOfEquityInvestment"];
            this.shareOfEquity = _data["shareOfEquity"];
            this.scp1scpe2EmissionsOfEquityInvestment_unit = _data["scp1scpe2EmissionsOfEquityInvestment_unit"];
        }
    }

    static fromJS(data: any): MethodABasedData {
        data = typeof data === 'object' ? data : {};
        let result = new MethodABasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["scp1scpe2EmissionsOfEquityInvestment"] = this.scp1scpe2EmissionsOfEquityInvestment;
        data["shareOfEquity"] = this.shareOfEquity;
        data["scp1scpe2EmissionsOfEquityInvestment_unit"] = this.scp1scpe2EmissionsOfEquityInvestment_unit;
        return data;
    }

    clone(): MethodABasedData {
        const json = this.toJSON();
        let result = new MethodABasedData();
        result.init(json);
        return result;
    }
}

export interface IMethodABasedData {
    id: number;
    scp1scpe2EmissionsOfEquityInvestment: number | undefined;
    shareOfEquity: number | undefined;
    scp1scpe2EmissionsOfEquityInvestment_unit: string;
}

export class MethodBBasedData implements IMethodBBasedData {
    id: number;
    investeeCompanyTotalRevenue: number | undefined;
    ef_InvesteeSector: number | undefined;
    shareOfEquity: number | undefined;
    investeeSector: any;

    constructor(data?: IMethodBBasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.investeeCompanyTotalRevenue = _data["investeeCompanyTotalRevenue"];
            this.ef_InvesteeSector = _data["ef_InvesteeSector"];
            this.shareOfEquity = _data["shareOfEquity"];
            this.investeeSector = _data["investeeSector"];
        }
    }

    static fromJS(data: any): MethodBBasedData {
        data = typeof data === 'object' ? data : {};
        let result = new MethodBBasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["investeeCompanyTotalRevenue"] = this.investeeCompanyTotalRevenue;
        data["ef_InvesteeSector"] = this.ef_InvesteeSector;
        data["shareOfEquity"] = this.shareOfEquity;
        data["investeeSector"] = this.investeeSector;
        return data;
    }

    clone(): MethodBBasedData {
        const json = this.toJSON();
        let result = new MethodBBasedData();
        result.init(json);
        return result;
    }
}

export interface IMethodBBasedData {
    id: number;
    investeeCompanyTotalRevenue: number | undefined;
    ef_InvesteeSector: number | undefined;
    shareOfEquity: number | undefined;
    investeeSector: any;
}

export class MethodCBasedData implements IMethodCBasedData {
    id: number;
    scp1scp2EmissionRelevantProject: number | undefined;
    shareOfTotalProjectCosts: number | undefined;
    scp1scp2EmissionRelevantProject_unit: string;

    constructor(data?: IMethodCBasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.scp1scp2EmissionRelevantProject = _data["scp1scp2EmissionRelevantProject"];
            this.shareOfTotalProjectCosts = _data["shareOfTotalProjectCosts"];
            this.scp1scp2EmissionRelevantProject_unit = _data["scp1scp2EmissionRelevantProject_unit"];
        }
    }

    static fromJS(data: any): MethodCBasedData {
        data = typeof data === 'object' ? data : {};
        let result = new MethodCBasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["scp1scp2EmissionRelevantProject"] = this.scp1scp2EmissionRelevantProject;
        data["shareOfTotalProjectCosts"] = this.shareOfTotalProjectCosts;
        data["scp1scp2EmissionRelevantProject_unit"] = this.scp1scp2EmissionRelevantProject_unit;
        return data;
    }

    clone(): MethodCBasedData {
        const json = this.toJSON();
        let result = new MethodCBasedData();
        result.init(json);
        return result;
    }
}

export interface IMethodCBasedData {
    id: number;
    scp1scp2EmissionRelevantProject: number | undefined;
    shareOfTotalProjectCosts: number | undefined;
    scp1scp2EmissionRelevantProject_unit: string;
}

export class MethodDBasedData implements IMethodDBasedData {
    id: number;
    projectConstructionCost: number | undefined;
    ef_ReleventConsSector: number | undefined;
    shareOfTotalProjectCosts: number | undefined;
    projectRevenueInReportingYear: number | undefined;
    ef_relevantOperatingSector: number | undefined;
    constructSector: string;
    operatingtSector: string;

    constructor(data?: IMethodDBasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectConstructionCost = _data["projectConstructionCost"];
            this.ef_ReleventConsSector = _data["ef_ReleventConsSector"];
            this.shareOfTotalProjectCosts = _data["shareOfTotalProjectCosts"];
            this.projectRevenueInReportingYear = _data["projectRevenueInReportingYear"];
            this.ef_relevantOperatingSector = _data["ef_relevantOperatingSector"];
            this.constructSector = _data["constructSector"];
            this.operatingtSector = _data["operatingtSector"];
        }
    }

    static fromJS(data: any): MethodDBasedData {
        data = typeof data === 'object' ? data : {};
        let result = new MethodDBasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectConstructionCost"] = this.projectConstructionCost;
        data["ef_ReleventConsSector"] = this.ef_ReleventConsSector;
        data["shareOfTotalProjectCosts"] = this.shareOfTotalProjectCosts;
        data["projectRevenueInReportingYear"] = this.projectRevenueInReportingYear;
        data["ef_relevantOperatingSector"] = this.ef_relevantOperatingSector;
        data["constructSector"] = this.constructSector;
        data["operatingtSector"] = this.operatingtSector;
        return data;
    }

    clone(): MethodDBasedData {
        const json = this.toJSON();
        let result = new MethodDBasedData();
        result.init(json);
        return result;
    }
}

export interface IMethodDBasedData {
    id: number;
    projectConstructionCost: number | undefined;
    ef_ReleventConsSector: number | undefined;
    shareOfTotalProjectCosts: number | undefined;
    projectRevenueInReportingYear: number | undefined;
    ef_relevantOperatingSector: number | undefined;
    constructSector: string;
    operatingtSector: string;
}

export class MethodEBasedData implements IMethodEBasedData {
    id: number;
    projectedAnnualEmissionsOfProject: number | undefined;
    projectedLifetimeOfProject: number | undefined;
    shareOfTotalProjectCosts: number | undefined;
    projectedAnnualEmissionsOfProject_unit: string;

    constructor(data?: IMethodEBasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectedAnnualEmissionsOfProject = _data["projectedAnnualEmissionsOfProject"];
            this.projectedLifetimeOfProject = _data["projectedLifetimeOfProject"];
            this.shareOfTotalProjectCosts = _data["shareOfTotalProjectCosts"];
            this.projectedAnnualEmissionsOfProject_unit = _data["projectedAnnualEmissionsOfProject_unit"];
        }
    }

    static fromJS(data: any): MethodEBasedData {
        data = typeof data === 'object' ? data : {};
        let result = new MethodEBasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectedAnnualEmissionsOfProject"] = this.projectedAnnualEmissionsOfProject;
        data["projectedLifetimeOfProject"] = this.projectedLifetimeOfProject;
        data["shareOfTotalProjectCosts"] = this.shareOfTotalProjectCosts;
        data["projectedAnnualEmissionsOfProject_unit"] = this.projectedAnnualEmissionsOfProject_unit;
        return data;
    }

    clone(): MethodEBasedData {
        const json = this.toJSON();
        let result = new MethodEBasedData();
        result.init(json);
        return result;
    }
}

export interface IMethodEBasedData {
    id: number;
    projectedAnnualEmissionsOfProject: number | undefined;
    projectedLifetimeOfProject: number | undefined;
    shareOfTotalProjectCosts: number | undefined;
    projectedAnnualEmissionsOfProject_unit: string;
}

export class InvestmentsActivityDataDto implements IInvestmentsActivityDataDto {
    month: number;
    year: number;
    activityType: string;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    groupNo: string;
    methodA_data: MethodABasedData[];
    methodB_data: MethodBBasedData[];
    methodC_data: MethodCBasedData[];
    methodD_data: MethodDBasedData[];
    methodE_data: MethodEBasedData[];

    constructor(data?: IInvestmentsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.methodA_data = [];
            this.methodB_data = [];
            this.methodC_data = [];
            this.methodD_data = [];
            this.methodE_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.activityType = _data["activityType"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.groupNo = _data["groupNo"];
            if (Array.isArray(_data["methodA_data"])) {
                this.methodA_data = [] as any;
                for (let item of _data["methodA_data"])
                    this.methodA_data.push(MethodABasedData.fromJS(item));
            }
            if (Array.isArray(_data["methodB_data"])) {
                this.methodB_data = [] as any;
                for (let item of _data["methodB_data"])
                    this.methodB_data.push(MethodBBasedData.fromJS(item));
            }
            if (Array.isArray(_data["methodC_data"])) {
                this.methodC_data = [] as any;
                for (let item of _data["methodC_data"])
                    this.methodC_data.push(MethodCBasedData.fromJS(item));
            }
            if (Array.isArray(_data["methodD_data"])) {
                this.methodD_data = [] as any;
                for (let item of _data["methodD_data"])
                    this.methodD_data.push(MethodDBasedData.fromJS(item));
            }
            if (Array.isArray(_data["methodE_data"])) {
                this.methodE_data = [] as any;
                for (let item of _data["methodE_data"])
                    this.methodE_data.push(MethodEBasedData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvestmentsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["activityType"] = this.activityType;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["groupNo"] = this.groupNo;
        if (Array.isArray(this.methodA_data)) {
            data["methodA_data"] = [];
            for (let item of this.methodA_data)
                data["methodA_data"].push(item.toJSON());
        }
        if (Array.isArray(this.methodB_data)) {
            data["methodB_data"] = [];
            for (let item of this.methodB_data)
                data["methodB_data"].push(item.toJSON());
        }
        if (Array.isArray(this.methodC_data)) {
            data["methodC_data"] = [];
            for (let item of this.methodC_data)
                data["methodC_data"].push(item.toJSON());
        }
        if (Array.isArray(this.methodD_data)) {
            data["methodD_data"] = [];
            for (let item of this.methodD_data)
                data["methodD_data"].push(item.toJSON());
        }
        if (Array.isArray(this.methodE_data)) {
            data["methodE_data"] = [];
            for (let item of this.methodE_data)
                data["methodE_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvestmentsActivityDataDto {
        const json = this.toJSON();
        let result = new InvestmentsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentsActivityDataDto {
    month: number;
    year: number;
    activityType: string;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    groupNo: string;
    methodA_data: MethodABasedData[];
    methodB_data: MethodBBasedData[];
    methodC_data: MethodCBasedData[];
    methodD_data: MethodDBasedData[];
    methodE_data: MethodEBasedData[];
}

export class GetManyInvestmentsActivityDataResponseDto implements IGetManyInvestmentsActivityDataResponseDto {
    data: InvestmentsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyInvestmentsActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(InvestmentsActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyInvestmentsActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyInvestmentsActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyInvestmentsActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyInvestmentsActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyInvestmentsActivityDataResponseDto {
    data: InvestmentsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class InvestmentsActivityData implements IInvestmentsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    activityType: string;
    scp1scpe2EmissionsOfEquityInvestment: number;
    shareOfEquity: number;
    investeeCompanyTotalRevenue: number;
    ef_InvesteeSector: number;
    shareOfTotalProjectCosts: number;
    scp1scp2EmissionRelevantProject: number;
    projectConstructionCost: number;
    ef_ReleventConsSector: number;
    projectRevenueInReportingYear: number;
    ef_relevantOperatingSector: number;
    projectedAnnualEmissionsOfProject: number;
    projectedLifetimeOfProject: number;
    emission: number;
    groupNo: string;
    scp1scpe2EmissionsOfEquityInvestment_unit: string;
    scp1scp2EmissionRelevantProject_unit: string;
    projectedAnnualEmissionsOfProject_unit: string;
    investeeSector: any;
    constructSector: string;
    operatingtSector: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: InvestmentsActivityDataActivityDataStatus;

    constructor(data?: IInvestmentsActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.activityType = _data["activityType"];
            this.scp1scpe2EmissionsOfEquityInvestment = _data["scp1scpe2EmissionsOfEquityInvestment"];
            this.shareOfEquity = _data["shareOfEquity"];
            this.investeeCompanyTotalRevenue = _data["investeeCompanyTotalRevenue"];
            this.ef_InvesteeSector = _data["ef_InvesteeSector"];
            this.shareOfTotalProjectCosts = _data["shareOfTotalProjectCosts"];
            this.scp1scp2EmissionRelevantProject = _data["scp1scp2EmissionRelevantProject"];
            this.projectConstructionCost = _data["projectConstructionCost"];
            this.ef_ReleventConsSector = _data["ef_ReleventConsSector"];
            this.projectRevenueInReportingYear = _data["projectRevenueInReportingYear"];
            this.ef_relevantOperatingSector = _data["ef_relevantOperatingSector"];
            this.projectedAnnualEmissionsOfProject = _data["projectedAnnualEmissionsOfProject"];
            this.projectedLifetimeOfProject = _data["projectedLifetimeOfProject"];
            this.emission = _data["emission"];
            this.groupNo = _data["groupNo"];
            this.scp1scpe2EmissionsOfEquityInvestment_unit = _data["scp1scpe2EmissionsOfEquityInvestment_unit"];
            this.scp1scp2EmissionRelevantProject_unit = _data["scp1scp2EmissionRelevantProject_unit"];
            this.projectedAnnualEmissionsOfProject_unit = _data["projectedAnnualEmissionsOfProject_unit"];
            this.investeeSector = _data["investeeSector"];
            this.constructSector = _data["constructSector"];
            this.operatingtSector = _data["operatingtSector"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): InvestmentsActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentsActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["activityType"] = this.activityType;
        data["scp1scpe2EmissionsOfEquityInvestment"] = this.scp1scpe2EmissionsOfEquityInvestment;
        data["shareOfEquity"] = this.shareOfEquity;
        data["investeeCompanyTotalRevenue"] = this.investeeCompanyTotalRevenue;
        data["ef_InvesteeSector"] = this.ef_InvesteeSector;
        data["shareOfTotalProjectCosts"] = this.shareOfTotalProjectCosts;
        data["scp1scp2EmissionRelevantProject"] = this.scp1scp2EmissionRelevantProject;
        data["projectConstructionCost"] = this.projectConstructionCost;
        data["ef_ReleventConsSector"] = this.ef_ReleventConsSector;
        data["projectRevenueInReportingYear"] = this.projectRevenueInReportingYear;
        data["ef_relevantOperatingSector"] = this.ef_relevantOperatingSector;
        data["projectedAnnualEmissionsOfProject"] = this.projectedAnnualEmissionsOfProject;
        data["projectedLifetimeOfProject"] = this.projectedLifetimeOfProject;
        data["emission"] = this.emission;
        data["groupNo"] = this.groupNo;
        data["scp1scpe2EmissionsOfEquityInvestment_unit"] = this.scp1scpe2EmissionsOfEquityInvestment_unit;
        data["scp1scp2EmissionRelevantProject_unit"] = this.scp1scp2EmissionRelevantProject_unit;
        data["projectedAnnualEmissionsOfProject_unit"] = this.projectedAnnualEmissionsOfProject_unit;
        data["investeeSector"] = this.investeeSector;
        data["constructSector"] = this.constructSector;
        data["operatingtSector"] = this.operatingtSector;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): InvestmentsActivityData {
        const json = this.toJSON();
        let result = new InvestmentsActivityData();
        result.init(json);
        return result;
    }
}

export interface IInvestmentsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    activityType: string;
    scp1scpe2EmissionsOfEquityInvestment: number;
    shareOfEquity: number;
    investeeCompanyTotalRevenue: number;
    ef_InvesteeSector: number;
    shareOfTotalProjectCosts: number;
    scp1scp2EmissionRelevantProject: number;
    projectConstructionCost: number;
    ef_ReleventConsSector: number;
    projectRevenueInReportingYear: number;
    ef_relevantOperatingSector: number;
    projectedAnnualEmissionsOfProject: number;
    projectedLifetimeOfProject: number;
    emission: number;
    groupNo: string;
    scp1scpe2EmissionsOfEquityInvestment_unit: string;
    scp1scp2EmissionRelevantProject_unit: string;
    projectedAnnualEmissionsOfProject_unit: string;
    investeeSector: any;
    constructSector: string;
    operatingtSector: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: InvestmentsActivityDataActivityDataStatus;
}

export class CreateManyInvestmentsActivityDataDto implements ICreateManyInvestmentsActivityDataDto {
    bulk: InvestmentsActivityData[];

    constructor(data?: ICreateManyInvestmentsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(InvestmentsActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyInvestmentsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyInvestmentsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyInvestmentsActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyInvestmentsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyInvestmentsActivityDataDto {
    bulk: InvestmentsActivityData[];
}

export class FuelFuelBasedNetZeroBusinessTravelEmissionSourceData implements IFuelFuelBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    fuel_type: string;
    fuel_quntity_unit: string;
    quntity: number;

    constructor(data?: IFuelFuelBasedNetZeroBusinessTravelEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_quntity_unit = _data["fuel_quntity_unit"];
            this.quntity = _data["quntity"];
        }
    }

    static fromJS(data: any): FuelFuelBasedNetZeroBusinessTravelEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelFuelBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["fuel_type"] = this.fuel_type;
        data["fuel_quntity_unit"] = this.fuel_quntity_unit;
        data["quntity"] = this.quntity;
        return data;
    }

    clone(): FuelFuelBasedNetZeroBusinessTravelEmissionSourceData {
        const json = this.toJSON();
        let result = new FuelFuelBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IFuelFuelBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    fuel_type: string;
    fuel_quntity_unit: string;
    quntity: number;
}

export class GridFuelBasedNetZeroBusinessTravelEmissionSourceData implements IGridFuelBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    grid_type: string;
    grid_quntity_unit: string;
    quntity: number;

    constructor(data?: IGridFuelBasedNetZeroBusinessTravelEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.grid_type = _data["grid_type"];
            this.grid_quntity_unit = _data["grid_quntity_unit"];
            this.quntity = _data["quntity"];
        }
    }

    static fromJS(data: any): GridFuelBasedNetZeroBusinessTravelEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new GridFuelBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["grid_type"] = this.grid_type;
        data["grid_quntity_unit"] = this.grid_quntity_unit;
        data["quntity"] = this.quntity;
        return data;
    }

    clone(): GridFuelBasedNetZeroBusinessTravelEmissionSourceData {
        const json = this.toJSON();
        let result = new GridFuelBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IGridFuelBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    grid_type: string;
    grid_quntity_unit: string;
    quntity: number;
}

export class RefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData implements IRefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    refrigerant_type: string;
    quntity: number;
    refrigerant_quntity_unit: string;

    constructor(data?: IRefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.quntity = _data["quntity"];
            this.refrigerant_quntity_unit = _data["refrigerant_quntity_unit"];
        }
    }

    static fromJS(data: any): RefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new RefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["refrigerant_type"] = this.refrigerant_type;
        data["quntity"] = this.quntity;
        data["refrigerant_quntity_unit"] = this.refrigerant_quntity_unit;
        return data;
    }

    clone(): RefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData {
        const json = this.toJSON();
        let result = new RefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IRefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    refrigerant_type: string;
    quntity: number;
    refrigerant_quntity_unit: string;
}

export class FuelBasedNetZeroBusinessTravelEmissionSourceData implements IFuelBasedNetZeroBusinessTravelEmissionSourceData {
    fuel_data: FuelFuelBasedNetZeroBusinessTravelEmissionSourceData[];
    grid_data: GridFuelBasedNetZeroBusinessTravelEmissionSourceData[];
    refrigerant_data: RefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData[];

    constructor(data?: IFuelBasedNetZeroBusinessTravelEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fuel_data = [];
            this.grid_data = [];
            this.refrigerant_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fuel_data"])) {
                this.fuel_data = [] as any;
                for (let item of _data["fuel_data"])
                    this.fuel_data.push(FuelFuelBasedNetZeroBusinessTravelEmissionSourceData.fromJS(item));
            }
            if (Array.isArray(_data["grid_data"])) {
                this.grid_data = [] as any;
                for (let item of _data["grid_data"])
                    this.grid_data.push(GridFuelBasedNetZeroBusinessTravelEmissionSourceData.fromJS(item));
            }
            if (Array.isArray(_data["refrigerant_data"])) {
                this.refrigerant_data = [] as any;
                for (let item of _data["refrigerant_data"])
                    this.refrigerant_data.push(RefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FuelBasedNetZeroBusinessTravelEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fuel_data)) {
            data["fuel_data"] = [];
            for (let item of this.fuel_data)
                data["fuel_data"].push(item.toJSON());
        }
        if (Array.isArray(this.grid_data)) {
            data["grid_data"] = [];
            for (let item of this.grid_data)
                data["grid_data"].push(item.toJSON());
        }
        if (Array.isArray(this.refrigerant_data)) {
            data["refrigerant_data"] = [];
            for (let item of this.refrigerant_data)
                data["refrigerant_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): FuelBasedNetZeroBusinessTravelEmissionSourceData {
        const json = this.toJSON();
        let result = new FuelBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IFuelBasedNetZeroBusinessTravelEmissionSourceData {
    fuel_data: FuelFuelBasedNetZeroBusinessTravelEmissionSourceData[];
    grid_data: GridFuelBasedNetZeroBusinessTravelEmissionSourceData[];
    refrigerant_data: RefrigerantFuelBasedNetZeroBusinessTravelEmissionSourceData[];
}

export class VehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData implements IVehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    vehicleType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;

    constructor(data?: IVehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.vehicleType = _data["vehicleType"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.totalDistanceTravelled_unit = _data["totalDistanceTravelled_unit"];
        }
    }

    static fromJS(data: any): VehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["vehicleType"] = this.vehicleType;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["totalDistanceTravelled_unit"] = this.totalDistanceTravelled_unit;
        return data;
    }

    clone(): VehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData {
        const json = this.toJSON();
        let result = new VehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IVehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    vehicleType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
}

export class HotelDistanceBasedNetZeroBusinessTravelEmissionSourceData implements IHotelDistanceBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    countryCode: string;
    totalNumberHotelNight: number;
    user_input_ef: number;

    constructor(data?: IHotelDistanceBasedNetZeroBusinessTravelEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.countryCode = _data["countryCode"];
            this.totalNumberHotelNight = _data["totalNumberHotelNight"];
            this.user_input_ef = _data["user_input_ef"];
        }
    }

    static fromJS(data: any): HotelDistanceBasedNetZeroBusinessTravelEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelDistanceBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["countryCode"] = this.countryCode;
        data["totalNumberHotelNight"] = this.totalNumberHotelNight;
        data["user_input_ef"] = this.user_input_ef;
        return data;
    }

    clone(): HotelDistanceBasedNetZeroBusinessTravelEmissionSourceData {
        const json = this.toJSON();
        let result = new HotelDistanceBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IHotelDistanceBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    typeName: string;
    countryCode: string;
    totalNumberHotelNight: number;
    user_input_ef: number;
}

export class DistanceBasedNetZeroBusinessTravelEmissionSourceData implements IDistanceBasedNetZeroBusinessTravelEmissionSourceData {
    vehicale_data: VehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData[];
    hotel_data: HotelDistanceBasedNetZeroBusinessTravelEmissionSourceData[];

    constructor(data?: IDistanceBasedNetZeroBusinessTravelEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.vehicale_data = [];
            this.hotel_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["vehicale_data"])) {
                this.vehicale_data = [] as any;
                for (let item of _data["vehicale_data"])
                    this.vehicale_data.push(VehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData.fromJS(item));
            }
            if (Array.isArray(_data["hotel_data"])) {
                this.hotel_data = [] as any;
                for (let item of _data["hotel_data"])
                    this.hotel_data.push(HotelDistanceBasedNetZeroBusinessTravelEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DistanceBasedNetZeroBusinessTravelEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new DistanceBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.vehicale_data)) {
            data["vehicale_data"] = [];
            for (let item of this.vehicale_data)
                data["vehicale_data"].push(item.toJSON());
        }
        if (Array.isArray(this.hotel_data)) {
            data["hotel_data"] = [];
            for (let item of this.hotel_data)
                data["hotel_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): DistanceBasedNetZeroBusinessTravelEmissionSourceData {
        const json = this.toJSON();
        let result = new DistanceBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IDistanceBasedNetZeroBusinessTravelEmissionSourceData {
    vehicale_data: VehicleDistanceBasedNetZeroBusinessTravelEmissionSourceData[];
    hotel_data: HotelDistanceBasedNetZeroBusinessTravelEmissionSourceData[];
}

export class AmountSpendBasedNetZeroBusinessTravelEmissionSourceData implements IAmountSpendBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    travel_type: string;
    totalAmountOnTravel: number;
    totalAmountOnTravel_unit: string;
    user_input_ef: number;

    constructor(data?: IAmountSpendBasedNetZeroBusinessTravelEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.travel_type = _data["travel_type"];
            this.totalAmountOnTravel = _data["totalAmountOnTravel"];
            this.totalAmountOnTravel_unit = _data["totalAmountOnTravel_unit"];
            this.user_input_ef = _data["user_input_ef"];
        }
    }

    static fromJS(data: any): AmountSpendBasedNetZeroBusinessTravelEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new AmountSpendBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["travel_type"] = this.travel_type;
        data["totalAmountOnTravel"] = this.totalAmountOnTravel;
        data["totalAmountOnTravel_unit"] = this.totalAmountOnTravel_unit;
        data["user_input_ef"] = this.user_input_ef;
        return data;
    }

    clone(): AmountSpendBasedNetZeroBusinessTravelEmissionSourceData {
        const json = this.toJSON();
        let result = new AmountSpendBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IAmountSpendBasedNetZeroBusinessTravelEmissionSourceData {
    id: number;
    travel_type: string;
    totalAmountOnTravel: number;
    totalAmountOnTravel_unit: string;
    user_input_ef: number;
}

export class SpendBasedNetZeroBusinessTravelEmissionSourceData implements ISpendBasedNetZeroBusinessTravelEmissionSourceData {
    amount_data: AmountSpendBasedNetZeroBusinessTravelEmissionSourceData[];

    constructor(data?: ISpendBasedNetZeroBusinessTravelEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.amount_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["amount_data"])) {
                this.amount_data = [] as any;
                for (let item of _data["amount_data"])
                    this.amount_data.push(AmountSpendBasedNetZeroBusinessTravelEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpendBasedNetZeroBusinessTravelEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new SpendBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.amount_data)) {
            data["amount_data"] = [];
            for (let item of this.amount_data)
                data["amount_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): SpendBasedNetZeroBusinessTravelEmissionSourceData {
        const json = this.toJSON();
        let result = new SpendBasedNetZeroBusinessTravelEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface ISpendBasedNetZeroBusinessTravelEmissionSourceData {
    amount_data: AmountSpendBasedNetZeroBusinessTravelEmissionSourceData[];
}

export class NetZeroBusinessTravelActivityDataDto implements INetZeroBusinessTravelActivityDataDto {
    month: number;
    year: number;
    method: NetZeroBusinessTravelActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroBusinessTravelActivityDataDtoActivityDataStatus;
    groupNo: string;
    fuel_emission_source_data: FuelBasedNetZeroBusinessTravelEmissionSourceData;
    distance_emission_source_data: DistanceBasedNetZeroBusinessTravelEmissionSourceData;
    spend_emission_source_data: SpendBasedNetZeroBusinessTravelEmissionSourceData;

    constructor(data?: INetZeroBusinessTravelActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.fuel_emission_source_data = new FuelBasedNetZeroBusinessTravelEmissionSourceData();
            this.distance_emission_source_data = new DistanceBasedNetZeroBusinessTravelEmissionSourceData();
            this.spend_emission_source_data = new SpendBasedNetZeroBusinessTravelEmissionSourceData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.fuel_emission_source_data = _data["fuel_emission_source_data"] ? FuelBasedNetZeroBusinessTravelEmissionSourceData.fromJS(_data["fuel_emission_source_data"]) : new FuelBasedNetZeroBusinessTravelEmissionSourceData();
            this.distance_emission_source_data = _data["distance_emission_source_data"] ? DistanceBasedNetZeroBusinessTravelEmissionSourceData.fromJS(_data["distance_emission_source_data"]) : new DistanceBasedNetZeroBusinessTravelEmissionSourceData();
            this.spend_emission_source_data = _data["spend_emission_source_data"] ? SpendBasedNetZeroBusinessTravelEmissionSourceData.fromJS(_data["spend_emission_source_data"]) : new SpendBasedNetZeroBusinessTravelEmissionSourceData();
        }
    }

    static fromJS(data: any): NetZeroBusinessTravelActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetZeroBusinessTravelActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["fuel_emission_source_data"] = this.fuel_emission_source_data ? this.fuel_emission_source_data.toJSON() : <any>undefined;
        data["distance_emission_source_data"] = this.distance_emission_source_data ? this.distance_emission_source_data.toJSON() : <any>undefined;
        data["spend_emission_source_data"] = this.spend_emission_source_data ? this.spend_emission_source_data.toJSON() : <any>undefined;
        return data;
    }

    clone(): NetZeroBusinessTravelActivityDataDto {
        const json = this.toJSON();
        let result = new NetZeroBusinessTravelActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface INetZeroBusinessTravelActivityDataDto {
    month: number;
    year: number;
    method: NetZeroBusinessTravelActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroBusinessTravelActivityDataDtoActivityDataStatus;
    groupNo: string;
    fuel_emission_source_data: FuelBasedNetZeroBusinessTravelEmissionSourceData;
    distance_emission_source_data: DistanceBasedNetZeroBusinessTravelEmissionSourceData;
    spend_emission_source_data: SpendBasedNetZeroBusinessTravelEmissionSourceData;
}

export class GetManyNetZeroBusinessTravelActivityDataResponseDto implements IGetManyNetZeroBusinessTravelActivityDataResponseDto {
    data: NetZeroBusinessTravelActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyNetZeroBusinessTravelActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(NetZeroBusinessTravelActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyNetZeroBusinessTravelActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyNetZeroBusinessTravelActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyNetZeroBusinessTravelActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyNetZeroBusinessTravelActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyNetZeroBusinessTravelActivityDataResponseDto {
    data: NetZeroBusinessTravelActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class NetZeroBusinessTravelActivityData implements INetZeroBusinessTravelActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: NetZeroBusinessTravelActivityDataMethod;
    type: string;
    fuel_type: string;
    fuel_quntity: number;
    fuel_quntity_unit: string;
    grid_type: string;
    grid_quntity: number;
    grid_quntity_unit: string;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    vehicleType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    countryCode: string;
    totalNumberHotelNight: number;
    travel_type: string;
    totalAmountOnTravel: number;
    totalAmountOnTravel_unit: string;
    emission: number;
    user_input_ef: any;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroBusinessTravelActivityDataActivityDataStatus;

    constructor(data?: INetZeroBusinessTravelActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.type = _data["type"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_quntity = _data["fuel_quntity"];
            this.fuel_quntity_unit = _data["fuel_quntity_unit"];
            this.grid_type = _data["grid_type"];
            this.grid_quntity = _data["grid_quntity"];
            this.grid_quntity_unit = _data["grid_quntity_unit"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.refrigerant_quntity = _data["refrigerant_quntity"];
            this.refrigerant_quntity_unit = _data["refrigerant_quntity_unit"];
            this.vehicleType = _data["vehicleType"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.totalDistanceTravelled_unit = _data["totalDistanceTravelled_unit"];
            this.countryCode = _data["countryCode"];
            this.totalNumberHotelNight = _data["totalNumberHotelNight"];
            this.travel_type = _data["travel_type"];
            this.totalAmountOnTravel = _data["totalAmountOnTravel"];
            this.totalAmountOnTravel_unit = _data["totalAmountOnTravel_unit"];
            this.emission = _data["emission"];
            this.user_input_ef = _data["user_input_ef"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): NetZeroBusinessTravelActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new NetZeroBusinessTravelActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["type"] = this.type;
        data["fuel_type"] = this.fuel_type;
        data["fuel_quntity"] = this.fuel_quntity;
        data["fuel_quntity_unit"] = this.fuel_quntity_unit;
        data["grid_type"] = this.grid_type;
        data["grid_quntity"] = this.grid_quntity;
        data["grid_quntity_unit"] = this.grid_quntity_unit;
        data["refrigerant_type"] = this.refrigerant_type;
        data["refrigerant_quntity"] = this.refrigerant_quntity;
        data["refrigerant_quntity_unit"] = this.refrigerant_quntity_unit;
        data["vehicleType"] = this.vehicleType;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["totalDistanceTravelled_unit"] = this.totalDistanceTravelled_unit;
        data["countryCode"] = this.countryCode;
        data["totalNumberHotelNight"] = this.totalNumberHotelNight;
        data["travel_type"] = this.travel_type;
        data["totalAmountOnTravel"] = this.totalAmountOnTravel;
        data["totalAmountOnTravel_unit"] = this.totalAmountOnTravel_unit;
        data["emission"] = this.emission;
        data["user_input_ef"] = this.user_input_ef;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): NetZeroBusinessTravelActivityData {
        const json = this.toJSON();
        let result = new NetZeroBusinessTravelActivityData();
        result.init(json);
        return result;
    }
}

export interface INetZeroBusinessTravelActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: NetZeroBusinessTravelActivityDataMethod;
    type: string;
    fuel_type: string;
    fuel_quntity: number;
    fuel_quntity_unit: string;
    grid_type: string;
    grid_quntity: number;
    grid_quntity_unit: string;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    vehicleType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    countryCode: string;
    totalNumberHotelNight: number;
    travel_type: string;
    totalAmountOnTravel: number;
    totalAmountOnTravel_unit: string;
    emission: number;
    user_input_ef: any;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroBusinessTravelActivityDataActivityDataStatus;
}

export class CreateManyNetZeroBusinessTravelActivityDataDto implements ICreateManyNetZeroBusinessTravelActivityDataDto {
    bulk: NetZeroBusinessTravelActivityData[];

    constructor(data?: ICreateManyNetZeroBusinessTravelActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(NetZeroBusinessTravelActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyNetZeroBusinessTravelActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyNetZeroBusinessTravelActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyNetZeroBusinessTravelActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyNetZeroBusinessTravelActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyNetZeroBusinessTravelActivityDataDto {
    bulk: NetZeroBusinessTravelActivityData[];
}

export class FuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData implements IFuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    fuel_type: string;
    fuel_quntity_unit: string;
    quntity: number;

    constructor(data?: IFuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_quntity_unit = _data["fuel_quntity_unit"];
            this.quntity = _data["quntity"];
        }
    }

    static fromJS(data: any): FuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["fuel_type"] = this.fuel_type;
        data["fuel_quntity_unit"] = this.fuel_quntity_unit;
        data["quntity"] = this.quntity;
        return data;
    }

    clone(): FuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
        const json = this.toJSON();
        let result = new FuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IFuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    fuel_type: string;
    fuel_quntity_unit: string;
    quntity: number;
}

export class GridFuelBasedNetZeroEmployeeCommutingEmissionSourceData implements IGridFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    grid_type: string;
    grid_quntity_unit: string;
    quntity: number;

    constructor(data?: IGridFuelBasedNetZeroEmployeeCommutingEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.grid_type = _data["grid_type"];
            this.grid_quntity_unit = _data["grid_quntity_unit"];
            this.quntity = _data["quntity"];
        }
    }

    static fromJS(data: any): GridFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new GridFuelBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["grid_type"] = this.grid_type;
        data["grid_quntity_unit"] = this.grid_quntity_unit;
        data["quntity"] = this.quntity;
        return data;
    }

    clone(): GridFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
        const json = this.toJSON();
        let result = new GridFuelBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IGridFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    grid_type: string;
    grid_quntity_unit: string;
    quntity: number;
}

export class RefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData implements IRefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    refrigerant_type: string;
    quntity: number;
    refrigerant_quntity_unit: string;

    constructor(data?: IRefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.quntity = _data["quntity"];
            this.refrigerant_quntity_unit = _data["refrigerant_quntity_unit"];
        }
    }

    static fromJS(data: any): RefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new RefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["refrigerant_type"] = this.refrigerant_type;
        data["quntity"] = this.quntity;
        data["refrigerant_quntity_unit"] = this.refrigerant_quntity_unit;
        return data;
    }

    clone(): RefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
        const json = this.toJSON();
        let result = new RefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IRefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    refrigerant_type: string;
    quntity: number;
    refrigerant_quntity_unit: string;
}

export class FuelBasedNetZeroEmployeeCommutingEmissionSourceData implements IFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
    fuel_data: FuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData[];
    grid_data: GridFuelBasedNetZeroEmployeeCommutingEmissionSourceData[];
    refrigerant_data: RefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData[];

    constructor(data?: IFuelBasedNetZeroEmployeeCommutingEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fuel_data = [];
            this.grid_data = [];
            this.refrigerant_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fuel_data"])) {
                this.fuel_data = [] as any;
                for (let item of _data["fuel_data"])
                    this.fuel_data.push(FuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData.fromJS(item));
            }
            if (Array.isArray(_data["grid_data"])) {
                this.grid_data = [] as any;
                for (let item of _data["grid_data"])
                    this.grid_data.push(GridFuelBasedNetZeroEmployeeCommutingEmissionSourceData.fromJS(item));
            }
            if (Array.isArray(_data["refrigerant_data"])) {
                this.refrigerant_data = [] as any;
                for (let item of _data["refrigerant_data"])
                    this.refrigerant_data.push(RefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FuelBasedNetZeroEmployeeCommutingEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fuel_data)) {
            data["fuel_data"] = [];
            for (let item of this.fuel_data)
                data["fuel_data"].push(item.toJSON());
        }
        if (Array.isArray(this.grid_data)) {
            data["grid_data"] = [];
            for (let item of this.grid_data)
                data["grid_data"].push(item.toJSON());
        }
        if (Array.isArray(this.refrigerant_data)) {
            data["refrigerant_data"] = [];
            for (let item of this.refrigerant_data)
                data["refrigerant_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): FuelBasedNetZeroEmployeeCommutingEmissionSourceData {
        const json = this.toJSON();
        let result = new FuelBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IFuelBasedNetZeroEmployeeCommutingEmissionSourceData {
    fuel_data: FuelFuelBasedNetZeroEmployeeCommutingEmissionSourceData[];
    grid_data: GridFuelBasedNetZeroEmployeeCommutingEmissionSourceData[];
    refrigerant_data: RefrigerantFuelBasedNetZeroEmployeeCommutingEmissionSourceData[];
}

export class VehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData implements IVehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    vehicleType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    commutingDaysPerYear: number;

    constructor(data?: IVehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.vehicleType = _data["vehicleType"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.totalDistanceTravelled_unit = _data["totalDistanceTravelled_unit"];
            this.commutingDaysPerYear = _data["commutingDaysPerYear"];
        }
    }

    static fromJS(data: any): VehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["vehicleType"] = this.vehicleType;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["totalDistanceTravelled_unit"] = this.totalDistanceTravelled_unit;
        data["commutingDaysPerYear"] = this.commutingDaysPerYear;
        return data;
    }

    clone(): VehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
        const json = this.toJSON();
        let result = new VehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IVehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    vehicleType: string;
    totalDistanceTravelled: number;
    totalDistanceTravelled_unit: string;
    commutingDaysPerYear: number;
}

export class EnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData implements IEnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    energy_source: string;
    energy: number;
    energy_unit: string;
    user_input_ef: number;

    constructor(data?: IEnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.energy_source = _data["energy_source"];
            this.energy = _data["energy"];
            this.energy_unit = _data["energy_unit"];
            this.user_input_ef = _data["user_input_ef"];
        }
    }

    static fromJS(data: any): EnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["energy_source"] = this.energy_source;
        data["energy"] = this.energy;
        data["energy_unit"] = this.energy_unit;
        data["user_input_ef"] = this.user_input_ef;
        return data;
    }

    clone(): EnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
        const json = this.toJSON();
        let result = new EnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IEnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    typeName: string;
    energy_source: string;
    energy: number;
    energy_unit: string;
    user_input_ef: number;
}

export class DistanceBasedNetZeroEmployeeCommutingEmissionSourceData implements IDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
    vehicale_data: VehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData[];
    energy_data: EnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData[];

    constructor(data?: IDistanceBasedNetZeroEmployeeCommutingEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.vehicale_data = [];
            this.energy_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["vehicale_data"])) {
                this.vehicale_data = [] as any;
                for (let item of _data["vehicale_data"])
                    this.vehicale_data.push(VehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData.fromJS(item));
            }
            if (Array.isArray(_data["energy_data"])) {
                this.energy_data = [] as any;
                for (let item of _data["energy_data"])
                    this.energy_data.push(EnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new DistanceBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.vehicale_data)) {
            data["vehicale_data"] = [];
            for (let item of this.vehicale_data)
                data["vehicale_data"].push(item.toJSON());
        }
        if (Array.isArray(this.energy_data)) {
            data["energy_data"] = [];
            for (let item of this.energy_data)
                data["energy_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): DistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
        const json = this.toJSON();
        let result = new DistanceBasedNetZeroEmployeeCommutingEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IDistanceBasedNetZeroEmployeeCommutingEmissionSourceData {
    vehicale_data: VehicleDistanceBasedNetZeroEmployeeCommutingEmissionSourceData[];
    energy_data: EnergyDistanceBasedNetZeroEmployeeCommutingEmissionSourceData[];
}

export class EmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData implements IEmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    travel_type: string;
    workingDayPerYear: number;
    oneWayDistance: number;
    oneWayDistance_unit: string;
    numberOfEmplyees: number;
    presentageUsingVehcleType: number;

    constructor(data?: IEmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.travel_type = _data["travel_type"];
            this.workingDayPerYear = _data["workingDayPerYear"];
            this.oneWayDistance = _data["oneWayDistance"];
            this.oneWayDistance_unit = _data["oneWayDistance_unit"];
            this.numberOfEmplyees = _data["numberOfEmplyees"];
            this.presentageUsingVehcleType = _data["presentageUsingVehcleType"];
        }
    }

    static fromJS(data: any): EmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["travel_type"] = this.travel_type;
        data["workingDayPerYear"] = this.workingDayPerYear;
        data["oneWayDistance"] = this.oneWayDistance;
        data["oneWayDistance_unit"] = this.oneWayDistance_unit;
        data["numberOfEmplyees"] = this.numberOfEmplyees;
        data["presentageUsingVehcleType"] = this.presentageUsingVehcleType;
        return data;
    }

    clone(): EmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData {
        const json = this.toJSON();
        let result = new EmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IEmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData {
    id: number;
    travel_type: string;
    workingDayPerYear: number;
    oneWayDistance: number;
    oneWayDistance_unit: string;
    numberOfEmplyees: number;
    presentageUsingVehcleType: number;
}

export class AverageDataNetZeroEmployeeCommutingEmissionSourceData implements IAverageDataNetZeroEmployeeCommutingEmissionSourceData {
    average_data: EmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData[];

    constructor(data?: IAverageDataNetZeroEmployeeCommutingEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.average_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["average_data"])) {
                this.average_data = [] as any;
                for (let item of _data["average_data"])
                    this.average_data.push(EmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AverageDataNetZeroEmployeeCommutingEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new AverageDataNetZeroEmployeeCommutingEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.average_data)) {
            data["average_data"] = [];
            for (let item of this.average_data)
                data["average_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): AverageDataNetZeroEmployeeCommutingEmissionSourceData {
        const json = this.toJSON();
        let result = new AverageDataNetZeroEmployeeCommutingEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IAverageDataNetZeroEmployeeCommutingEmissionSourceData {
    average_data: EmployeeAverageDataNetZeroEmployeeCommutingEmissionSourceData[];
}

export class NetZeroEmployeeCommutingActivityDataDto implements INetZeroEmployeeCommutingActivityDataDto {
    month: number;
    year: number;
    method: NetZeroEmployeeCommutingActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroEmployeeCommutingActivityDataDtoActivityDataStatus;
    groupNo: string;
    fuel_emission_source_data: FuelBasedNetZeroEmployeeCommutingEmissionSourceData;
    distance_emission_source_data: DistanceBasedNetZeroEmployeeCommutingEmissionSourceData;
    average_data_emission_source_data: AverageDataNetZeroEmployeeCommutingEmissionSourceData;

    constructor(data?: INetZeroEmployeeCommutingActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.fuel_emission_source_data = new FuelBasedNetZeroEmployeeCommutingEmissionSourceData();
            this.distance_emission_source_data = new DistanceBasedNetZeroEmployeeCommutingEmissionSourceData();
            this.average_data_emission_source_data = new AverageDataNetZeroEmployeeCommutingEmissionSourceData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.fuel_emission_source_data = _data["fuel_emission_source_data"] ? FuelBasedNetZeroEmployeeCommutingEmissionSourceData.fromJS(_data["fuel_emission_source_data"]) : new FuelBasedNetZeroEmployeeCommutingEmissionSourceData();
            this.distance_emission_source_data = _data["distance_emission_source_data"] ? DistanceBasedNetZeroEmployeeCommutingEmissionSourceData.fromJS(_data["distance_emission_source_data"]) : new DistanceBasedNetZeroEmployeeCommutingEmissionSourceData();
            this.average_data_emission_source_data = _data["average_data_emission_source_data"] ? AverageDataNetZeroEmployeeCommutingEmissionSourceData.fromJS(_data["average_data_emission_source_data"]) : new AverageDataNetZeroEmployeeCommutingEmissionSourceData();
        }
    }

    static fromJS(data: any): NetZeroEmployeeCommutingActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetZeroEmployeeCommutingActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["fuel_emission_source_data"] = this.fuel_emission_source_data ? this.fuel_emission_source_data.toJSON() : <any>undefined;
        data["distance_emission_source_data"] = this.distance_emission_source_data ? this.distance_emission_source_data.toJSON() : <any>undefined;
        data["average_data_emission_source_data"] = this.average_data_emission_source_data ? this.average_data_emission_source_data.toJSON() : <any>undefined;
        return data;
    }

    clone(): NetZeroEmployeeCommutingActivityDataDto {
        const json = this.toJSON();
        let result = new NetZeroEmployeeCommutingActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface INetZeroEmployeeCommutingActivityDataDto {
    month: number;
    year: number;
    method: NetZeroEmployeeCommutingActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroEmployeeCommutingActivityDataDtoActivityDataStatus;
    groupNo: string;
    fuel_emission_source_data: FuelBasedNetZeroEmployeeCommutingEmissionSourceData;
    distance_emission_source_data: DistanceBasedNetZeroEmployeeCommutingEmissionSourceData;
    average_data_emission_source_data: AverageDataNetZeroEmployeeCommutingEmissionSourceData;
}

export class GetManyNetZeroEmployeeCommutingActivityDataResponseDto implements IGetManyNetZeroEmployeeCommutingActivityDataResponseDto {
    data: NetZeroEmployeeCommutingActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyNetZeroEmployeeCommutingActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(NetZeroEmployeeCommutingActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyNetZeroEmployeeCommutingActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyNetZeroEmployeeCommutingActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyNetZeroEmployeeCommutingActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyNetZeroEmployeeCommutingActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyNetZeroEmployeeCommutingActivityDataResponseDto {
    data: NetZeroEmployeeCommutingActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class NetZeroEmployeeCommutingActivityData implements INetZeroEmployeeCommutingActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: NetZeroEmployeeCommutingActivityDataMethod;
    type: string;
    fuel_type: string;
    fuel_quntity: number;
    fuel_quntity_unit: string;
    grid_type: string;
    grid_quntity: number;
    grid_quntity_unit: string;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    vehicleType: string;
    totalDistanceTravelled: number;
    commutingDaysPerYear: number;
    totalDistanceTravelled_unit: string;
    energy_source: string;
    energy: number;
    energy_unit: string;
    workingDayPerYear: number;
    oneWayDistance: number;
    oneWayDistance_unit: string;
    numberOfEmplyees: number;
    presentageUsingVehcleType: number;
    emission: number;
    user_input_ef: any;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroEmployeeCommutingActivityDataActivityDataStatus;

    constructor(data?: INetZeroEmployeeCommutingActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.type = _data["type"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_quntity = _data["fuel_quntity"];
            this.fuel_quntity_unit = _data["fuel_quntity_unit"];
            this.grid_type = _data["grid_type"];
            this.grid_quntity = _data["grid_quntity"];
            this.grid_quntity_unit = _data["grid_quntity_unit"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.refrigerant_quntity = _data["refrigerant_quntity"];
            this.refrigerant_quntity_unit = _data["refrigerant_quntity_unit"];
            this.vehicleType = _data["vehicleType"];
            this.totalDistanceTravelled = _data["totalDistanceTravelled"];
            this.commutingDaysPerYear = _data["commutingDaysPerYear"];
            this.totalDistanceTravelled_unit = _data["totalDistanceTravelled_unit"];
            this.energy_source = _data["energy_source"];
            this.energy = _data["energy"];
            this.energy_unit = _data["energy_unit"];
            this.workingDayPerYear = _data["workingDayPerYear"];
            this.oneWayDistance = _data["oneWayDistance"];
            this.oneWayDistance_unit = _data["oneWayDistance_unit"];
            this.numberOfEmplyees = _data["numberOfEmplyees"];
            this.presentageUsingVehcleType = _data["presentageUsingVehcleType"];
            this.emission = _data["emission"];
            this.user_input_ef = _data["user_input_ef"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): NetZeroEmployeeCommutingActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new NetZeroEmployeeCommutingActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["type"] = this.type;
        data["fuel_type"] = this.fuel_type;
        data["fuel_quntity"] = this.fuel_quntity;
        data["fuel_quntity_unit"] = this.fuel_quntity_unit;
        data["grid_type"] = this.grid_type;
        data["grid_quntity"] = this.grid_quntity;
        data["grid_quntity_unit"] = this.grid_quntity_unit;
        data["refrigerant_type"] = this.refrigerant_type;
        data["refrigerant_quntity"] = this.refrigerant_quntity;
        data["refrigerant_quntity_unit"] = this.refrigerant_quntity_unit;
        data["vehicleType"] = this.vehicleType;
        data["totalDistanceTravelled"] = this.totalDistanceTravelled;
        data["commutingDaysPerYear"] = this.commutingDaysPerYear;
        data["totalDistanceTravelled_unit"] = this.totalDistanceTravelled_unit;
        data["energy_source"] = this.energy_source;
        data["energy"] = this.energy;
        data["energy_unit"] = this.energy_unit;
        data["workingDayPerYear"] = this.workingDayPerYear;
        data["oneWayDistance"] = this.oneWayDistance;
        data["oneWayDistance_unit"] = this.oneWayDistance_unit;
        data["numberOfEmplyees"] = this.numberOfEmplyees;
        data["presentageUsingVehcleType"] = this.presentageUsingVehcleType;
        data["emission"] = this.emission;
        data["user_input_ef"] = this.user_input_ef;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): NetZeroEmployeeCommutingActivityData {
        const json = this.toJSON();
        let result = new NetZeroEmployeeCommutingActivityData();
        result.init(json);
        return result;
    }
}

export interface INetZeroEmployeeCommutingActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: NetZeroEmployeeCommutingActivityDataMethod;
    type: string;
    fuel_type: string;
    fuel_quntity: number;
    fuel_quntity_unit: string;
    grid_type: string;
    grid_quntity: number;
    grid_quntity_unit: string;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    vehicleType: string;
    totalDistanceTravelled: number;
    commutingDaysPerYear: number;
    totalDistanceTravelled_unit: string;
    energy_source: string;
    energy: number;
    energy_unit: string;
    workingDayPerYear: number;
    oneWayDistance: number;
    oneWayDistance_unit: string;
    numberOfEmplyees: number;
    presentageUsingVehcleType: number;
    emission: number;
    user_input_ef: any;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroEmployeeCommutingActivityDataActivityDataStatus;
}

export class CreateManyNetZeroEmployeeCommutingActivityDataDto implements ICreateManyNetZeroEmployeeCommutingActivityDataDto {
    bulk: NetZeroEmployeeCommutingActivityData[];

    constructor(data?: ICreateManyNetZeroEmployeeCommutingActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(NetZeroEmployeeCommutingActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyNetZeroEmployeeCommutingActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyNetZeroEmployeeCommutingActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyNetZeroEmployeeCommutingActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyNetZeroEmployeeCommutingActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyNetZeroEmployeeCommutingActivityDataDto {
    bulk: NetZeroEmployeeCommutingActivityData[];
}

export class WasteBasedData implements IWasteBasedData {
    id: number;
    wasteMethod: string;
    soldProducts: number | undefined;
    totalWaste: number | undefined;
    mass_unit: string;

    constructor(data?: IWasteBasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.wasteMethod = _data["wasteMethod"];
            this.soldProducts = _data["soldProducts"];
            this.totalWaste = _data["totalWaste"];
            this.mass_unit = _data["mass_unit"];
        }
    }

    static fromJS(data: any): WasteBasedData {
        data = typeof data === 'object' ? data : {};
        let result = new WasteBasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wasteMethod"] = this.wasteMethod;
        data["soldProducts"] = this.soldProducts;
        data["totalWaste"] = this.totalWaste;
        data["mass_unit"] = this.mass_unit;
        return data;
    }

    clone(): WasteBasedData {
        const json = this.toJSON();
        let result = new WasteBasedData();
        result.init(json);
        return result;
    }
}

export interface IWasteBasedData {
    id: number;
    wasteMethod: string;
    soldProducts: number | undefined;
    totalWaste: number | undefined;
    mass_unit: string;
}

export class EndOfLifeTreatmentOfSoldProductsActivityDataDto implements IEndOfLifeTreatmentOfSoldProductsActivityDataDto {
    month: number;
    year: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    groupNo: string;
    method_data: WasteBasedData[];

    constructor(data?: IEndOfLifeTreatmentOfSoldProductsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.method_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.groupNo = _data["groupNo"];
            if (Array.isArray(_data["method_data"])) {
                this.method_data = [] as any;
                for (let item of _data["method_data"])
                    this.method_data.push(WasteBasedData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EndOfLifeTreatmentOfSoldProductsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new EndOfLifeTreatmentOfSoldProductsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["groupNo"] = this.groupNo;
        if (Array.isArray(this.method_data)) {
            data["method_data"] = [];
            for (let item of this.method_data)
                data["method_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): EndOfLifeTreatmentOfSoldProductsActivityDataDto {
        const json = this.toJSON();
        let result = new EndOfLifeTreatmentOfSoldProductsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IEndOfLifeTreatmentOfSoldProductsActivityDataDto {
    month: number;
    year: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    groupNo: string;
    method_data: WasteBasedData[];
}

export class GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto implements IGetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto {
    data: EndOfLifeTreatmentOfSoldProductsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(EndOfLifeTreatmentOfSoldProductsActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyEndOfLifeTreatmentOfSoldProductsActivityDataResponseDto {
    data: EndOfLifeTreatmentOfSoldProductsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class EndOfLifeTreatmentOfSoldProductsActivityData implements IEndOfLifeTreatmentOfSoldProductsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    wasteMethod: string;
    soldProducts: number;
    totalWaste: number;
    emission: number;
    groupNo: string;
    mass_unit: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: EndOfLifeTreatmentOfSoldProductsActivityDataActivityDataStatus;

    constructor(data?: IEndOfLifeTreatmentOfSoldProductsActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.wasteMethod = _data["wasteMethod"];
            this.soldProducts = _data["soldProducts"];
            this.totalWaste = _data["totalWaste"];
            this.emission = _data["emission"];
            this.groupNo = _data["groupNo"];
            this.mass_unit = _data["mass_unit"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): EndOfLifeTreatmentOfSoldProductsActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new EndOfLifeTreatmentOfSoldProductsActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["wasteMethod"] = this.wasteMethod;
        data["soldProducts"] = this.soldProducts;
        data["totalWaste"] = this.totalWaste;
        data["emission"] = this.emission;
        data["groupNo"] = this.groupNo;
        data["mass_unit"] = this.mass_unit;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): EndOfLifeTreatmentOfSoldProductsActivityData {
        const json = this.toJSON();
        let result = new EndOfLifeTreatmentOfSoldProductsActivityData();
        result.init(json);
        return result;
    }
}

export interface IEndOfLifeTreatmentOfSoldProductsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    wasteMethod: string;
    soldProducts: number;
    totalWaste: number;
    emission: number;
    groupNo: string;
    mass_unit: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: EndOfLifeTreatmentOfSoldProductsActivityDataActivityDataStatus;
}

export class CreateManyEndOfLifeTreatmentOfSoldProductsActivityDataDto implements ICreateManyEndOfLifeTreatmentOfSoldProductsActivityDataDto {
    bulk: EndOfLifeTreatmentOfSoldProductsActivityData[];

    constructor(data?: ICreateManyEndOfLifeTreatmentOfSoldProductsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(EndOfLifeTreatmentOfSoldProductsActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyEndOfLifeTreatmentOfSoldProductsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyEndOfLifeTreatmentOfSoldProductsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyEndOfLifeTreatmentOfSoldProductsActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyEndOfLifeTreatmentOfSoldProductsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyEndOfLifeTreatmentOfSoldProductsActivityDataDto {
    bulk: EndOfLifeTreatmentOfSoldProductsActivityData[];
}

export class FuelBasedeData implements IFuelBasedeData {
    id: number;
    fuel_type: string;
    fuel_quntity_unit: string;
    fuel_quntity: number | undefined;
    typeName: string | undefined;

    constructor(data?: IFuelBasedeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_quntity_unit = _data["fuel_quntity_unit"];
            this.fuel_quntity = _data["fuel_quntity"];
            this.typeName = _data["typeName"];
        }
    }

    static fromJS(data: any): FuelBasedeData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelBasedeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fuel_type"] = this.fuel_type;
        data["fuel_quntity_unit"] = this.fuel_quntity_unit;
        data["fuel_quntity"] = this.fuel_quntity;
        data["typeName"] = this.typeName;
        return data;
    }

    clone(): FuelBasedeData {
        const json = this.toJSON();
        let result = new FuelBasedeData();
        result.init(json);
        return result;
    }
}

export interface IFuelBasedeData {
    id: number;
    fuel_type: string;
    fuel_quntity_unit: string;
    fuel_quntity: number | undefined;
    typeName: string | undefined;
}

export class RefrigerantBasdeData implements IRefrigerantBasdeData {
    id: number;
    refrigerant_type: string;
    refrigerant_quntity: number | undefined;
    refrigerant_quntity_unit: string;
    process_emission: number | undefined;
    process_emission_unit: string;
    typeName: string | undefined;

    constructor(data?: IRefrigerantBasdeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.refrigerant_quntity = _data["refrigerant_quntity"];
            this.refrigerant_quntity_unit = _data["refrigerant_quntity_unit"];
            this.process_emission = _data["process_emission"];
            this.process_emission_unit = _data["process_emission_unit"];
            this.typeName = _data["typeName"];
        }
    }

    static fromJS(data: any): RefrigerantBasdeData {
        data = typeof data === 'object' ? data : {};
        let result = new RefrigerantBasdeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["refrigerant_type"] = this.refrigerant_type;
        data["refrigerant_quntity"] = this.refrigerant_quntity;
        data["refrigerant_quntity_unit"] = this.refrigerant_quntity_unit;
        data["process_emission"] = this.process_emission;
        data["process_emission_unit"] = this.process_emission_unit;
        data["typeName"] = this.typeName;
        return data;
    }

    clone(): RefrigerantBasdeData {
        const json = this.toJSON();
        let result = new RefrigerantBasdeData();
        result.init(json);
        return result;
    }
}

export interface IRefrigerantBasdeData {
    id: number;
    refrigerant_type: string;
    refrigerant_quntity: number | undefined;
    refrigerant_quntity_unit: string;
    process_emission: number | undefined;
    process_emission_unit: string;
    typeName: string | undefined;
}

export class ElectricityBaseData implements IElectricityBaseData {
    id: number;
    fuel_type: string;
    fuel_quntity_unit: string;
    fuel_quntity: number | undefined;
    typeName: string | undefined;

    constructor(data?: IElectricityBaseData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_quntity_unit = _data["fuel_quntity_unit"];
            this.fuel_quntity = _data["fuel_quntity"];
            this.typeName = _data["typeName"];
        }
    }

    static fromJS(data: any): ElectricityBaseData {
        data = typeof data === 'object' ? data : {};
        let result = new ElectricityBaseData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fuel_type"] = this.fuel_type;
        data["fuel_quntity_unit"] = this.fuel_quntity_unit;
        data["fuel_quntity"] = this.fuel_quntity;
        data["typeName"] = this.typeName;
        return data;
    }

    clone(): ElectricityBaseData {
        const json = this.toJSON();
        let result = new ElectricityBaseData();
        result.init(json);
        return result;
    }
}

export interface IElectricityBaseData {
    id: number;
    fuel_type: string;
    fuel_quntity_unit: string;
    fuel_quntity: number | undefined;
    typeName: string | undefined;
}

export class AssetSpecificMethodData implements IAssetSpecificMethodData {
    fuel_data: FuelBasedeData[];
    refrigerant_data: RefrigerantBasdeData[];
    elec_data: ElectricityBaseData[];

    constructor(data?: IAssetSpecificMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fuel_data = [];
            this.refrigerant_data = [];
            this.elec_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fuel_data"])) {
                this.fuel_data = [] as any;
                for (let item of _data["fuel_data"])
                    this.fuel_data.push(FuelBasedeData.fromJS(item));
            }
            if (Array.isArray(_data["refrigerant_data"])) {
                this.refrigerant_data = [] as any;
                for (let item of _data["refrigerant_data"])
                    this.refrigerant_data.push(RefrigerantBasdeData.fromJS(item));
            }
            if (Array.isArray(_data["elec_data"])) {
                this.elec_data = [] as any;
                for (let item of _data["elec_data"])
                    this.elec_data.push(ElectricityBaseData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssetSpecificMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSpecificMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fuel_data)) {
            data["fuel_data"] = [];
            for (let item of this.fuel_data)
                data["fuel_data"].push(item.toJSON());
        }
        if (Array.isArray(this.refrigerant_data)) {
            data["refrigerant_data"] = [];
            for (let item of this.refrigerant_data)
                data["refrigerant_data"].push(item.toJSON());
        }
        if (Array.isArray(this.elec_data)) {
            data["elec_data"] = [];
            for (let item of this.elec_data)
                data["elec_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): AssetSpecificMethodData {
        const json = this.toJSON();
        let result = new AssetSpecificMethodData();
        result.init(json);
        return result;
    }
}

export interface IAssetSpecificMethodData {
    fuel_data: FuelBasedeData[];
    refrigerant_data: RefrigerantBasdeData[];
    elec_data: ElectricityBaseData[];
}

export class LessorSpecificMethodData implements ILessorSpecificMethodData {
    id: number;
    lessorType: string;
    userInputEF: number | undefined;
    scp1scp2_emissions_lessor: number | undefined;
    scp1scp2_emissions_lessor_unit: string;
    lease_assests_ratio: number | undefined;

    constructor(data?: ILessorSpecificMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lessorType = _data["lessorType"];
            this.userInputEF = _data["userInputEF"];
            this.scp1scp2_emissions_lessor = _data["scp1scp2_emissions_lessor"];
            this.scp1scp2_emissions_lessor_unit = _data["scp1scp2_emissions_lessor_unit"];
            this.lease_assests_ratio = _data["lease_assests_ratio"];
        }
    }

    static fromJS(data: any): LessorSpecificMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new LessorSpecificMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lessorType"] = this.lessorType;
        data["userInputEF"] = this.userInputEF;
        data["scp1scp2_emissions_lessor"] = this.scp1scp2_emissions_lessor;
        data["scp1scp2_emissions_lessor_unit"] = this.scp1scp2_emissions_lessor_unit;
        data["lease_assests_ratio"] = this.lease_assests_ratio;
        return data;
    }

    clone(): LessorSpecificMethodData {
        const json = this.toJSON();
        let result = new LessorSpecificMethodData();
        result.init(json);
        return result;
    }
}

export interface ILessorSpecificMethodData {
    id: number;
    lessorType: string;
    userInputEF: number | undefined;
    scp1scp2_emissions_lessor: number | undefined;
    scp1scp2_emissions_lessor_unit: string;
    lease_assests_ratio: number | undefined;
}

export class LeasedBuildingsMethodData implements ILeasedBuildingsMethodData {
    id: number;
    userInputEF: number | undefined;
    total_floor_space: number | undefined;
    total_floor_space_unit: string;
    building_type: string;

    constructor(data?: ILeasedBuildingsMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userInputEF = _data["userInputEF"];
            this.total_floor_space = _data["total_floor_space"];
            this.total_floor_space_unit = _data["total_floor_space_unit"];
            this.building_type = _data["building_type"];
        }
    }

    static fromJS(data: any): LeasedBuildingsMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new LeasedBuildingsMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userInputEF"] = this.userInputEF;
        data["total_floor_space"] = this.total_floor_space;
        data["total_floor_space_unit"] = this.total_floor_space_unit;
        data["building_type"] = this.building_type;
        return data;
    }

    clone(): LeasedBuildingsMethodData {
        const json = this.toJSON();
        let result = new LeasedBuildingsMethodData();
        result.init(json);
        return result;
    }
}

export interface ILeasedBuildingsMethodData {
    id: number;
    userInputEF: number | undefined;
    total_floor_space: number | undefined;
    total_floor_space_unit: string;
    building_type: string;
}

export class LeasedAssetsMethodData implements ILeasedAssetsMethodData {
    userInputEF: number | undefined;
    number_of_assets: number | undefined;
    asset_type: string;
    id: number;

    constructor(data?: ILeasedAssetsMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userInputEF = _data["userInputEF"];
            this.number_of_assets = _data["number_of_assets"];
            this.asset_type = _data["asset_type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LeasedAssetsMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new LeasedAssetsMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userInputEF"] = this.userInputEF;
        data["number_of_assets"] = this.number_of_assets;
        data["asset_type"] = this.asset_type;
        data["id"] = this.id;
        return data;
    }

    clone(): LeasedAssetsMethodData {
        const json = this.toJSON();
        let result = new LeasedAssetsMethodData();
        result.init(json);
        return result;
    }
}

export interface ILeasedAssetsMethodData {
    userInputEF: number | undefined;
    number_of_assets: number | undefined;
    asset_type: string;
    id: number;
}

export class UpstreamLeasedAssetsActivityDataDto implements IUpstreamLeasedAssetsActivityDataDto {
    month: number;
    year: number;
    activityType: UpstreamLeasedAssetsActivityDataDtoActivityType;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: UpstreamLeasedAssetsActivityDataDtoActivityDataStatus;
    groupNo: string;
    asset_specific_method_data: AssetSpecificMethodData;
    lessor_specific_method_data: LessorSpecificMethodData[];
    leased_buildings_method_data: LeasedBuildingsMethodData[];
    leased_assets_method_data: LeasedAssetsMethodData[];

    constructor(data?: IUpstreamLeasedAssetsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.asset_specific_method_data = new AssetSpecificMethodData();
            this.lessor_specific_method_data = [];
            this.leased_buildings_method_data = [];
            this.leased_assets_method_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.activityType = _data["activityType"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.asset_specific_method_data = _data["asset_specific_method_data"] ? AssetSpecificMethodData.fromJS(_data["asset_specific_method_data"]) : new AssetSpecificMethodData();
            if (Array.isArray(_data["lessor_specific_method_data"])) {
                this.lessor_specific_method_data = [] as any;
                for (let item of _data["lessor_specific_method_data"])
                    this.lessor_specific_method_data.push(LessorSpecificMethodData.fromJS(item));
            }
            if (Array.isArray(_data["leased_buildings_method_data"])) {
                this.leased_buildings_method_data = [] as any;
                for (let item of _data["leased_buildings_method_data"])
                    this.leased_buildings_method_data.push(LeasedBuildingsMethodData.fromJS(item));
            }
            if (Array.isArray(_data["leased_assets_method_data"])) {
                this.leased_assets_method_data = [] as any;
                for (let item of _data["leased_assets_method_data"])
                    this.leased_assets_method_data.push(LeasedAssetsMethodData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpstreamLeasedAssetsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpstreamLeasedAssetsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["activityType"] = this.activityType;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["asset_specific_method_data"] = this.asset_specific_method_data ? this.asset_specific_method_data.toJSON() : <any>undefined;
        if (Array.isArray(this.lessor_specific_method_data)) {
            data["lessor_specific_method_data"] = [];
            for (let item of this.lessor_specific_method_data)
                data["lessor_specific_method_data"].push(item.toJSON());
        }
        if (Array.isArray(this.leased_buildings_method_data)) {
            data["leased_buildings_method_data"] = [];
            for (let item of this.leased_buildings_method_data)
                data["leased_buildings_method_data"].push(item.toJSON());
        }
        if (Array.isArray(this.leased_assets_method_data)) {
            data["leased_assets_method_data"] = [];
            for (let item of this.leased_assets_method_data)
                data["leased_assets_method_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpstreamLeasedAssetsActivityDataDto {
        const json = this.toJSON();
        let result = new UpstreamLeasedAssetsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IUpstreamLeasedAssetsActivityDataDto {
    month: number;
    year: number;
    activityType: UpstreamLeasedAssetsActivityDataDtoActivityType;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: UpstreamLeasedAssetsActivityDataDtoActivityDataStatus;
    groupNo: string;
    asset_specific_method_data: AssetSpecificMethodData;
    lessor_specific_method_data: LessorSpecificMethodData[];
    leased_buildings_method_data: LeasedBuildingsMethodData[];
    leased_assets_method_data: LeasedAssetsMethodData[];
}

export class GetManyUpstreamLeasedAssetsActivityDataResponseDto implements IGetManyUpstreamLeasedAssetsActivityDataResponseDto {
    data: UpstreamLeasedAssetsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUpstreamLeasedAssetsActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(UpstreamLeasedAssetsActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUpstreamLeasedAssetsActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUpstreamLeasedAssetsActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUpstreamLeasedAssetsActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyUpstreamLeasedAssetsActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUpstreamLeasedAssetsActivityDataResponseDto {
    data: UpstreamLeasedAssetsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class UpstreamLeasedAssetsActivityData implements IUpstreamLeasedAssetsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    activityType: UpstreamLeasedAssetsActivityDataActivityType;
    type: string;
    fuel_type: string;
    fuel_quntity: number;
    fuel_quntity_unit: string;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    process_emission: number;
    process_emission_unit: string;
    scp1scp2_emissions_lessor: number;
    scp1scp2_emissions_lessor_unit: string;
    lessor_type: string;
    lease_assests_ratio: number;
    total_floor_space: number;
    total_floor_space_unit: string;
    building_type: string;
    number_of_assets: number;
    asset_type: string;
    user_input_ef: number;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: UpstreamLeasedAssetsActivityDataActivityDataStatus;

    constructor(data?: IUpstreamLeasedAssetsActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.activityType = _data["activityType"];
            this.type = _data["type"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_quntity = _data["fuel_quntity"];
            this.fuel_quntity_unit = _data["fuel_quntity_unit"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.refrigerant_quntity = _data["refrigerant_quntity"];
            this.refrigerant_quntity_unit = _data["refrigerant_quntity_unit"];
            this.process_emission = _data["process_emission"];
            this.process_emission_unit = _data["process_emission_unit"];
            this.scp1scp2_emissions_lessor = _data["scp1scp2_emissions_lessor"];
            this.scp1scp2_emissions_lessor_unit = _data["scp1scp2_emissions_lessor_unit"];
            this.lessor_type = _data["lessor_type"];
            this.lease_assests_ratio = _data["lease_assests_ratio"];
            this.total_floor_space = _data["total_floor_space"];
            this.total_floor_space_unit = _data["total_floor_space_unit"];
            this.building_type = _data["building_type"];
            this.number_of_assets = _data["number_of_assets"];
            this.asset_type = _data["asset_type"];
            this.user_input_ef = _data["user_input_ef"];
            this.emission = _data["emission"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): UpstreamLeasedAssetsActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new UpstreamLeasedAssetsActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["activityType"] = this.activityType;
        data["type"] = this.type;
        data["fuel_type"] = this.fuel_type;
        data["fuel_quntity"] = this.fuel_quntity;
        data["fuel_quntity_unit"] = this.fuel_quntity_unit;
        data["refrigerant_type"] = this.refrigerant_type;
        data["refrigerant_quntity"] = this.refrigerant_quntity;
        data["refrigerant_quntity_unit"] = this.refrigerant_quntity_unit;
        data["process_emission"] = this.process_emission;
        data["process_emission_unit"] = this.process_emission_unit;
        data["scp1scp2_emissions_lessor"] = this.scp1scp2_emissions_lessor;
        data["scp1scp2_emissions_lessor_unit"] = this.scp1scp2_emissions_lessor_unit;
        data["lessor_type"] = this.lessor_type;
        data["lease_assests_ratio"] = this.lease_assests_ratio;
        data["total_floor_space"] = this.total_floor_space;
        data["total_floor_space_unit"] = this.total_floor_space_unit;
        data["building_type"] = this.building_type;
        data["number_of_assets"] = this.number_of_assets;
        data["asset_type"] = this.asset_type;
        data["user_input_ef"] = this.user_input_ef;
        data["emission"] = this.emission;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): UpstreamLeasedAssetsActivityData {
        const json = this.toJSON();
        let result = new UpstreamLeasedAssetsActivityData();
        result.init(json);
        return result;
    }
}

export interface IUpstreamLeasedAssetsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    activityType: UpstreamLeasedAssetsActivityDataActivityType;
    type: string;
    fuel_type: string;
    fuel_quntity: number;
    fuel_quntity_unit: string;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    process_emission: number;
    process_emission_unit: string;
    scp1scp2_emissions_lessor: number;
    scp1scp2_emissions_lessor_unit: string;
    lessor_type: string;
    lease_assests_ratio: number;
    total_floor_space: number;
    total_floor_space_unit: string;
    building_type: string;
    number_of_assets: number;
    asset_type: string;
    user_input_ef: number;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: UpstreamLeasedAssetsActivityDataActivityDataStatus;
}

export class CreateManyUpstreamLeasedAssetsActivityDataDto implements ICreateManyUpstreamLeasedAssetsActivityDataDto {
    bulk: UpstreamLeasedAssetsActivityData[];

    constructor(data?: ICreateManyUpstreamLeasedAssetsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(UpstreamLeasedAssetsActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUpstreamLeasedAssetsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUpstreamLeasedAssetsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyUpstreamLeasedAssetsActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyUpstreamLeasedAssetsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUpstreamLeasedAssetsActivityDataDto {
    bulk: UpstreamLeasedAssetsActivityData[];
}

export class FuelBasede_Data implements IFuelBasede_Data {
    id: number;
    fuel_type: string;
    typeName: string;
    quntity_unit: string;
    quntity: number | undefined;
    user_input_ef: number | undefined;

    constructor(data?: IFuelBasede_Data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fuel_type = _data["fuel_type"];
            this.typeName = _data["typeName"];
            this.quntity_unit = _data["quntity_unit"];
            this.quntity = _data["quntity"];
            this.user_input_ef = _data["user_input_ef"];
        }
    }

    static fromJS(data: any): FuelBasede_Data {
        data = typeof data === 'object' ? data : {};
        let result = new FuelBasede_Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fuel_type"] = this.fuel_type;
        data["typeName"] = this.typeName;
        data["quntity_unit"] = this.quntity_unit;
        data["quntity"] = this.quntity;
        data["user_input_ef"] = this.user_input_ef;
        return data;
    }

    clone(): FuelBasede_Data {
        const json = this.toJSON();
        let result = new FuelBasede_Data();
        result.init(json);
        return result;
    }
}

export interface IFuelBasede_Data {
    id: number;
    fuel_type: string;
    typeName: string;
    quntity_unit: string;
    quntity: number | undefined;
    user_input_ef: number | undefined;
}

export class RefrigerantBasde_Data implements IRefrigerantBasde_Data {
    id: number;
    refrigerant_type: string;
    typeName: string;
    quntity: number | undefined;
    quntity_unit: string;

    constructor(data?: IRefrigerantBasde_Data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.typeName = _data["typeName"];
            this.quntity = _data["quntity"];
            this.quntity_unit = _data["quntity_unit"];
        }
    }

    static fromJS(data: any): RefrigerantBasde_Data {
        data = typeof data === 'object' ? data : {};
        let result = new RefrigerantBasde_Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["refrigerant_type"] = this.refrigerant_type;
        data["typeName"] = this.typeName;
        data["quntity"] = this.quntity;
        data["quntity_unit"] = this.quntity_unit;
        return data;
    }

    clone(): RefrigerantBasde_Data {
        const json = this.toJSON();
        let result = new RefrigerantBasde_Data();
        result.init(json);
        return result;
    }
}

export interface IRefrigerantBasde_Data {
    id: number;
    refrigerant_type: string;
    typeName: string;
    quntity: number | undefined;
    quntity_unit: string;
}

export class WasteBasede_Data implements IWasteBasede_Data {
    id: number;
    disposalMethod: string;
    typeName: string;
    waste_type: string;
    mass: number | undefined;
    mass_unit: string;

    constructor(data?: IWasteBasede_Data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.disposalMethod = _data["disposalMethod"];
            this.typeName = _data["typeName"];
            this.waste_type = _data["waste_type"];
            this.mass = _data["mass"];
            this.mass_unit = _data["mass_unit"];
        }
    }

    static fromJS(data: any): WasteBasede_Data {
        data = typeof data === 'object' ? data : {};
        let result = new WasteBasede_Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["disposalMethod"] = this.disposalMethod;
        data["typeName"] = this.typeName;
        data["waste_type"] = this.waste_type;
        data["mass"] = this.mass;
        data["mass_unit"] = this.mass_unit;
        return data;
    }

    clone(): WasteBasede_Data {
        const json = this.toJSON();
        let result = new WasteBasede_Data();
        result.init(json);
        return result;
    }
}

export interface IWasteBasede_Data {
    id: number;
    disposalMethod: string;
    typeName: string;
    waste_type: string;
    mass: number | undefined;
    mass_unit: string;
}

export class SiteSpecificMethodCO2Data implements ISiteSpecificMethodCO2Data {
    fuel_data: FuelBasede_Data[];
    refrigerant_data: RefrigerantBasde_Data[];
    waste_data: WasteBasede_Data[];

    constructor(data?: ISiteSpecificMethodCO2Data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fuel_data = [];
            this.refrigerant_data = [];
            this.waste_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fuel_data"])) {
                this.fuel_data = [] as any;
                for (let item of _data["fuel_data"])
                    this.fuel_data.push(FuelBasede_Data.fromJS(item));
            }
            if (Array.isArray(_data["refrigerant_data"])) {
                this.refrigerant_data = [] as any;
                for (let item of _data["refrigerant_data"])
                    this.refrigerant_data.push(RefrigerantBasde_Data.fromJS(item));
            }
            if (Array.isArray(_data["waste_data"])) {
                this.waste_data = [] as any;
                for (let item of _data["waste_data"])
                    this.waste_data.push(WasteBasede_Data.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SiteSpecificMethodCO2Data {
        data = typeof data === 'object' ? data : {};
        let result = new SiteSpecificMethodCO2Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fuel_data)) {
            data["fuel_data"] = [];
            for (let item of this.fuel_data)
                data["fuel_data"].push(item.toJSON());
        }
        if (Array.isArray(this.refrigerant_data)) {
            data["refrigerant_data"] = [];
            for (let item of this.refrigerant_data)
                data["refrigerant_data"].push(item.toJSON());
        }
        if (Array.isArray(this.waste_data)) {
            data["waste_data"] = [];
            for (let item of this.waste_data)
                data["waste_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): SiteSpecificMethodCO2Data {
        const json = this.toJSON();
        let result = new SiteSpecificMethodCO2Data();
        result.init(json);
        return result;
    }
}

export interface ISiteSpecificMethodCO2Data {
    fuel_data: FuelBasede_Data[];
    refrigerant_data: RefrigerantBasde_Data[];
    waste_data: WasteBasede_Data[];
}

export class AverageDataMethodData implements IAverageDataMethodData {
    id: number;
    sold_intermediate_type: string;
    mass: number | undefined;
    mass_unit: string;
    user_input_ef: number | undefined;

    constructor(data?: IAverageDataMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sold_intermediate_type = _data["sold_intermediate_type"];
            this.mass = _data["mass"];
            this.mass_unit = _data["mass_unit"];
            this.user_input_ef = _data["user_input_ef"];
        }
    }

    static fromJS(data: any): AverageDataMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new AverageDataMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sold_intermediate_type"] = this.sold_intermediate_type;
        data["mass"] = this.mass;
        data["mass_unit"] = this.mass_unit;
        data["user_input_ef"] = this.user_input_ef;
        return data;
    }

    clone(): AverageDataMethodData {
        const json = this.toJSON();
        let result = new AverageDataMethodData();
        result.init(json);
        return result;
    }
}

export interface IAverageDataMethodData {
    id: number;
    sold_intermediate_type: string;
    mass: number | undefined;
    mass_unit: string;
    user_input_ef: number | undefined;
}

export class ProcessingOfSoldProductsActivityDataDto implements IProcessingOfSoldProductsActivityDataDto {
    month: number;
    year: number;
    activityType: ProcessingOfSoldProductsActivityDataDtoActivityType;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: ProcessingOfSoldProductsActivityDataDtoActivityDataStatus;
    groupNo: string;
    site_specific_method_cO2_data: SiteSpecificMethodCO2Data;
    average_data_method: AverageDataMethodData[];

    constructor(data?: IProcessingOfSoldProductsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.site_specific_method_cO2_data = new SiteSpecificMethodCO2Data();
            this.average_data_method = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.activityType = _data["activityType"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.site_specific_method_cO2_data = _data["site_specific_method_cO2_data"] ? SiteSpecificMethodCO2Data.fromJS(_data["site_specific_method_cO2_data"]) : new SiteSpecificMethodCO2Data();
            if (Array.isArray(_data["average_data_method"])) {
                this.average_data_method = [] as any;
                for (let item of _data["average_data_method"])
                    this.average_data_method.push(AverageDataMethodData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessingOfSoldProductsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessingOfSoldProductsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["activityType"] = this.activityType;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["site_specific_method_cO2_data"] = this.site_specific_method_cO2_data ? this.site_specific_method_cO2_data.toJSON() : <any>undefined;
        if (Array.isArray(this.average_data_method)) {
            data["average_data_method"] = [];
            for (let item of this.average_data_method)
                data["average_data_method"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProcessingOfSoldProductsActivityDataDto {
        const json = this.toJSON();
        let result = new ProcessingOfSoldProductsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IProcessingOfSoldProductsActivityDataDto {
    month: number;
    year: number;
    activityType: ProcessingOfSoldProductsActivityDataDtoActivityType;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: ProcessingOfSoldProductsActivityDataDtoActivityDataStatus;
    groupNo: string;
    site_specific_method_cO2_data: SiteSpecificMethodCO2Data;
    average_data_method: AverageDataMethodData[];
}

export class GetManyProcessingOfSoldProductsActivityDataResponseDto implements IGetManyProcessingOfSoldProductsActivityDataResponseDto {
    data: ProcessingOfSoldProductsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProcessingOfSoldProductsActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProcessingOfSoldProductsActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProcessingOfSoldProductsActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProcessingOfSoldProductsActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProcessingOfSoldProductsActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyProcessingOfSoldProductsActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProcessingOfSoldProductsActivityDataResponseDto {
    data: ProcessingOfSoldProductsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ProcessingOfSoldProductsActivityData implements IProcessingOfSoldProductsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    activityType: ProcessingOfSoldProductsActivityDataActivityType;
    type: string;
    fuel_type: string;
    quntity: number;
    refrigerant_type: string;
    quntity_unit: string;
    disposalMethod: string;
    waste_type: string;
    mass: number;
    mass_unit: string;
    sold_intermediate_type: string;
    sold_intermediate_mass_unit: string;
    emission: number;
    user_input_ef: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: ProcessingOfSoldProductsActivityDataActivityDataStatus;

    constructor(data?: IProcessingOfSoldProductsActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.activityType = _data["activityType"];
            this.type = _data["type"];
            this.fuel_type = _data["fuel_type"];
            this.quntity = _data["quntity"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.quntity_unit = _data["quntity_unit"];
            this.disposalMethod = _data["disposalMethod"];
            this.waste_type = _data["waste_type"];
            this.mass = _data["mass"];
            this.mass_unit = _data["mass_unit"];
            this.sold_intermediate_type = _data["sold_intermediate_type"];
            this.sold_intermediate_mass_unit = _data["sold_intermediate_mass_unit"];
            this.emission = _data["emission"];
            this.user_input_ef = _data["user_input_ef"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): ProcessingOfSoldProductsActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessingOfSoldProductsActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["activityType"] = this.activityType;
        data["type"] = this.type;
        data["fuel_type"] = this.fuel_type;
        data["quntity"] = this.quntity;
        data["refrigerant_type"] = this.refrigerant_type;
        data["quntity_unit"] = this.quntity_unit;
        data["disposalMethod"] = this.disposalMethod;
        data["waste_type"] = this.waste_type;
        data["mass"] = this.mass;
        data["mass_unit"] = this.mass_unit;
        data["sold_intermediate_type"] = this.sold_intermediate_type;
        data["sold_intermediate_mass_unit"] = this.sold_intermediate_mass_unit;
        data["emission"] = this.emission;
        data["user_input_ef"] = this.user_input_ef;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): ProcessingOfSoldProductsActivityData {
        const json = this.toJSON();
        let result = new ProcessingOfSoldProductsActivityData();
        result.init(json);
        return result;
    }
}

export interface IProcessingOfSoldProductsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    activityType: ProcessingOfSoldProductsActivityDataActivityType;
    type: string;
    fuel_type: string;
    quntity: number;
    refrigerant_type: string;
    quntity_unit: string;
    disposalMethod: string;
    waste_type: string;
    mass: number;
    mass_unit: string;
    sold_intermediate_type: string;
    sold_intermediate_mass_unit: string;
    emission: number;
    user_input_ef: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: ProcessingOfSoldProductsActivityDataActivityDataStatus;
}

export class CreateManyProcessingOfSoldProductsActivityDataDto implements ICreateManyProcessingOfSoldProductsActivityDataDto {
    bulk: ProcessingOfSoldProductsActivityData[];

    constructor(data?: ICreateManyProcessingOfSoldProductsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ProcessingOfSoldProductsActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProcessingOfSoldProductsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProcessingOfSoldProductsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyProcessingOfSoldProductsActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyProcessingOfSoldProductsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProcessingOfSoldProductsActivityDataDto {
    bulk: ProcessingOfSoldProductsActivityData[];
}

export class SpecificMethodParameters implements ISpecificMethodParameters {
    id: number;
    typeName: string;
    scopeOneEmission: number;
    scopeOneEmission_unit: string;
    scopeTwoEmission: number;
    scopeTwoEmission_unit: string;

    constructor(data?: ISpecificMethodParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.scopeOneEmission = _data["scopeOneEmission"];
            this.scopeOneEmission_unit = _data["scopeOneEmission_unit"];
            this.scopeTwoEmission = _data["scopeTwoEmission"];
            this.scopeTwoEmission_unit = _data["scopeTwoEmission_unit"];
        }
    }

    static fromJS(data: any): SpecificMethodParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SpecificMethodParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["scopeOneEmission"] = this.scopeOneEmission;
        data["scopeOneEmission_unit"] = this.scopeOneEmission_unit;
        data["scopeTwoEmission"] = this.scopeTwoEmission;
        data["scopeTwoEmission_unit"] = this.scopeTwoEmission_unit;
        return data;
    }

    clone(): SpecificMethodParameters {
        const json = this.toJSON();
        let result = new SpecificMethodParameters();
        result.init(json);
        return result;
    }
}

export interface ISpecificMethodParameters {
    id: number;
    typeName: string;
    scopeOneEmission: number;
    scopeOneEmission_unit: string;
    scopeTwoEmission: number;
    scopeTwoEmission_unit: string;
}

export class SpecificMethodData implements ISpecificMethodData {
    data: SpecificMethodParameters[];

    constructor(data?: ISpecificMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(SpecificMethodParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpecificMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new SpecificMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }

    clone(): SpecificMethodData {
        const json = this.toJSON();
        let result = new SpecificMethodData();
        result.init(json);
        return result;
    }
}

export interface ISpecificMethodData {
    data: SpecificMethodParameters[];
}

export class NotSubMeteredParameters implements INotSubMeteredParameters {
    id: number;
    typeName: string;
    franchises_area: number;
    franchises_area_unit: string;
    building_total_area: number;
    building_total_area_unit: string;
    building_occupancy_rate: number;
    building_occupancy_rate_unit: string;
    building_total_energy_use: number;
    building_total_energy_use_unit: string;

    constructor(data?: INotSubMeteredParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.franchises_area = _data["franchises_area"];
            this.franchises_area_unit = _data["franchises_area_unit"];
            this.building_total_area = _data["building_total_area"];
            this.building_total_area_unit = _data["building_total_area_unit"];
            this.building_occupancy_rate = _data["building_occupancy_rate"];
            this.building_occupancy_rate_unit = _data["building_occupancy_rate_unit"];
            this.building_total_energy_use = _data["building_total_energy_use"];
            this.building_total_energy_use_unit = _data["building_total_energy_use_unit"];
        }
    }

    static fromJS(data: any): NotSubMeteredParameters {
        data = typeof data === 'object' ? data : {};
        let result = new NotSubMeteredParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["franchises_area"] = this.franchises_area;
        data["franchises_area_unit"] = this.franchises_area_unit;
        data["building_total_area"] = this.building_total_area;
        data["building_total_area_unit"] = this.building_total_area_unit;
        data["building_occupancy_rate"] = this.building_occupancy_rate;
        data["building_occupancy_rate_unit"] = this.building_occupancy_rate_unit;
        data["building_total_energy_use"] = this.building_total_energy_use;
        data["building_total_energy_use_unit"] = this.building_total_energy_use_unit;
        return data;
    }

    clone(): NotSubMeteredParameters {
        const json = this.toJSON();
        let result = new NotSubMeteredParameters();
        result.init(json);
        return result;
    }
}

export interface INotSubMeteredParameters {
    id: number;
    typeName: string;
    franchises_area: number;
    franchises_area_unit: string;
    building_total_area: number;
    building_total_area_unit: string;
    building_occupancy_rate: number;
    building_occupancy_rate_unit: string;
    building_total_energy_use: number;
    building_total_energy_use_unit: string;
}

export class NotSubMeteredData implements INotSubMeteredData {
    data: NotSubMeteredParameters[];

    constructor(data?: INotSubMeteredData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(NotSubMeteredParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotSubMeteredData {
        data = typeof data === 'object' ? data : {};
        let result = new NotSubMeteredData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }

    clone(): NotSubMeteredData {
        const json = this.toJSON();
        let result = new NotSubMeteredData();
        result.init(json);
        return result;
    }
}

export interface INotSubMeteredData {
    data: NotSubMeteredParameters[];
}

export class SampleGroupParameters implements ISampleGroupParameters {
    id: number;
    typeName: string;
    total_e_of_sampled_franchises: number;
    total_number_of_franchises: number;
    number_of_franchises_sampled: number;

    constructor(data?: ISampleGroupParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.total_e_of_sampled_franchises = _data["total_e_of_sampled_franchises"];
            this.total_number_of_franchises = _data["total_number_of_franchises"];
            this.number_of_franchises_sampled = _data["number_of_franchises_sampled"];
        }
    }

    static fromJS(data: any): SampleGroupParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SampleGroupParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["total_e_of_sampled_franchises"] = this.total_e_of_sampled_franchises;
        data["total_number_of_franchises"] = this.total_number_of_franchises;
        data["number_of_franchises_sampled"] = this.number_of_franchises_sampled;
        return data;
    }

    clone(): SampleGroupParameters {
        const json = this.toJSON();
        let result = new SampleGroupParameters();
        result.init(json);
        return result;
    }
}

export interface ISampleGroupParameters {
    id: number;
    typeName: string;
    total_e_of_sampled_franchises: number;
    total_number_of_franchises: number;
    number_of_franchises_sampled: number;
}

export class SampleGroupsData implements ISampleGroupsData {
    data: SampleGroupParameters[];

    constructor(data?: ISampleGroupsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(SampleGroupParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SampleGroupsData {
        data = typeof data === 'object' ? data : {};
        let result = new SampleGroupsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }

    clone(): SampleGroupsData {
        const json = this.toJSON();
        let result = new SampleGroupsData();
        result.init(json);
        return result;
    }
}

export interface ISampleGroupsData {
    data: SampleGroupParameters[];
}

export class AverageDataMethodFloorSpaceDataParameters implements IAverageDataMethodFloorSpaceDataParameters {
    id: number;
    typeName: string;
    building_type_total_floor_space: number;
    building_type_total_floor_space_unit: string;
    building_type_average_emission_factor: number;
    building_type_average_emission_factor_unit: string;
    building_type: string;

    constructor(data?: IAverageDataMethodFloorSpaceDataParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.building_type_total_floor_space = _data["building_type_total_floor_space"];
            this.building_type_total_floor_space_unit = _data["building_type_total_floor_space_unit"];
            this.building_type_average_emission_factor = _data["building_type_average_emission_factor"];
            this.building_type_average_emission_factor_unit = _data["building_type_average_emission_factor_unit"];
            this.building_type = _data["building_type"];
        }
    }

    static fromJS(data: any): AverageDataMethodFloorSpaceDataParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AverageDataMethodFloorSpaceDataParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["building_type_total_floor_space"] = this.building_type_total_floor_space;
        data["building_type_total_floor_space_unit"] = this.building_type_total_floor_space_unit;
        data["building_type_average_emission_factor"] = this.building_type_average_emission_factor;
        data["building_type_average_emission_factor_unit"] = this.building_type_average_emission_factor_unit;
        data["building_type"] = this.building_type;
        return data;
    }

    clone(): AverageDataMethodFloorSpaceDataParameters {
        const json = this.toJSON();
        let result = new AverageDataMethodFloorSpaceDataParameters();
        result.init(json);
        return result;
    }
}

export interface IAverageDataMethodFloorSpaceDataParameters {
    id: number;
    typeName: string;
    building_type_total_floor_space: number;
    building_type_total_floor_space_unit: string;
    building_type_average_emission_factor: number;
    building_type_average_emission_factor_unit: string;
    building_type: string;
}

export class AverageDataMethodFloorSpaceData implements IAverageDataMethodFloorSpaceData {
    data: AverageDataMethodFloorSpaceDataParameters[];

    constructor(data?: IAverageDataMethodFloorSpaceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(AverageDataMethodFloorSpaceDataParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AverageDataMethodFloorSpaceData {
        data = typeof data === 'object' ? data : {};
        let result = new AverageDataMethodFloorSpaceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }

    clone(): AverageDataMethodFloorSpaceData {
        const json = this.toJSON();
        let result = new AverageDataMethodFloorSpaceData();
        result.init(json);
        return result;
    }
}

export interface IAverageDataMethodFloorSpaceData {
    data: AverageDataMethodFloorSpaceDataParameters[];
}

export class AverageDataMethodNotFloorSpaceDataParameters implements IAverageDataMethodNotFloorSpaceDataParameters {
    id: number;
    typeName: string;
    number_of_buildings: number;
    average_emissions_of_building: number;
    average_emissions_of_building_unit: string;
    asset_type: string;

    constructor(data?: IAverageDataMethodNotFloorSpaceDataParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.number_of_buildings = _data["number_of_buildings"];
            this.average_emissions_of_building = _data["average_emissions_of_building"];
            this.average_emissions_of_building_unit = _data["average_emissions_of_building_unit"];
            this.asset_type = _data["asset_type"];
        }
    }

    static fromJS(data: any): AverageDataMethodNotFloorSpaceDataParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AverageDataMethodNotFloorSpaceDataParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["number_of_buildings"] = this.number_of_buildings;
        data["average_emissions_of_building"] = this.average_emissions_of_building;
        data["average_emissions_of_building_unit"] = this.average_emissions_of_building_unit;
        data["asset_type"] = this.asset_type;
        return data;
    }

    clone(): AverageDataMethodNotFloorSpaceDataParameters {
        const json = this.toJSON();
        let result = new AverageDataMethodNotFloorSpaceDataParameters();
        result.init(json);
        return result;
    }
}

export interface IAverageDataMethodNotFloorSpaceDataParameters {
    id: number;
    typeName: string;
    number_of_buildings: number;
    average_emissions_of_building: number;
    average_emissions_of_building_unit: string;
    asset_type: string;
}

export class AverageDataMethodNotFloorSpaceData implements IAverageDataMethodNotFloorSpaceData {
    data: AverageDataMethodNotFloorSpaceDataParameters[];

    constructor(data?: IAverageDataMethodNotFloorSpaceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(AverageDataMethodNotFloorSpaceDataParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AverageDataMethodNotFloorSpaceData {
        data = typeof data === 'object' ? data : {};
        let result = new AverageDataMethodNotFloorSpaceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }

    clone(): AverageDataMethodNotFloorSpaceData {
        const json = this.toJSON();
        let result = new AverageDataMethodNotFloorSpaceData();
        result.init(json);
        return result;
    }
}

export interface IAverageDataMethodNotFloorSpaceData {
    data: AverageDataMethodNotFloorSpaceDataParameters[];
}

export class FranchisesActivityDataDto implements IFranchisesActivityDataDto {
    month: number;
    year: number;
    method: FranchisesActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FranchisesActivityDataDtoActivityDataStatus;
    groupNo: string;
    specific_method_data: SpecificMethodData;
    not_sub_metered_data: NotSubMeteredData;
    sample_groups_data: SampleGroupsData;
    average_data_method_floor_space_data: AverageDataMethodFloorSpaceData;
    average_data_method_not_floor_space_data: AverageDataMethodNotFloorSpaceData;

    constructor(data?: IFranchisesActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.specific_method_data = new SpecificMethodData();
            this.not_sub_metered_data = new NotSubMeteredData();
            this.sample_groups_data = new SampleGroupsData();
            this.average_data_method_floor_space_data = new AverageDataMethodFloorSpaceData();
            this.average_data_method_not_floor_space_data = new AverageDataMethodNotFloorSpaceData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.specific_method_data = _data["specific_method_data"] ? SpecificMethodData.fromJS(_data["specific_method_data"]) : new SpecificMethodData();
            this.not_sub_metered_data = _data["not_sub_metered_data"] ? NotSubMeteredData.fromJS(_data["not_sub_metered_data"]) : new NotSubMeteredData();
            this.sample_groups_data = _data["sample_groups_data"] ? SampleGroupsData.fromJS(_data["sample_groups_data"]) : new SampleGroupsData();
            this.average_data_method_floor_space_data = _data["average_data_method_floor_space_data"] ? AverageDataMethodFloorSpaceData.fromJS(_data["average_data_method_floor_space_data"]) : new AverageDataMethodFloorSpaceData();
            this.average_data_method_not_floor_space_data = _data["average_data_method_not_floor_space_data"] ? AverageDataMethodNotFloorSpaceData.fromJS(_data["average_data_method_not_floor_space_data"]) : new AverageDataMethodNotFloorSpaceData();
        }
    }

    static fromJS(data: any): FranchisesActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FranchisesActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["specific_method_data"] = this.specific_method_data ? this.specific_method_data.toJSON() : <any>undefined;
        data["not_sub_metered_data"] = this.not_sub_metered_data ? this.not_sub_metered_data.toJSON() : <any>undefined;
        data["sample_groups_data"] = this.sample_groups_data ? this.sample_groups_data.toJSON() : <any>undefined;
        data["average_data_method_floor_space_data"] = this.average_data_method_floor_space_data ? this.average_data_method_floor_space_data.toJSON() : <any>undefined;
        data["average_data_method_not_floor_space_data"] = this.average_data_method_not_floor_space_data ? this.average_data_method_not_floor_space_data.toJSON() : <any>undefined;
        return data;
    }

    clone(): FranchisesActivityDataDto {
        const json = this.toJSON();
        let result = new FranchisesActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IFranchisesActivityDataDto {
    month: number;
    year: number;
    method: FranchisesActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FranchisesActivityDataDtoActivityDataStatus;
    groupNo: string;
    specific_method_data: SpecificMethodData;
    not_sub_metered_data: NotSubMeteredData;
    sample_groups_data: SampleGroupsData;
    average_data_method_floor_space_data: AverageDataMethodFloorSpaceData;
    average_data_method_not_floor_space_data: AverageDataMethodNotFloorSpaceData;
}

export class GetManyFranchisesActivityDataResponseDto implements IGetManyFranchisesActivityDataResponseDto {
    data: FranchisesActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFranchisesActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FranchisesActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFranchisesActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFranchisesActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFranchisesActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyFranchisesActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFranchisesActivityDataResponseDto {
    data: FranchisesActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class FranchisesActivityData implements IFranchisesActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: FranchisesActivityDataMethod;
    type: string;
    typeName: string;
    scopeOneEmission: number;
    scopeOneEmission_unit: string;
    scopeTwoEmission: number;
    scopeTwoEmission_unit: string;
    franchises_area: number;
    franchises_area_unit: string;
    building_total_area: number;
    building_total_area_unit: string;
    building_occupancy_rate: number;
    building_occupancy_rate_unit: string;
    building_total_energy_use: number;
    building_total_energy_use_unit: string;
    total_e_of_sampled_franchises: number;
    total_number_of_franchises: number;
    number_of_franchises_sampled: number;
    building_type_total_floor_space: number;
    building_type_total_floor_space_unit: string;
    building_type_average_emission_factor: number;
    building_type_average_emission_factor_unit: string;
    building_type: string;
    number_of_buildings: number;
    average_emissions_of_building: number;
    average_emissions_of_building_unit: string;
    asset_type: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FranchisesActivityDataActivityDataStatus;

    constructor(data?: IFranchisesActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.type = _data["type"];
            this.typeName = _data["typeName"];
            this.scopeOneEmission = _data["scopeOneEmission"];
            this.scopeOneEmission_unit = _data["scopeOneEmission_unit"];
            this.scopeTwoEmission = _data["scopeTwoEmission"];
            this.scopeTwoEmission_unit = _data["scopeTwoEmission_unit"];
            this.franchises_area = _data["franchises_area"];
            this.franchises_area_unit = _data["franchises_area_unit"];
            this.building_total_area = _data["building_total_area"];
            this.building_total_area_unit = _data["building_total_area_unit"];
            this.building_occupancy_rate = _data["building_occupancy_rate"];
            this.building_occupancy_rate_unit = _data["building_occupancy_rate_unit"];
            this.building_total_energy_use = _data["building_total_energy_use"];
            this.building_total_energy_use_unit = _data["building_total_energy_use_unit"];
            this.total_e_of_sampled_franchises = _data["total_e_of_sampled_franchises"];
            this.total_number_of_franchises = _data["total_number_of_franchises"];
            this.number_of_franchises_sampled = _data["number_of_franchises_sampled"];
            this.building_type_total_floor_space = _data["building_type_total_floor_space"];
            this.building_type_total_floor_space_unit = _data["building_type_total_floor_space_unit"];
            this.building_type_average_emission_factor = _data["building_type_average_emission_factor"];
            this.building_type_average_emission_factor_unit = _data["building_type_average_emission_factor_unit"];
            this.building_type = _data["building_type"];
            this.number_of_buildings = _data["number_of_buildings"];
            this.average_emissions_of_building = _data["average_emissions_of_building"];
            this.average_emissions_of_building_unit = _data["average_emissions_of_building_unit"];
            this.asset_type = _data["asset_type"];
            this.emission = _data["emission"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): FranchisesActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new FranchisesActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["type"] = this.type;
        data["typeName"] = this.typeName;
        data["scopeOneEmission"] = this.scopeOneEmission;
        data["scopeOneEmission_unit"] = this.scopeOneEmission_unit;
        data["scopeTwoEmission"] = this.scopeTwoEmission;
        data["scopeTwoEmission_unit"] = this.scopeTwoEmission_unit;
        data["franchises_area"] = this.franchises_area;
        data["franchises_area_unit"] = this.franchises_area_unit;
        data["building_total_area"] = this.building_total_area;
        data["building_total_area_unit"] = this.building_total_area_unit;
        data["building_occupancy_rate"] = this.building_occupancy_rate;
        data["building_occupancy_rate_unit"] = this.building_occupancy_rate_unit;
        data["building_total_energy_use"] = this.building_total_energy_use;
        data["building_total_energy_use_unit"] = this.building_total_energy_use_unit;
        data["total_e_of_sampled_franchises"] = this.total_e_of_sampled_franchises;
        data["total_number_of_franchises"] = this.total_number_of_franchises;
        data["number_of_franchises_sampled"] = this.number_of_franchises_sampled;
        data["building_type_total_floor_space"] = this.building_type_total_floor_space;
        data["building_type_total_floor_space_unit"] = this.building_type_total_floor_space_unit;
        data["building_type_average_emission_factor"] = this.building_type_average_emission_factor;
        data["building_type_average_emission_factor_unit"] = this.building_type_average_emission_factor_unit;
        data["building_type"] = this.building_type;
        data["number_of_buildings"] = this.number_of_buildings;
        data["average_emissions_of_building"] = this.average_emissions_of_building;
        data["average_emissions_of_building_unit"] = this.average_emissions_of_building_unit;
        data["asset_type"] = this.asset_type;
        data["emission"] = this.emission;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): FranchisesActivityData {
        const json = this.toJSON();
        let result = new FranchisesActivityData();
        result.init(json);
        return result;
    }
}

export interface IFranchisesActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: FranchisesActivityDataMethod;
    type: string;
    typeName: string;
    scopeOneEmission: number;
    scopeOneEmission_unit: string;
    scopeTwoEmission: number;
    scopeTwoEmission_unit: string;
    franchises_area: number;
    franchises_area_unit: string;
    building_total_area: number;
    building_total_area_unit: string;
    building_occupancy_rate: number;
    building_occupancy_rate_unit: string;
    building_total_energy_use: number;
    building_total_energy_use_unit: string;
    total_e_of_sampled_franchises: number;
    total_number_of_franchises: number;
    number_of_franchises_sampled: number;
    building_type_total_floor_space: number;
    building_type_total_floor_space_unit: string;
    building_type_average_emission_factor: number;
    building_type_average_emission_factor_unit: string;
    building_type: string;
    number_of_buildings: number;
    average_emissions_of_building: number;
    average_emissions_of_building_unit: string;
    asset_type: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: FranchisesActivityDataActivityDataStatus;
}

export class CreateManyFranchisesActivityDataDto implements ICreateManyFranchisesActivityDataDto {
    bulk: FranchisesActivityData[];

    constructor(data?: ICreateManyFranchisesActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FranchisesActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFranchisesActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFranchisesActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFranchisesActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyFranchisesActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFranchisesActivityDataDto {
    bulk: FranchisesActivityData[];
}

export class FuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData implements IFuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
    id: number;
    fuel_type: string;
    fuel_quntity_unit: string;
    fuel_quntity: number;

    constructor(data?: IFuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_quntity_unit = _data["fuel_quntity_unit"];
            this.fuel_quntity = _data["fuel_quntity"];
        }
    }

    static fromJS(data: any): FuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fuel_type"] = this.fuel_type;
        data["fuel_quntity_unit"] = this.fuel_quntity_unit;
        data["fuel_quntity"] = this.fuel_quntity;
        return data;
    }

    clone(): FuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
        const json = this.toJSON();
        let result = new FuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IFuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
    id: number;
    fuel_type: string;
    fuel_quntity_unit: string;
    fuel_quntity: number;
}

export class RefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData implements IRefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
    id: number;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    process_emission: number;
    process_emission_unit: string;

    constructor(data?: IRefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.refrigerant_quntity = _data["refrigerant_quntity"];
            this.refrigerant_quntity_unit = _data["refrigerant_quntity_unit"];
            this.process_emission = _data["process_emission"];
            this.process_emission_unit = _data["process_emission_unit"];
        }
    }

    static fromJS(data: any): RefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new RefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["refrigerant_type"] = this.refrigerant_type;
        data["refrigerant_quntity"] = this.refrigerant_quntity;
        data["refrigerant_quntity_unit"] = this.refrigerant_quntity_unit;
        data["process_emission"] = this.process_emission;
        data["process_emission_unit"] = this.process_emission_unit;
        return data;
    }

    clone(): RefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
        const json = this.toJSON();
        let result = new RefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IRefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
    id: number;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    process_emission: number;
    process_emission_unit: string;
}

export class AssetSpecificDownstreamLeasedAssetsEmissionSourceData implements IAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
    fuel_data: FuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData[];
    refrigerant_data: RefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData[];

    constructor(data?: IAssetSpecificDownstreamLeasedAssetsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fuel_data = [];
            this.refrigerant_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fuel_data"])) {
                this.fuel_data = [] as any;
                for (let item of _data["fuel_data"])
                    this.fuel_data.push(FuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData.fromJS(item));
            }
            if (Array.isArray(_data["refrigerant_data"])) {
                this.refrigerant_data = [] as any;
                for (let item of _data["refrigerant_data"])
                    this.refrigerant_data.push(RefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssetSpecificDownstreamLeasedAssetsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fuel_data)) {
            data["fuel_data"] = [];
            for (let item of this.fuel_data)
                data["fuel_data"].push(item.toJSON());
        }
        if (Array.isArray(this.refrigerant_data)) {
            data["refrigerant_data"] = [];
            for (let item of this.refrigerant_data)
                data["refrigerant_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): AssetSpecificDownstreamLeasedAssetsEmissionSourceData {
        const json = this.toJSON();
        let result = new AssetSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface IAssetSpecificDownstreamLeasedAssetsEmissionSourceData {
    fuel_data: FuelBaseAssetSpecificDownstreamLeasedAssetsEmissionSourceData[];
    refrigerant_data: RefrigerantAssetSpecificDownstreamLeasedAssetsEmissionSourceData[];
}

export class LessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData implements ILessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData {
    id: number;
    user_input_ef: number;
    lessor_type: string;
    scp1scp2_emissions_lessor: number;
    scp1scp2_emissions_lessor_unit: string;
    lease_assests_ratio: number;

    constructor(data?: ILessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_input_ef = _data["user_input_ef"];
            this.lessor_type = _data["lessor_type"];
            this.scp1scp2_emissions_lessor = _data["scp1scp2_emissions_lessor"];
            this.scp1scp2_emissions_lessor_unit = _data["scp1scp2_emissions_lessor_unit"];
            this.lease_assests_ratio = _data["lease_assests_ratio"];
        }
    }

    static fromJS(data: any): LessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new LessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_input_ef"] = this.user_input_ef;
        data["lessor_type"] = this.lessor_type;
        data["scp1scp2_emissions_lessor"] = this.scp1scp2_emissions_lessor;
        data["scp1scp2_emissions_lessor_unit"] = this.scp1scp2_emissions_lessor_unit;
        data["lease_assests_ratio"] = this.lease_assests_ratio;
        return data;
    }

    clone(): LessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData {
        const json = this.toJSON();
        let result = new LessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface ILessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData {
    id: number;
    user_input_ef: number;
    lessor_type: string;
    scp1scp2_emissions_lessor: number;
    scp1scp2_emissions_lessor_unit: string;
    lease_assests_ratio: number;
}

export class LessorSpecificDownstreamLeasedAssetsEmissionSourceData implements ILessorSpecificDownstreamLeasedAssetsEmissionSourceData {
    lessor_data: LessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData[];

    constructor(data?: ILessorSpecificDownstreamLeasedAssetsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lessor_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lessor_data"])) {
                this.lessor_data = [] as any;
                for (let item of _data["lessor_data"])
                    this.lessor_data.push(LessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LessorSpecificDownstreamLeasedAssetsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new LessorSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lessor_data)) {
            data["lessor_data"] = [];
            for (let item of this.lessor_data)
                data["lessor_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): LessorSpecificDownstreamLeasedAssetsEmissionSourceData {
        const json = this.toJSON();
        let result = new LessorSpecificDownstreamLeasedAssetsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface ILessorSpecificDownstreamLeasedAssetsEmissionSourceData {
    lessor_data: LessorDataLessorSpecificDownstreamLeasedAssetsEmissionSourceData[];
}

export class LeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData implements ILeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData {
    id: number;
    user_input_ef: number;
    total_floor_space: number;
    total_floor_space_unit: string;
    building_type: string;

    constructor(data?: ILeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_input_ef = _data["user_input_ef"];
            this.total_floor_space = _data["total_floor_space"];
            this.total_floor_space_unit = _data["total_floor_space_unit"];
            this.building_type = _data["building_type"];
        }
    }

    static fromJS(data: any): LeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new LeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_input_ef"] = this.user_input_ef;
        data["total_floor_space"] = this.total_floor_space;
        data["total_floor_space_unit"] = this.total_floor_space_unit;
        data["building_type"] = this.building_type;
        return data;
    }

    clone(): LeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData {
        const json = this.toJSON();
        let result = new LeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface ILeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData {
    id: number;
    user_input_ef: number;
    total_floor_space: number;
    total_floor_space_unit: string;
    building_type: string;
}

export class LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData implements ILeasedBuildingsDownstreamLeasedAssetsEmissionSourceData {
    leased_data: LeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData[];

    constructor(data?: ILeasedBuildingsDownstreamLeasedAssetsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.leased_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["leased_data"])) {
                this.leased_data = [] as any;
                for (let item of _data["leased_data"])
                    this.leased_data.push(LeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.leased_data)) {
            data["leased_data"] = [];
            for (let item of this.leased_data)
                data["leased_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData {
        const json = this.toJSON();
        let result = new LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface ILeasedBuildingsDownstreamLeasedAssetsEmissionSourceData {
    leased_data: LeasedDataLeasedBuildingsDownstreamLeasedAssetsEmissionSourceData[];
}

export class LeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData implements ILeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData {
    user_input_ef: number;
    number_of_assets: number;
    asset_type: string;
    id: number;

    constructor(data?: ILeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_input_ef = _data["user_input_ef"];
            this.number_of_assets = _data["number_of_assets"];
            this.asset_type = _data["asset_type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new LeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_input_ef"] = this.user_input_ef;
        data["number_of_assets"] = this.number_of_assets;
        data["asset_type"] = this.asset_type;
        data["id"] = this.id;
        return data;
    }

    clone(): LeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData {
        const json = this.toJSON();
        let result = new LeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface ILeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData {
    user_input_ef: number;
    number_of_assets: number;
    asset_type: string;
    id: number;
}

export class LeasedAssetsDownstreamLeasedAssetsEmissionSourceData implements ILeasedAssetsDownstreamLeasedAssetsEmissionSourceData {
    leased_data: LeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData[];

    constructor(data?: ILeasedAssetsDownstreamLeasedAssetsEmissionSourceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.leased_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["leased_data"])) {
                this.leased_data = [] as any;
                for (let item of _data["leased_data"])
                    this.leased_data.push(LeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LeasedAssetsDownstreamLeasedAssetsEmissionSourceData {
        data = typeof data === 'object' ? data : {};
        let result = new LeasedAssetsDownstreamLeasedAssetsEmissionSourceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.leased_data)) {
            data["leased_data"] = [];
            for (let item of this.leased_data)
                data["leased_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): LeasedAssetsDownstreamLeasedAssetsEmissionSourceData {
        const json = this.toJSON();
        let result = new LeasedAssetsDownstreamLeasedAssetsEmissionSourceData();
        result.init(json);
        return result;
    }
}

export interface ILeasedAssetsDownstreamLeasedAssetsEmissionSourceData {
    leased_data: LeasedDataLeasedAssetsDownstreamLeasedAssetsEmissionSourceData[];
}

export class DownstreamLeasedAssetsActivityDataDto implements IDownstreamLeasedAssetsActivityDataDto {
    month: number;
    year: number;
    method: DownstreamLeasedAssetsActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: DownstreamLeasedAssetsActivityDataDtoActivityDataStatus;
    groupNo: string;
    asset_specific_method_data: AssetSpecificDownstreamLeasedAssetsEmissionSourceData;
    lessor_specific_method_data: LessorSpecificDownstreamLeasedAssetsEmissionSourceData;
    leased_buildings_method_data: LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData;
    leased_assets_method_data: LeasedAssetsDownstreamLeasedAssetsEmissionSourceData;

    constructor(data?: IDownstreamLeasedAssetsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.asset_specific_method_data = new AssetSpecificDownstreamLeasedAssetsEmissionSourceData();
            this.lessor_specific_method_data = new LessorSpecificDownstreamLeasedAssetsEmissionSourceData();
            this.leased_buildings_method_data = new LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData();
            this.leased_assets_method_data = new LeasedAssetsDownstreamLeasedAssetsEmissionSourceData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.asset_specific_method_data = _data["asset_specific_method_data"] ? AssetSpecificDownstreamLeasedAssetsEmissionSourceData.fromJS(_data["asset_specific_method_data"]) : new AssetSpecificDownstreamLeasedAssetsEmissionSourceData();
            this.lessor_specific_method_data = _data["lessor_specific_method_data"] ? LessorSpecificDownstreamLeasedAssetsEmissionSourceData.fromJS(_data["lessor_specific_method_data"]) : new LessorSpecificDownstreamLeasedAssetsEmissionSourceData();
            this.leased_buildings_method_data = _data["leased_buildings_method_data"] ? LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData.fromJS(_data["leased_buildings_method_data"]) : new LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData();
            this.leased_assets_method_data = _data["leased_assets_method_data"] ? LeasedAssetsDownstreamLeasedAssetsEmissionSourceData.fromJS(_data["leased_assets_method_data"]) : new LeasedAssetsDownstreamLeasedAssetsEmissionSourceData();
        }
    }

    static fromJS(data: any): DownstreamLeasedAssetsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new DownstreamLeasedAssetsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["asset_specific_method_data"] = this.asset_specific_method_data ? this.asset_specific_method_data.toJSON() : <any>undefined;
        data["lessor_specific_method_data"] = this.lessor_specific_method_data ? this.lessor_specific_method_data.toJSON() : <any>undefined;
        data["leased_buildings_method_data"] = this.leased_buildings_method_data ? this.leased_buildings_method_data.toJSON() : <any>undefined;
        data["leased_assets_method_data"] = this.leased_assets_method_data ? this.leased_assets_method_data.toJSON() : <any>undefined;
        return data;
    }

    clone(): DownstreamLeasedAssetsActivityDataDto {
        const json = this.toJSON();
        let result = new DownstreamLeasedAssetsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IDownstreamLeasedAssetsActivityDataDto {
    month: number;
    year: number;
    method: DownstreamLeasedAssetsActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: DownstreamLeasedAssetsActivityDataDtoActivityDataStatus;
    groupNo: string;
    asset_specific_method_data: AssetSpecificDownstreamLeasedAssetsEmissionSourceData;
    lessor_specific_method_data: LessorSpecificDownstreamLeasedAssetsEmissionSourceData;
    leased_buildings_method_data: LeasedBuildingsDownstreamLeasedAssetsEmissionSourceData;
    leased_assets_method_data: LeasedAssetsDownstreamLeasedAssetsEmissionSourceData;
}

export class GetManyDownstreamLeasedAssetsActivityDataResponseDto implements IGetManyDownstreamLeasedAssetsActivityDataResponseDto {
    data: DownstreamLeasedAssetsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyDownstreamLeasedAssetsActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(DownstreamLeasedAssetsActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyDownstreamLeasedAssetsActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyDownstreamLeasedAssetsActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyDownstreamLeasedAssetsActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyDownstreamLeasedAssetsActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyDownstreamLeasedAssetsActivityDataResponseDto {
    data: DownstreamLeasedAssetsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class DownstreamLeasedAssetsActivityData implements IDownstreamLeasedAssetsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: DownstreamLeasedAssetsActivityDataMethod;
    type: string;
    fuel_type: string;
    fuel_quntity: number;
    fuel_quntity_unit: string;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    process_emission: number;
    process_emission_unit: string;
    lessor_type: string;
    scp1scp2_emissions_lessor: number;
    scp1scp2_emissions_lessor_unit: string;
    lease_assests_ratio: number;
    total_floor_space: number;
    total_floor_space_unit: string;
    user_input_ef: any;
    building_type: string;
    number_of_assets: number;
    asset_type: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: DownstreamLeasedAssetsActivityDataActivityDataStatus;

    constructor(data?: IDownstreamLeasedAssetsActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.type = _data["type"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_quntity = _data["fuel_quntity"];
            this.fuel_quntity_unit = _data["fuel_quntity_unit"];
            this.refrigerant_type = _data["refrigerant_type"];
            this.refrigerant_quntity = _data["refrigerant_quntity"];
            this.refrigerant_quntity_unit = _data["refrigerant_quntity_unit"];
            this.process_emission = _data["process_emission"];
            this.process_emission_unit = _data["process_emission_unit"];
            this.lessor_type = _data["lessor_type"];
            this.scp1scp2_emissions_lessor = _data["scp1scp2_emissions_lessor"];
            this.scp1scp2_emissions_lessor_unit = _data["scp1scp2_emissions_lessor_unit"];
            this.lease_assests_ratio = _data["lease_assests_ratio"];
            this.total_floor_space = _data["total_floor_space"];
            this.total_floor_space_unit = _data["total_floor_space_unit"];
            this.user_input_ef = _data["user_input_ef"];
            this.building_type = _data["building_type"];
            this.number_of_assets = _data["number_of_assets"];
            this.asset_type = _data["asset_type"];
            this.emission = _data["emission"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): DownstreamLeasedAssetsActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new DownstreamLeasedAssetsActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["type"] = this.type;
        data["fuel_type"] = this.fuel_type;
        data["fuel_quntity"] = this.fuel_quntity;
        data["fuel_quntity_unit"] = this.fuel_quntity_unit;
        data["refrigerant_type"] = this.refrigerant_type;
        data["refrigerant_quntity"] = this.refrigerant_quntity;
        data["refrigerant_quntity_unit"] = this.refrigerant_quntity_unit;
        data["process_emission"] = this.process_emission;
        data["process_emission_unit"] = this.process_emission_unit;
        data["lessor_type"] = this.lessor_type;
        data["scp1scp2_emissions_lessor"] = this.scp1scp2_emissions_lessor;
        data["scp1scp2_emissions_lessor_unit"] = this.scp1scp2_emissions_lessor_unit;
        data["lease_assests_ratio"] = this.lease_assests_ratio;
        data["total_floor_space"] = this.total_floor_space;
        data["total_floor_space_unit"] = this.total_floor_space_unit;
        data["user_input_ef"] = this.user_input_ef;
        data["building_type"] = this.building_type;
        data["number_of_assets"] = this.number_of_assets;
        data["asset_type"] = this.asset_type;
        data["emission"] = this.emission;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): DownstreamLeasedAssetsActivityData {
        const json = this.toJSON();
        let result = new DownstreamLeasedAssetsActivityData();
        result.init(json);
        return result;
    }
}

export interface IDownstreamLeasedAssetsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: DownstreamLeasedAssetsActivityDataMethod;
    type: string;
    fuel_type: string;
    fuel_quntity: number;
    fuel_quntity_unit: string;
    refrigerant_type: string;
    refrigerant_quntity: number;
    refrigerant_quntity_unit: string;
    process_emission: number;
    process_emission_unit: string;
    lessor_type: string;
    scp1scp2_emissions_lessor: number;
    scp1scp2_emissions_lessor_unit: string;
    lease_assests_ratio: number;
    total_floor_space: number;
    total_floor_space_unit: string;
    user_input_ef: any;
    building_type: string;
    number_of_assets: number;
    asset_type: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: DownstreamLeasedAssetsActivityDataActivityDataStatus;
}

export class CreateManyDownstreamLeasedAssetsActivityDataDto implements ICreateManyDownstreamLeasedAssetsActivityDataDto {
    bulk: DownstreamLeasedAssetsActivityData[];

    constructor(data?: ICreateManyDownstreamLeasedAssetsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(DownstreamLeasedAssetsActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyDownstreamLeasedAssetsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyDownstreamLeasedAssetsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyDownstreamLeasedAssetsActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyDownstreamLeasedAssetsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyDownstreamLeasedAssetsActivityDataDto {
    bulk: DownstreamLeasedAssetsActivityData[];
}

export class FuelParameters implements IFuelParameters {
    id: number;
    typeName: string;
    quantity_of_fuel_consumed: number;
    quantity_of_fuel_consumed_unit: string;
    fuelBasefuelType: string;

    constructor(data?: IFuelParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.quantity_of_fuel_consumed = _data["quantity_of_fuel_consumed"];
            this.quantity_of_fuel_consumed_unit = _data["quantity_of_fuel_consumed_unit"];
            this.fuelBasefuelType = _data["fuelBasefuelType"];
        }
    }

    static fromJS(data: any): FuelParameters {
        data = typeof data === 'object' ? data : {};
        let result = new FuelParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["quantity_of_fuel_consumed"] = this.quantity_of_fuel_consumed;
        data["quantity_of_fuel_consumed_unit"] = this.quantity_of_fuel_consumed_unit;
        data["fuelBasefuelType"] = this.fuelBasefuelType;
        return data;
    }

    clone(): FuelParameters {
        const json = this.toJSON();
        let result = new FuelParameters();
        result.init(json);
        return result;
    }
}

export interface IFuelParameters {
    id: number;
    typeName: string;
    quantity_of_fuel_consumed: number;
    quantity_of_fuel_consumed_unit: string;
    fuelBasefuelType: string;
}

export class ElectricityParameters implements IElectricityParameters {
    id: number;
    typeName: string;
    quantity_of_electricity_consumed: number;
    quantity_of_electricity_consumed_unit: string;
    grid_region: string;

    constructor(data?: IElectricityParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.quantity_of_electricity_consumed = _data["quantity_of_electricity_consumed"];
            this.quantity_of_electricity_consumed_unit = _data["quantity_of_electricity_consumed_unit"];
            this.grid_region = _data["grid_region"];
        }
    }

    static fromJS(data: any): ElectricityParameters {
        data = typeof data === 'object' ? data : {};
        let result = new ElectricityParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["quantity_of_electricity_consumed"] = this.quantity_of_electricity_consumed;
        data["quantity_of_electricity_consumed_unit"] = this.quantity_of_electricity_consumed_unit;
        data["grid_region"] = this.grid_region;
        return data;
    }

    clone(): ElectricityParameters {
        const json = this.toJSON();
        let result = new ElectricityParameters();
        result.init(json);
        return result;
    }
}

export interface IElectricityParameters {
    id: number;
    typeName: string;
    quantity_of_electricity_consumed: number;
    quantity_of_electricity_consumed_unit: string;
    grid_region: string;
}

export class RefrigerentParameters implements IRefrigerentParameters {
    id: number;
    typeName: string;
    quantity_of_refrigerent_leaked: number;
    quantity_of_refrigerent_leaked_unit: string;
    fuelBaseRefrigerantType: string;

    constructor(data?: IRefrigerentParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.quantity_of_refrigerent_leaked = _data["quantity_of_refrigerent_leaked"];
            this.quantity_of_refrigerent_leaked_unit = _data["quantity_of_refrigerent_leaked_unit"];
            this.fuelBaseRefrigerantType = _data["fuelBaseRefrigerantType"];
        }
    }

    static fromJS(data: any): RefrigerentParameters {
        data = typeof data === 'object' ? data : {};
        let result = new RefrigerentParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["quantity_of_refrigerent_leaked"] = this.quantity_of_refrigerent_leaked;
        data["quantity_of_refrigerent_leaked_unit"] = this.quantity_of_refrigerent_leaked_unit;
        data["fuelBaseRefrigerantType"] = this.fuelBaseRefrigerantType;
        return data;
    }

    clone(): RefrigerentParameters {
        const json = this.toJSON();
        let result = new RefrigerentParameters();
        result.init(json);
        return result;
    }
}

export interface IRefrigerentParameters {
    id: number;
    typeName: string;
    quantity_of_refrigerent_leaked: number;
    quantity_of_refrigerent_leaked_unit: string;
    fuelBaseRefrigerantType: string;
}

export class BackhaulParameters implements IBackhaulParameters {
    id: number;
    typeName: string;
    quantity_of_fuel_consumed_from_backhaul: number;
    quantity_of_fuel_consumed_from_backhaul_unit: string;
    fuelBaseBackhaulFuelType: string;

    constructor(data?: IBackhaulParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.quantity_of_fuel_consumed_from_backhaul = _data["quantity_of_fuel_consumed_from_backhaul"];
            this.quantity_of_fuel_consumed_from_backhaul_unit = _data["quantity_of_fuel_consumed_from_backhaul_unit"];
            this.fuelBaseBackhaulFuelType = _data["fuelBaseBackhaulFuelType"];
        }
    }

    static fromJS(data: any): BackhaulParameters {
        data = typeof data === 'object' ? data : {};
        let result = new BackhaulParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["quantity_of_fuel_consumed_from_backhaul"] = this.quantity_of_fuel_consumed_from_backhaul;
        data["quantity_of_fuel_consumed_from_backhaul_unit"] = this.quantity_of_fuel_consumed_from_backhaul_unit;
        data["fuelBaseBackhaulFuelType"] = this.fuelBaseBackhaulFuelType;
        return data;
    }

    clone(): BackhaulParameters {
        const json = this.toJSON();
        let result = new BackhaulParameters();
        result.init(json);
        return result;
    }
}

export interface IBackhaulParameters {
    id: number;
    typeName: string;
    quantity_of_fuel_consumed_from_backhaul: number;
    quantity_of_fuel_consumed_from_backhaul_unit: string;
    fuelBaseBackhaulFuelType: string;
}

export class FuelBaseMethodData implements IFuelBaseMethodData {
    fuel_data: FuelParameters[];
    electricity_data: ElectricityParameters[];
    refrigerent_data: RefrigerentParameters[];
    backhaul_data: BackhaulParameters[];

    constructor(data?: IFuelBaseMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fuel_data = [];
            this.electricity_data = [];
            this.refrigerent_data = [];
            this.backhaul_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fuel_data"])) {
                this.fuel_data = [] as any;
                for (let item of _data["fuel_data"])
                    this.fuel_data.push(FuelParameters.fromJS(item));
            }
            if (Array.isArray(_data["electricity_data"])) {
                this.electricity_data = [] as any;
                for (let item of _data["electricity_data"])
                    this.electricity_data.push(ElectricityParameters.fromJS(item));
            }
            if (Array.isArray(_data["refrigerent_data"])) {
                this.refrigerent_data = [] as any;
                for (let item of _data["refrigerent_data"])
                    this.refrigerent_data.push(RefrigerentParameters.fromJS(item));
            }
            if (Array.isArray(_data["backhaul_data"])) {
                this.backhaul_data = [] as any;
                for (let item of _data["backhaul_data"])
                    this.backhaul_data.push(BackhaulParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FuelBaseMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelBaseMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fuel_data)) {
            data["fuel_data"] = [];
            for (let item of this.fuel_data)
                data["fuel_data"].push(item.toJSON());
        }
        if (Array.isArray(this.electricity_data)) {
            data["electricity_data"] = [];
            for (let item of this.electricity_data)
                data["electricity_data"].push(item.toJSON());
        }
        if (Array.isArray(this.refrigerent_data)) {
            data["refrigerent_data"] = [];
            for (let item of this.refrigerent_data)
                data["refrigerent_data"].push(item.toJSON());
        }
        if (Array.isArray(this.backhaul_data)) {
            data["backhaul_data"] = [];
            for (let item of this.backhaul_data)
                data["backhaul_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): FuelBaseMethodData {
        const json = this.toJSON();
        let result = new FuelBaseMethodData();
        result.init(json);
        return result;
    }
}

export interface IFuelBaseMethodData {
    fuel_data: FuelParameters[];
    electricity_data: ElectricityParameters[];
    refrigerent_data: RefrigerentParameters[];
    backhaul_data: BackhaulParameters[];
}

export class DistanceBaseMethodDataParameters implements IDistanceBaseMethodDataParameters {
    id: number;
    typeName: string;
    mass_of_goods_purchased: number;
    mass_of_goods_purchased_unit: string;
    distance_travelled_in_transport_leg: number;
    distance_travelled_in_transport_leg_unit: string;
    vehicle_type: string;

    constructor(data?: IDistanceBaseMethodDataParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.mass_of_goods_purchased = _data["mass_of_goods_purchased"];
            this.mass_of_goods_purchased_unit = _data["mass_of_goods_purchased_unit"];
            this.distance_travelled_in_transport_leg = _data["distance_travelled_in_transport_leg"];
            this.distance_travelled_in_transport_leg_unit = _data["distance_travelled_in_transport_leg_unit"];
            this.vehicle_type = _data["vehicle_type"];
        }
    }

    static fromJS(data: any): DistanceBaseMethodDataParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DistanceBaseMethodDataParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["mass_of_goods_purchased"] = this.mass_of_goods_purchased;
        data["mass_of_goods_purchased_unit"] = this.mass_of_goods_purchased_unit;
        data["distance_travelled_in_transport_leg"] = this.distance_travelled_in_transport_leg;
        data["distance_travelled_in_transport_leg_unit"] = this.distance_travelled_in_transport_leg_unit;
        data["vehicle_type"] = this.vehicle_type;
        return data;
    }

    clone(): DistanceBaseMethodDataParameters {
        const json = this.toJSON();
        let result = new DistanceBaseMethodDataParameters();
        result.init(json);
        return result;
    }
}

export interface IDistanceBaseMethodDataParameters {
    id: number;
    typeName: string;
    mass_of_goods_purchased: number;
    mass_of_goods_purchased_unit: string;
    distance_travelled_in_transport_leg: number;
    distance_travelled_in_transport_leg_unit: string;
    vehicle_type: string;
}

export class DistanceBaseMethodData implements IDistanceBaseMethodData {
    data: DistanceBaseMethodDataParameters[];

    constructor(data?: IDistanceBaseMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(DistanceBaseMethodDataParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DistanceBaseMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new DistanceBaseMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }

    clone(): DistanceBaseMethodData {
        const json = this.toJSON();
        let result = new DistanceBaseMethodData();
        result.init(json);
        return result;
    }
}

export interface IDistanceBaseMethodData {
    data: DistanceBaseMethodDataParameters[];
}

export class SpendBaseMethodDataParameters implements ISpendBaseMethodDataParameters {
    id: number;
    typeName: string;
    amount_spent_on_transportation_by_type: number;
    amount_spent_on_transportation_by_type_unit: string;
    shareOfTotalProjectCosts: number;
    shareOfTotalProjectCosts_unit: string;
    eEIO_factor: number;
    eEIO_factor_unit: string;

    constructor(data?: ISpendBaseMethodDataParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.amount_spent_on_transportation_by_type = _data["amount_spent_on_transportation_by_type"];
            this.amount_spent_on_transportation_by_type_unit = _data["amount_spent_on_transportation_by_type_unit"];
            this.shareOfTotalProjectCosts = _data["shareOfTotalProjectCosts"];
            this.shareOfTotalProjectCosts_unit = _data["shareOfTotalProjectCosts_unit"];
            this.eEIO_factor = _data["eEIO_factor"];
            this.eEIO_factor_unit = _data["eEIO_factor_unit"];
        }
    }

    static fromJS(data: any): SpendBaseMethodDataParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SpendBaseMethodDataParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["amount_spent_on_transportation_by_type"] = this.amount_spent_on_transportation_by_type;
        data["amount_spent_on_transportation_by_type_unit"] = this.amount_spent_on_transportation_by_type_unit;
        data["shareOfTotalProjectCosts"] = this.shareOfTotalProjectCosts;
        data["shareOfTotalProjectCosts_unit"] = this.shareOfTotalProjectCosts_unit;
        data["eEIO_factor"] = this.eEIO_factor;
        data["eEIO_factor_unit"] = this.eEIO_factor_unit;
        return data;
    }

    clone(): SpendBaseMethodDataParameters {
        const json = this.toJSON();
        let result = new SpendBaseMethodDataParameters();
        result.init(json);
        return result;
    }
}

export interface ISpendBaseMethodDataParameters {
    id: number;
    typeName: string;
    amount_spent_on_transportation_by_type: number;
    amount_spent_on_transportation_by_type_unit: string;
    shareOfTotalProjectCosts: number;
    shareOfTotalProjectCosts_unit: string;
    eEIO_factor: number;
    eEIO_factor_unit: string;
}

export class SpendBaseMethodData implements ISpendBaseMethodData {
    data: SpendBaseMethodDataParameters[];

    constructor(data?: ISpendBaseMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(SpendBaseMethodDataParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpendBaseMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new SpendBaseMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }

    clone(): SpendBaseMethodData {
        const json = this.toJSON();
        let result = new SpendBaseMethodData();
        result.init(json);
        return result;
    }
}

export interface ISpendBaseMethodData {
    data: SpendBaseMethodDataParameters[];
}

export class SiteSpecificMethodParameters implements ISiteSpecificMethodParameters {
    id: number;
    typeName: string;
    volume_of_reporting_companys_purchased_goods: number;
    volume_of_reporting_companys_purchased_goods_unit: string;
    total_volume_of_goods_in_storage_facility: number;
    total_volume_of_goods_in_storage_facility_unit: string;
    fuel_consumed: number;
    fuel_consumed_unit: string;
    electricity_consumed: number;
    electricity_consumed_unit: string;
    refrigerant_leakage: number;
    refrigerant_leakage_unit: string;
    refrigerantType: string;
    fuelType: string;

    constructor(data?: ISiteSpecificMethodParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.volume_of_reporting_companys_purchased_goods = _data["volume_of_reporting_companys_purchased_goods"];
            this.volume_of_reporting_companys_purchased_goods_unit = _data["volume_of_reporting_companys_purchased_goods_unit"];
            this.total_volume_of_goods_in_storage_facility = _data["total_volume_of_goods_in_storage_facility"];
            this.total_volume_of_goods_in_storage_facility_unit = _data["total_volume_of_goods_in_storage_facility_unit"];
            this.fuel_consumed = _data["fuel_consumed"];
            this.fuel_consumed_unit = _data["fuel_consumed_unit"];
            this.electricity_consumed = _data["electricity_consumed"];
            this.electricity_consumed_unit = _data["electricity_consumed_unit"];
            this.refrigerant_leakage = _data["refrigerant_leakage"];
            this.refrigerant_leakage_unit = _data["refrigerant_leakage_unit"];
            this.refrigerantType = _data["refrigerantType"];
            this.fuelType = _data["fuelType"];
        }
    }

    static fromJS(data: any): SiteSpecificMethodParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SiteSpecificMethodParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["volume_of_reporting_companys_purchased_goods"] = this.volume_of_reporting_companys_purchased_goods;
        data["volume_of_reporting_companys_purchased_goods_unit"] = this.volume_of_reporting_companys_purchased_goods_unit;
        data["total_volume_of_goods_in_storage_facility"] = this.total_volume_of_goods_in_storage_facility;
        data["total_volume_of_goods_in_storage_facility_unit"] = this.total_volume_of_goods_in_storage_facility_unit;
        data["fuel_consumed"] = this.fuel_consumed;
        data["fuel_consumed_unit"] = this.fuel_consumed_unit;
        data["electricity_consumed"] = this.electricity_consumed;
        data["electricity_consumed_unit"] = this.electricity_consumed_unit;
        data["refrigerant_leakage"] = this.refrigerant_leakage;
        data["refrigerant_leakage_unit"] = this.refrigerant_leakage_unit;
        data["refrigerantType"] = this.refrigerantType;
        data["fuelType"] = this.fuelType;
        return data;
    }

    clone(): SiteSpecificMethodParameters {
        const json = this.toJSON();
        let result = new SiteSpecificMethodParameters();
        result.init(json);
        return result;
    }
}

export interface ISiteSpecificMethodParameters {
    id: number;
    typeName: string;
    volume_of_reporting_companys_purchased_goods: number;
    volume_of_reporting_companys_purchased_goods_unit: string;
    total_volume_of_goods_in_storage_facility: number;
    total_volume_of_goods_in_storage_facility_unit: string;
    fuel_consumed: number;
    fuel_consumed_unit: string;
    electricity_consumed: number;
    electricity_consumed_unit: string;
    refrigerant_leakage: number;
    refrigerant_leakage_unit: string;
    refrigerantType: string;
    fuelType: string;
}

export class SiteSpecificMethodData implements ISiteSpecificMethodData {
    data: SiteSpecificMethodParameters[];

    constructor(data?: ISiteSpecificMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(SiteSpecificMethodParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SiteSpecificMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new SiteSpecificMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }

    clone(): SiteSpecificMethodData {
        const json = this.toJSON();
        let result = new SiteSpecificMethodData();
        result.init(json);
        return result;
    }
}

export interface ISiteSpecificMethodData {
    data: SiteSpecificMethodParameters[];
}

export class DTAverageDataMethodDataParameters implements IDTAverageDataMethodDataParameters {
    id: number;
    typeName: string;
    average_number_of_days_stored: number;
    storage_facility_ef: number;
    storage_facility_ef_unit: string;
    volume_of_stored_goods: number;
    volume_of_stored_goods_unit: string;

    constructor(data?: IDTAverageDataMethodDataParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.average_number_of_days_stored = _data["average_number_of_days_stored"];
            this.storage_facility_ef = _data["storage_facility_ef"];
            this.storage_facility_ef_unit = _data["storage_facility_ef_unit"];
            this.volume_of_stored_goods = _data["volume_of_stored_goods"];
            this.volume_of_stored_goods_unit = _data["volume_of_stored_goods_unit"];
        }
    }

    static fromJS(data: any): DTAverageDataMethodDataParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DTAverageDataMethodDataParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["average_number_of_days_stored"] = this.average_number_of_days_stored;
        data["storage_facility_ef"] = this.storage_facility_ef;
        data["storage_facility_ef_unit"] = this.storage_facility_ef_unit;
        data["volume_of_stored_goods"] = this.volume_of_stored_goods;
        data["volume_of_stored_goods_unit"] = this.volume_of_stored_goods_unit;
        return data;
    }

    clone(): DTAverageDataMethodDataParameters {
        const json = this.toJSON();
        let result = new DTAverageDataMethodDataParameters();
        result.init(json);
        return result;
    }
}

export interface IDTAverageDataMethodDataParameters {
    id: number;
    typeName: string;
    average_number_of_days_stored: number;
    storage_facility_ef: number;
    storage_facility_ef_unit: string;
    volume_of_stored_goods: number;
    volume_of_stored_goods_unit: string;
}

export class DTAverageDataMethodData implements IDTAverageDataMethodData {
    data: DTAverageDataMethodDataParameters[];

    constructor(data?: IDTAverageDataMethodData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(DTAverageDataMethodDataParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DTAverageDataMethodData {
        data = typeof data === 'object' ? data : {};
        let result = new DTAverageDataMethodData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }

    clone(): DTAverageDataMethodData {
        const json = this.toJSON();
        let result = new DTAverageDataMethodData();
        result.init(json);
        return result;
    }
}

export interface IDTAverageDataMethodData {
    data: DTAverageDataMethodDataParameters[];
}

export class DownstreamTransportationActivityDataDto implements IDownstreamTransportationActivityDataDto {
    month: number;
    year: number;
    method: DownstreamTransportationActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: DownstreamTransportationActivityDataDtoActivityDataStatus;
    groupNo: string;
    fule_based_method_data: FuelBaseMethodData;
    distance_based_method_data: DistanceBaseMethodData;
    spend_based_method_data: SpendBaseMethodData;
    site_specific_method_data: SiteSpecificMethodData;
    average_data_method_data: DTAverageDataMethodData;

    constructor(data?: IDownstreamTransportationActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.fule_based_method_data = new FuelBaseMethodData();
            this.distance_based_method_data = new DistanceBaseMethodData();
            this.spend_based_method_data = new SpendBaseMethodData();
            this.site_specific_method_data = new SiteSpecificMethodData();
            this.average_data_method_data = new DTAverageDataMethodData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.fule_based_method_data = _data["fule_based_method_data"] ? FuelBaseMethodData.fromJS(_data["fule_based_method_data"]) : new FuelBaseMethodData();
            this.distance_based_method_data = _data["distance_based_method_data"] ? DistanceBaseMethodData.fromJS(_data["distance_based_method_data"]) : new DistanceBaseMethodData();
            this.spend_based_method_data = _data["spend_based_method_data"] ? SpendBaseMethodData.fromJS(_data["spend_based_method_data"]) : new SpendBaseMethodData();
            this.site_specific_method_data = _data["site_specific_method_data"] ? SiteSpecificMethodData.fromJS(_data["site_specific_method_data"]) : new SiteSpecificMethodData();
            this.average_data_method_data = _data["average_data_method_data"] ? DTAverageDataMethodData.fromJS(_data["average_data_method_data"]) : new DTAverageDataMethodData();
        }
    }

    static fromJS(data: any): DownstreamTransportationActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new DownstreamTransportationActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["fule_based_method_data"] = this.fule_based_method_data ? this.fule_based_method_data.toJSON() : <any>undefined;
        data["distance_based_method_data"] = this.distance_based_method_data ? this.distance_based_method_data.toJSON() : <any>undefined;
        data["spend_based_method_data"] = this.spend_based_method_data ? this.spend_based_method_data.toJSON() : <any>undefined;
        data["site_specific_method_data"] = this.site_specific_method_data ? this.site_specific_method_data.toJSON() : <any>undefined;
        data["average_data_method_data"] = this.average_data_method_data ? this.average_data_method_data.toJSON() : <any>undefined;
        return data;
    }

    clone(): DownstreamTransportationActivityDataDto {
        const json = this.toJSON();
        let result = new DownstreamTransportationActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IDownstreamTransportationActivityDataDto {
    month: number;
    year: number;
    method: DownstreamTransportationActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: DownstreamTransportationActivityDataDtoActivityDataStatus;
    groupNo: string;
    fule_based_method_data: FuelBaseMethodData;
    distance_based_method_data: DistanceBaseMethodData;
    spend_based_method_data: SpendBaseMethodData;
    site_specific_method_data: SiteSpecificMethodData;
    average_data_method_data: DTAverageDataMethodData;
}

export class GetManyDownstreamTransportationActivityDataResponseDto implements IGetManyDownstreamTransportationActivityDataResponseDto {
    data: DownstreamTransportationActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyDownstreamTransportationActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(DownstreamTransportationActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyDownstreamTransportationActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyDownstreamTransportationActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyDownstreamTransportationActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyDownstreamTransportationActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyDownstreamTransportationActivityDataResponseDto {
    data: DownstreamTransportationActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class DownstreamTransportationActivityData implements IDownstreamTransportationActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: DownstreamTransportationActivityDataMethod;
    type: string;
    typeName: string;
    quantity_of_fuel_consumed: number;
    quantity_of_fuel_consumed_unit: string;
    fuelBasefuelType: string;
    quantity_of_electricity_consumed: number;
    quantity_of_electricity_consumed_unit: string;
    grid_region: string;
    quantity_of_refrigerent_leaked: number;
    quantity_of_refrigerent_leaked_unit: string;
    fuelBaseRefrigerantType: string;
    quantity_of_fuel_consumed_from_backhaul: number;
    quantity_of_fuel_consumed_from_backhaul_unit: string;
    fuelBaseBackhaulFuelType: string;
    mass_of_goods_purchased: number;
    mass_of_goods_purchased_unit: string;
    distance_travelled_in_transport_leg: number;
    distance_travelled_in_transport_leg_unit: string;
    vehicle_type: string;
    amount_spent_on_transportation_by_type: number;
    amount_spent_on_transportation_by_type_unit: string;
    shareOfTotalProjectCosts: number;
    shareOfTotalProjectCosts_unit: string;
    eEIO_factor: number;
    eEIO_factor_unit: string;
    volume_of_reporting_companys_purchased_goods: number;
    volume_of_reporting_companys_purchased_goods_unit: string;
    total_volume_of_goods_in_storage_facility: number;
    total_volume_of_goods_in_storage_facility_unit: string;
    fuel_consumed: number;
    fuel_consumed_unit: string;
    electricity_consumed: number;
    electricity_consumed_unit: string;
    refrigerant_leakage: number;
    refrigerant_leakage_unit: string;
    refrigerantType: string;
    fuelType: string;
    average_number_of_days_stored: number;
    storage_facility_ef: number;
    storage_facility_ef_unit: string;
    volume_of_stored_goods: number;
    volume_of_stored_goods_unit: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: DownstreamTransportationActivityDataActivityDataStatus;

    constructor(data?: IDownstreamTransportationActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.type = _data["type"];
            this.typeName = _data["typeName"];
            this.quantity_of_fuel_consumed = _data["quantity_of_fuel_consumed"];
            this.quantity_of_fuel_consumed_unit = _data["quantity_of_fuel_consumed_unit"];
            this.fuelBasefuelType = _data["fuelBasefuelType"];
            this.quantity_of_electricity_consumed = _data["quantity_of_electricity_consumed"];
            this.quantity_of_electricity_consumed_unit = _data["quantity_of_electricity_consumed_unit"];
            this.grid_region = _data["grid_region"];
            this.quantity_of_refrigerent_leaked = _data["quantity_of_refrigerent_leaked"];
            this.quantity_of_refrigerent_leaked_unit = _data["quantity_of_refrigerent_leaked_unit"];
            this.fuelBaseRefrigerantType = _data["fuelBaseRefrigerantType"];
            this.quantity_of_fuel_consumed_from_backhaul = _data["quantity_of_fuel_consumed_from_backhaul"];
            this.quantity_of_fuel_consumed_from_backhaul_unit = _data["quantity_of_fuel_consumed_from_backhaul_unit"];
            this.fuelBaseBackhaulFuelType = _data["fuelBaseBackhaulFuelType"];
            this.mass_of_goods_purchased = _data["mass_of_goods_purchased"];
            this.mass_of_goods_purchased_unit = _data["mass_of_goods_purchased_unit"];
            this.distance_travelled_in_transport_leg = _data["distance_travelled_in_transport_leg"];
            this.distance_travelled_in_transport_leg_unit = _data["distance_travelled_in_transport_leg_unit"];
            this.vehicle_type = _data["vehicle_type"];
            this.amount_spent_on_transportation_by_type = _data["amount_spent_on_transportation_by_type"];
            this.amount_spent_on_transportation_by_type_unit = _data["amount_spent_on_transportation_by_type_unit"];
            this.shareOfTotalProjectCosts = _data["shareOfTotalProjectCosts"];
            this.shareOfTotalProjectCosts_unit = _data["shareOfTotalProjectCosts_unit"];
            this.eEIO_factor = _data["eEIO_factor"];
            this.eEIO_factor_unit = _data["eEIO_factor_unit"];
            this.volume_of_reporting_companys_purchased_goods = _data["volume_of_reporting_companys_purchased_goods"];
            this.volume_of_reporting_companys_purchased_goods_unit = _data["volume_of_reporting_companys_purchased_goods_unit"];
            this.total_volume_of_goods_in_storage_facility = _data["total_volume_of_goods_in_storage_facility"];
            this.total_volume_of_goods_in_storage_facility_unit = _data["total_volume_of_goods_in_storage_facility_unit"];
            this.fuel_consumed = _data["fuel_consumed"];
            this.fuel_consumed_unit = _data["fuel_consumed_unit"];
            this.electricity_consumed = _data["electricity_consumed"];
            this.electricity_consumed_unit = _data["electricity_consumed_unit"];
            this.refrigerant_leakage = _data["refrigerant_leakage"];
            this.refrigerant_leakage_unit = _data["refrigerant_leakage_unit"];
            this.refrigerantType = _data["refrigerantType"];
            this.fuelType = _data["fuelType"];
            this.average_number_of_days_stored = _data["average_number_of_days_stored"];
            this.storage_facility_ef = _data["storage_facility_ef"];
            this.storage_facility_ef_unit = _data["storage_facility_ef_unit"];
            this.volume_of_stored_goods = _data["volume_of_stored_goods"];
            this.volume_of_stored_goods_unit = _data["volume_of_stored_goods_unit"];
            this.emission = _data["emission"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): DownstreamTransportationActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new DownstreamTransportationActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["type"] = this.type;
        data["typeName"] = this.typeName;
        data["quantity_of_fuel_consumed"] = this.quantity_of_fuel_consumed;
        data["quantity_of_fuel_consumed_unit"] = this.quantity_of_fuel_consumed_unit;
        data["fuelBasefuelType"] = this.fuelBasefuelType;
        data["quantity_of_electricity_consumed"] = this.quantity_of_electricity_consumed;
        data["quantity_of_electricity_consumed_unit"] = this.quantity_of_electricity_consumed_unit;
        data["grid_region"] = this.grid_region;
        data["quantity_of_refrigerent_leaked"] = this.quantity_of_refrigerent_leaked;
        data["quantity_of_refrigerent_leaked_unit"] = this.quantity_of_refrigerent_leaked_unit;
        data["fuelBaseRefrigerantType"] = this.fuelBaseRefrigerantType;
        data["quantity_of_fuel_consumed_from_backhaul"] = this.quantity_of_fuel_consumed_from_backhaul;
        data["quantity_of_fuel_consumed_from_backhaul_unit"] = this.quantity_of_fuel_consumed_from_backhaul_unit;
        data["fuelBaseBackhaulFuelType"] = this.fuelBaseBackhaulFuelType;
        data["mass_of_goods_purchased"] = this.mass_of_goods_purchased;
        data["mass_of_goods_purchased_unit"] = this.mass_of_goods_purchased_unit;
        data["distance_travelled_in_transport_leg"] = this.distance_travelled_in_transport_leg;
        data["distance_travelled_in_transport_leg_unit"] = this.distance_travelled_in_transport_leg_unit;
        data["vehicle_type"] = this.vehicle_type;
        data["amount_spent_on_transportation_by_type"] = this.amount_spent_on_transportation_by_type;
        data["amount_spent_on_transportation_by_type_unit"] = this.amount_spent_on_transportation_by_type_unit;
        data["shareOfTotalProjectCosts"] = this.shareOfTotalProjectCosts;
        data["shareOfTotalProjectCosts_unit"] = this.shareOfTotalProjectCosts_unit;
        data["eEIO_factor"] = this.eEIO_factor;
        data["eEIO_factor_unit"] = this.eEIO_factor_unit;
        data["volume_of_reporting_companys_purchased_goods"] = this.volume_of_reporting_companys_purchased_goods;
        data["volume_of_reporting_companys_purchased_goods_unit"] = this.volume_of_reporting_companys_purchased_goods_unit;
        data["total_volume_of_goods_in_storage_facility"] = this.total_volume_of_goods_in_storage_facility;
        data["total_volume_of_goods_in_storage_facility_unit"] = this.total_volume_of_goods_in_storage_facility_unit;
        data["fuel_consumed"] = this.fuel_consumed;
        data["fuel_consumed_unit"] = this.fuel_consumed_unit;
        data["electricity_consumed"] = this.electricity_consumed;
        data["electricity_consumed_unit"] = this.electricity_consumed_unit;
        data["refrigerant_leakage"] = this.refrigerant_leakage;
        data["refrigerant_leakage_unit"] = this.refrigerant_leakage_unit;
        data["refrigerantType"] = this.refrigerantType;
        data["fuelType"] = this.fuelType;
        data["average_number_of_days_stored"] = this.average_number_of_days_stored;
        data["storage_facility_ef"] = this.storage_facility_ef;
        data["storage_facility_ef_unit"] = this.storage_facility_ef_unit;
        data["volume_of_stored_goods"] = this.volume_of_stored_goods;
        data["volume_of_stored_goods_unit"] = this.volume_of_stored_goods_unit;
        data["emission"] = this.emission;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): DownstreamTransportationActivityData {
        const json = this.toJSON();
        let result = new DownstreamTransportationActivityData();
        result.init(json);
        return result;
    }
}

export interface IDownstreamTransportationActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: DownstreamTransportationActivityDataMethod;
    type: string;
    typeName: string;
    quantity_of_fuel_consumed: number;
    quantity_of_fuel_consumed_unit: string;
    fuelBasefuelType: string;
    quantity_of_electricity_consumed: number;
    quantity_of_electricity_consumed_unit: string;
    grid_region: string;
    quantity_of_refrigerent_leaked: number;
    quantity_of_refrigerent_leaked_unit: string;
    fuelBaseRefrigerantType: string;
    quantity_of_fuel_consumed_from_backhaul: number;
    quantity_of_fuel_consumed_from_backhaul_unit: string;
    fuelBaseBackhaulFuelType: string;
    mass_of_goods_purchased: number;
    mass_of_goods_purchased_unit: string;
    distance_travelled_in_transport_leg: number;
    distance_travelled_in_transport_leg_unit: string;
    vehicle_type: string;
    amount_spent_on_transportation_by_type: number;
    amount_spent_on_transportation_by_type_unit: string;
    shareOfTotalProjectCosts: number;
    shareOfTotalProjectCosts_unit: string;
    eEIO_factor: number;
    eEIO_factor_unit: string;
    volume_of_reporting_companys_purchased_goods: number;
    volume_of_reporting_companys_purchased_goods_unit: string;
    total_volume_of_goods_in_storage_facility: number;
    total_volume_of_goods_in_storage_facility_unit: string;
    fuel_consumed: number;
    fuel_consumed_unit: string;
    electricity_consumed: number;
    electricity_consumed_unit: string;
    refrigerant_leakage: number;
    refrigerant_leakage_unit: string;
    refrigerantType: string;
    fuelType: string;
    average_number_of_days_stored: number;
    storage_facility_ef: number;
    storage_facility_ef_unit: string;
    volume_of_stored_goods: number;
    volume_of_stored_goods_unit: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: DownstreamTransportationActivityDataActivityDataStatus;
}

export class CreateManyDownstreamTransportationActivityDataDto implements ICreateManyDownstreamTransportationActivityDataDto {
    bulk: DownstreamTransportationActivityData[];

    constructor(data?: ICreateManyDownstreamTransportationActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(DownstreamTransportationActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyDownstreamTransportationActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyDownstreamTransportationActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyDownstreamTransportationActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyDownstreamTransportationActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyDownstreamTransportationActivityDataDto {
    bulk: DownstreamTransportationActivityData[];
}

export class UpstreamTransportationActivityDataDto implements IUpstreamTransportationActivityDataDto {
    month: number;
    year: number;
    method: UpstreamTransportationActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: UpstreamTransportationActivityDataDtoActivityDataStatus;
    groupNo: string;
    fule_based_method_data: FuelBaseMethodData;
    distance_based_method_data: DistanceBaseMethodData;
    spend_based_method_data: SpendBaseMethodData;
    site_specific_method_data: SiteSpecificMethodData;
    average_data_method_data: DTAverageDataMethodData;

    constructor(data?: IUpstreamTransportationActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.fule_based_method_data = new FuelBaseMethodData();
            this.distance_based_method_data = new DistanceBaseMethodData();
            this.spend_based_method_data = new SpendBaseMethodData();
            this.site_specific_method_data = new SiteSpecificMethodData();
            this.average_data_method_data = new DTAverageDataMethodData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.fule_based_method_data = _data["fule_based_method_data"] ? FuelBaseMethodData.fromJS(_data["fule_based_method_data"]) : new FuelBaseMethodData();
            this.distance_based_method_data = _data["distance_based_method_data"] ? DistanceBaseMethodData.fromJS(_data["distance_based_method_data"]) : new DistanceBaseMethodData();
            this.spend_based_method_data = _data["spend_based_method_data"] ? SpendBaseMethodData.fromJS(_data["spend_based_method_data"]) : new SpendBaseMethodData();
            this.site_specific_method_data = _data["site_specific_method_data"] ? SiteSpecificMethodData.fromJS(_data["site_specific_method_data"]) : new SiteSpecificMethodData();
            this.average_data_method_data = _data["average_data_method_data"] ? DTAverageDataMethodData.fromJS(_data["average_data_method_data"]) : new DTAverageDataMethodData();
        }
    }

    static fromJS(data: any): UpstreamTransportationActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpstreamTransportationActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["fule_based_method_data"] = this.fule_based_method_data ? this.fule_based_method_data.toJSON() : <any>undefined;
        data["distance_based_method_data"] = this.distance_based_method_data ? this.distance_based_method_data.toJSON() : <any>undefined;
        data["spend_based_method_data"] = this.spend_based_method_data ? this.spend_based_method_data.toJSON() : <any>undefined;
        data["site_specific_method_data"] = this.site_specific_method_data ? this.site_specific_method_data.toJSON() : <any>undefined;
        data["average_data_method_data"] = this.average_data_method_data ? this.average_data_method_data.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpstreamTransportationActivityDataDto {
        const json = this.toJSON();
        let result = new UpstreamTransportationActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface IUpstreamTransportationActivityDataDto {
    month: number;
    year: number;
    method: UpstreamTransportationActivityDataDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: UpstreamTransportationActivityDataDtoActivityDataStatus;
    groupNo: string;
    fule_based_method_data: FuelBaseMethodData;
    distance_based_method_data: DistanceBaseMethodData;
    spend_based_method_data: SpendBaseMethodData;
    site_specific_method_data: SiteSpecificMethodData;
    average_data_method_data: DTAverageDataMethodData;
}

export class GetManyUpstreamTransportationActivityDataResponseDto implements IGetManyUpstreamTransportationActivityDataResponseDto {
    data: UpstreamTransportationActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUpstreamTransportationActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(UpstreamTransportationActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUpstreamTransportationActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUpstreamTransportationActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUpstreamTransportationActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyUpstreamTransportationActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUpstreamTransportationActivityDataResponseDto {
    data: UpstreamTransportationActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class UpstreamTransportationActivityData implements IUpstreamTransportationActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: UpstreamTransportationActivityDataMethod;
    type: string;
    typeName: string;
    quantity_of_fuel_consumed: number;
    quantity_of_fuel_consumed_unit: string;
    fuelBasefuelType: string;
    quantity_of_electricity_consumed: number;
    quantity_of_electricity_consumed_unit: string;
    grid_region: string;
    quantity_of_refrigerent_leaked: number;
    quantity_of_refrigerent_leaked_unit: string;
    fuelBaseRefrigerantType: string;
    quantity_of_fuel_consumed_from_backhaul: number;
    quantity_of_fuel_consumed_from_backhaul_unit: string;
    fuelBaseBackhaulFuelType: string;
    mass_of_goods_purchased: number;
    mass_of_goods_purchased_unit: string;
    distance_travelled_in_transport_leg: number;
    distance_travelled_in_transport_leg_unit: string;
    vehicle_type: string;
    amount_spent_on_transportation_by_type: number;
    amount_spent_on_transportation_by_type_unit: string;
    shareOfTotalProjectCosts: number;
    shareOfTotalProjectCosts_unit: string;
    eEIO_factor: number;
    eEIO_factor_unit: string;
    volume_of_reporting_companys_purchased_goods: number;
    volume_of_reporting_companys_purchased_goods_unit: string;
    total_volume_of_goods_in_storage_facility: number;
    total_volume_of_goods_in_storage_facility_unit: string;
    fuel_consumed: number;
    fuel_consumed_unit: string;
    electricity_consumed: number;
    electricity_consumed_unit: string;
    refrigerant_leakage: number;
    refrigerant_leakage_unit: string;
    refrigerantType: string;
    fuelType: string;
    average_number_of_days_stored: number;
    storage_facility_ef: number;
    storage_facility_ef_unit: string;
    volume_of_stored_goods: number;
    volume_of_stored_goods_unit: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: UpstreamTransportationActivityDataActivityDataStatus;

    constructor(data?: IUpstreamTransportationActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.type = _data["type"];
            this.typeName = _data["typeName"];
            this.quantity_of_fuel_consumed = _data["quantity_of_fuel_consumed"];
            this.quantity_of_fuel_consumed_unit = _data["quantity_of_fuel_consumed_unit"];
            this.fuelBasefuelType = _data["fuelBasefuelType"];
            this.quantity_of_electricity_consumed = _data["quantity_of_electricity_consumed"];
            this.quantity_of_electricity_consumed_unit = _data["quantity_of_electricity_consumed_unit"];
            this.grid_region = _data["grid_region"];
            this.quantity_of_refrigerent_leaked = _data["quantity_of_refrigerent_leaked"];
            this.quantity_of_refrigerent_leaked_unit = _data["quantity_of_refrigerent_leaked_unit"];
            this.fuelBaseRefrigerantType = _data["fuelBaseRefrigerantType"];
            this.quantity_of_fuel_consumed_from_backhaul = _data["quantity_of_fuel_consumed_from_backhaul"];
            this.quantity_of_fuel_consumed_from_backhaul_unit = _data["quantity_of_fuel_consumed_from_backhaul_unit"];
            this.fuelBaseBackhaulFuelType = _data["fuelBaseBackhaulFuelType"];
            this.mass_of_goods_purchased = _data["mass_of_goods_purchased"];
            this.mass_of_goods_purchased_unit = _data["mass_of_goods_purchased_unit"];
            this.distance_travelled_in_transport_leg = _data["distance_travelled_in_transport_leg"];
            this.distance_travelled_in_transport_leg_unit = _data["distance_travelled_in_transport_leg_unit"];
            this.vehicle_type = _data["vehicle_type"];
            this.amount_spent_on_transportation_by_type = _data["amount_spent_on_transportation_by_type"];
            this.amount_spent_on_transportation_by_type_unit = _data["amount_spent_on_transportation_by_type_unit"];
            this.shareOfTotalProjectCosts = _data["shareOfTotalProjectCosts"];
            this.shareOfTotalProjectCosts_unit = _data["shareOfTotalProjectCosts_unit"];
            this.eEIO_factor = _data["eEIO_factor"];
            this.eEIO_factor_unit = _data["eEIO_factor_unit"];
            this.volume_of_reporting_companys_purchased_goods = _data["volume_of_reporting_companys_purchased_goods"];
            this.volume_of_reporting_companys_purchased_goods_unit = _data["volume_of_reporting_companys_purchased_goods_unit"];
            this.total_volume_of_goods_in_storage_facility = _data["total_volume_of_goods_in_storage_facility"];
            this.total_volume_of_goods_in_storage_facility_unit = _data["total_volume_of_goods_in_storage_facility_unit"];
            this.fuel_consumed = _data["fuel_consumed"];
            this.fuel_consumed_unit = _data["fuel_consumed_unit"];
            this.electricity_consumed = _data["electricity_consumed"];
            this.electricity_consumed_unit = _data["electricity_consumed_unit"];
            this.refrigerant_leakage = _data["refrigerant_leakage"];
            this.refrigerant_leakage_unit = _data["refrigerant_leakage_unit"];
            this.refrigerantType = _data["refrigerantType"];
            this.fuelType = _data["fuelType"];
            this.average_number_of_days_stored = _data["average_number_of_days_stored"];
            this.storage_facility_ef = _data["storage_facility_ef"];
            this.storage_facility_ef_unit = _data["storage_facility_ef_unit"];
            this.volume_of_stored_goods = _data["volume_of_stored_goods"];
            this.volume_of_stored_goods_unit = _data["volume_of_stored_goods_unit"];
            this.emission = _data["emission"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): UpstreamTransportationActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new UpstreamTransportationActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["type"] = this.type;
        data["typeName"] = this.typeName;
        data["quantity_of_fuel_consumed"] = this.quantity_of_fuel_consumed;
        data["quantity_of_fuel_consumed_unit"] = this.quantity_of_fuel_consumed_unit;
        data["fuelBasefuelType"] = this.fuelBasefuelType;
        data["quantity_of_electricity_consumed"] = this.quantity_of_electricity_consumed;
        data["quantity_of_electricity_consumed_unit"] = this.quantity_of_electricity_consumed_unit;
        data["grid_region"] = this.grid_region;
        data["quantity_of_refrigerent_leaked"] = this.quantity_of_refrigerent_leaked;
        data["quantity_of_refrigerent_leaked_unit"] = this.quantity_of_refrigerent_leaked_unit;
        data["fuelBaseRefrigerantType"] = this.fuelBaseRefrigerantType;
        data["quantity_of_fuel_consumed_from_backhaul"] = this.quantity_of_fuel_consumed_from_backhaul;
        data["quantity_of_fuel_consumed_from_backhaul_unit"] = this.quantity_of_fuel_consumed_from_backhaul_unit;
        data["fuelBaseBackhaulFuelType"] = this.fuelBaseBackhaulFuelType;
        data["mass_of_goods_purchased"] = this.mass_of_goods_purchased;
        data["mass_of_goods_purchased_unit"] = this.mass_of_goods_purchased_unit;
        data["distance_travelled_in_transport_leg"] = this.distance_travelled_in_transport_leg;
        data["distance_travelled_in_transport_leg_unit"] = this.distance_travelled_in_transport_leg_unit;
        data["vehicle_type"] = this.vehicle_type;
        data["amount_spent_on_transportation_by_type"] = this.amount_spent_on_transportation_by_type;
        data["amount_spent_on_transportation_by_type_unit"] = this.amount_spent_on_transportation_by_type_unit;
        data["shareOfTotalProjectCosts"] = this.shareOfTotalProjectCosts;
        data["shareOfTotalProjectCosts_unit"] = this.shareOfTotalProjectCosts_unit;
        data["eEIO_factor"] = this.eEIO_factor;
        data["eEIO_factor_unit"] = this.eEIO_factor_unit;
        data["volume_of_reporting_companys_purchased_goods"] = this.volume_of_reporting_companys_purchased_goods;
        data["volume_of_reporting_companys_purchased_goods_unit"] = this.volume_of_reporting_companys_purchased_goods_unit;
        data["total_volume_of_goods_in_storage_facility"] = this.total_volume_of_goods_in_storage_facility;
        data["total_volume_of_goods_in_storage_facility_unit"] = this.total_volume_of_goods_in_storage_facility_unit;
        data["fuel_consumed"] = this.fuel_consumed;
        data["fuel_consumed_unit"] = this.fuel_consumed_unit;
        data["electricity_consumed"] = this.electricity_consumed;
        data["electricity_consumed_unit"] = this.electricity_consumed_unit;
        data["refrigerant_leakage"] = this.refrigerant_leakage;
        data["refrigerant_leakage_unit"] = this.refrigerant_leakage_unit;
        data["refrigerantType"] = this.refrigerantType;
        data["fuelType"] = this.fuelType;
        data["average_number_of_days_stored"] = this.average_number_of_days_stored;
        data["storage_facility_ef"] = this.storage_facility_ef;
        data["storage_facility_ef_unit"] = this.storage_facility_ef_unit;
        data["volume_of_stored_goods"] = this.volume_of_stored_goods;
        data["volume_of_stored_goods_unit"] = this.volume_of_stored_goods_unit;
        data["emission"] = this.emission;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): UpstreamTransportationActivityData {
        const json = this.toJSON();
        let result = new UpstreamTransportationActivityData();
        result.init(json);
        return result;
    }
}

export interface IUpstreamTransportationActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    method: UpstreamTransportationActivityDataMethod;
    type: string;
    typeName: string;
    quantity_of_fuel_consumed: number;
    quantity_of_fuel_consumed_unit: string;
    fuelBasefuelType: string;
    quantity_of_electricity_consumed: number;
    quantity_of_electricity_consumed_unit: string;
    grid_region: string;
    quantity_of_refrigerent_leaked: number;
    quantity_of_refrigerent_leaked_unit: string;
    fuelBaseRefrigerantType: string;
    quantity_of_fuel_consumed_from_backhaul: number;
    quantity_of_fuel_consumed_from_backhaul_unit: string;
    fuelBaseBackhaulFuelType: string;
    mass_of_goods_purchased: number;
    mass_of_goods_purchased_unit: string;
    distance_travelled_in_transport_leg: number;
    distance_travelled_in_transport_leg_unit: string;
    vehicle_type: string;
    amount_spent_on_transportation_by_type: number;
    amount_spent_on_transportation_by_type_unit: string;
    shareOfTotalProjectCosts: number;
    shareOfTotalProjectCosts_unit: string;
    eEIO_factor: number;
    eEIO_factor_unit: string;
    volume_of_reporting_companys_purchased_goods: number;
    volume_of_reporting_companys_purchased_goods_unit: string;
    total_volume_of_goods_in_storage_facility: number;
    total_volume_of_goods_in_storage_facility_unit: string;
    fuel_consumed: number;
    fuel_consumed_unit: string;
    electricity_consumed: number;
    electricity_consumed_unit: string;
    refrigerant_leakage: number;
    refrigerant_leakage_unit: string;
    refrigerantType: string;
    fuelType: string;
    average_number_of_days_stored: number;
    storage_facility_ef: number;
    storage_facility_ef_unit: string;
    volume_of_stored_goods: number;
    volume_of_stored_goods_unit: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: UpstreamTransportationActivityDataActivityDataStatus;
}

export class CreateManyUpstreamTransportationActivityDataDto implements ICreateManyUpstreamTransportationActivityDataDto {
    bulk: UpstreamTransportationActivityData[];

    constructor(data?: ICreateManyUpstreamTransportationActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(UpstreamTransportationActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUpstreamTransportationActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUpstreamTransportationActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyUpstreamTransportationActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyUpstreamTransportationActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUpstreamTransportationActivityDataDto {
    bulk: UpstreamTransportationActivityData[];
}

export class FuelData implements IFuelData {
    id: number;
    typeName: string;
    fuel_type: string;
    fuel_lifetime: number;
    fuel_number_of_sold: number;
    fuel_consumption: number;
    fuel_consumption_unit: string;

    constructor(data?: IFuelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.fuel_type = _data["fuel_type"];
            this.fuel_lifetime = _data["fuel_lifetime"];
            this.fuel_number_of_sold = _data["fuel_number_of_sold"];
            this.fuel_consumption = _data["fuel_consumption"];
            this.fuel_consumption_unit = _data["fuel_consumption_unit"];
        }
    }

    static fromJS(data: any): FuelData {
        data = typeof data === 'object' ? data : {};
        let result = new FuelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["fuel_type"] = this.fuel_type;
        data["fuel_lifetime"] = this.fuel_lifetime;
        data["fuel_number_of_sold"] = this.fuel_number_of_sold;
        data["fuel_consumption"] = this.fuel_consumption;
        data["fuel_consumption_unit"] = this.fuel_consumption_unit;
        return data;
    }

    clone(): FuelData {
        const json = this.toJSON();
        let result = new FuelData();
        result.init(json);
        return result;
    }
}

export interface IFuelData {
    id: number;
    typeName: string;
    fuel_type: string;
    fuel_lifetime: number;
    fuel_number_of_sold: number;
    fuel_consumption: number;
    fuel_consumption_unit: string;
}

export class ElectricityData implements IElectricityData {
    id: number;
    typeName: string;
    elec_lifetime: number;
    elec_number_of_sold: number;
    elec_consumption: number;
    elec_consumption_unit: string;

    constructor(data?: IElectricityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.elec_lifetime = _data["elec_lifetime"];
            this.elec_number_of_sold = _data["elec_number_of_sold"];
            this.elec_consumption = _data["elec_consumption"];
            this.elec_consumption_unit = _data["elec_consumption_unit"];
        }
    }

    static fromJS(data: any): ElectricityData {
        data = typeof data === 'object' ? data : {};
        let result = new ElectricityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["elec_lifetime"] = this.elec_lifetime;
        data["elec_number_of_sold"] = this.elec_number_of_sold;
        data["elec_consumption"] = this.elec_consumption;
        data["elec_consumption_unit"] = this.elec_consumption_unit;
        return data;
    }

    clone(): ElectricityData {
        const json = this.toJSON();
        let result = new ElectricityData();
        result.init(json);
        return result;
    }
}

export interface IElectricityData {
    id: number;
    typeName: string;
    elec_lifetime: number;
    elec_number_of_sold: number;
    elec_consumption: number;
    elec_consumption_unit: string;
}

export class RefrigerantData implements IRefrigerantData {
    id: number;
    typeName: string;
    ref_type: string;
    ref_lifetime: number;
    ref_number_of_sold: number;
    ref_leakage: number;
    ref_leakage_unit: string;

    constructor(data?: IRefrigerantData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.ref_type = _data["ref_type"];
            this.ref_lifetime = _data["ref_lifetime"];
            this.ref_number_of_sold = _data["ref_number_of_sold"];
            this.ref_leakage = _data["ref_leakage"];
            this.ref_leakage_unit = _data["ref_leakage_unit"];
        }
    }

    static fromJS(data: any): RefrigerantData {
        data = typeof data === 'object' ? data : {};
        let result = new RefrigerantData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["ref_type"] = this.ref_type;
        data["ref_lifetime"] = this.ref_lifetime;
        data["ref_number_of_sold"] = this.ref_number_of_sold;
        data["ref_leakage"] = this.ref_leakage;
        data["ref_leakage_unit"] = this.ref_leakage_unit;
        return data;
    }

    clone(): RefrigerantData {
        const json = this.toJSON();
        let result = new RefrigerantData();
        result.init(json);
        return result;
    }
}

export interface IRefrigerantData {
    id: number;
    typeName: string;
    ref_type: string;
    ref_lifetime: number;
    ref_number_of_sold: number;
    ref_leakage: number;
    ref_leakage_unit: string;
}

export class DirectEnergy implements IDirectEnergy {
    fuelData: FuelData[];
    electricityData: ElectricityData[];
    refrigerantData: RefrigerantData[];

    constructor(data?: IDirectEnergy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fuelData = [];
            this.electricityData = [];
            this.refrigerantData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fuelData"])) {
                this.fuelData = [] as any;
                for (let item of _data["fuelData"])
                    this.fuelData.push(FuelData.fromJS(item));
            }
            if (Array.isArray(_data["electricityData"])) {
                this.electricityData = [] as any;
                for (let item of _data["electricityData"])
                    this.electricityData.push(ElectricityData.fromJS(item));
            }
            if (Array.isArray(_data["refrigerantData"])) {
                this.refrigerantData = [] as any;
                for (let item of _data["refrigerantData"])
                    this.refrigerantData.push(RefrigerantData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DirectEnergy {
        data = typeof data === 'object' ? data : {};
        let result = new DirectEnergy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fuelData)) {
            data["fuelData"] = [];
            for (let item of this.fuelData)
                data["fuelData"].push(item.toJSON());
        }
        if (Array.isArray(this.electricityData)) {
            data["electricityData"] = [];
            for (let item of this.electricityData)
                data["electricityData"].push(item.toJSON());
        }
        if (Array.isArray(this.refrigerantData)) {
            data["refrigerantData"] = [];
            for (let item of this.refrigerantData)
                data["refrigerantData"].push(item.toJSON());
        }
        return data;
    }

    clone(): DirectEnergy {
        const json = this.toJSON();
        let result = new DirectEnergy();
        result.init(json);
        return result;
    }
}

export interface IDirectEnergy {
    fuelData: FuelData[];
    electricityData: ElectricityData[];
    refrigerantData: RefrigerantData[];
}

export class CombustedData implements ICombustedData {
    id: number;
    typeName: string;
    fuel_type: string;
    total_quantity: number;
    total_quantity_unit: string;

    constructor(data?: ICombustedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.fuel_type = _data["fuel_type"];
            this.total_quantity = _data["total_quantity"];
            this.total_quantity_unit = _data["total_quantity_unit"];
        }
    }

    static fromJS(data: any): CombustedData {
        data = typeof data === 'object' ? data : {};
        let result = new CombustedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["fuel_type"] = this.fuel_type;
        data["total_quantity"] = this.total_quantity;
        data["total_quantity_unit"] = this.total_quantity_unit;
        return data;
    }

    clone(): CombustedData {
        const json = this.toJSON();
        let result = new CombustedData();
        result.init(json);
        return result;
    }
}

export interface ICombustedData {
    id: number;
    typeName: string;
    fuel_type: string;
    total_quantity: number;
    total_quantity_unit: string;
}

export class DirectCombusted implements IDirectCombusted {
    combustedData: CombustedData[];

    constructor(data?: IDirectCombusted) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.combustedData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["combustedData"])) {
                this.combustedData = [] as any;
                for (let item of _data["combustedData"])
                    this.combustedData.push(CombustedData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DirectCombusted {
        data = typeof data === 'object' ? data : {};
        let result = new DirectCombusted();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.combustedData)) {
            data["combustedData"] = [];
            for (let item of this.combustedData)
                data["combustedData"].push(item.toJSON());
        }
        return data;
    }

    clone(): DirectCombusted {
        const json = this.toJSON();
        let result = new DirectCombusted();
        result.init(json);
        return result;
    }
}

export interface IDirectCombusted {
    combustedData: CombustedData[];
}

export class GreenhouseData implements IGreenhouseData {
    id: number;
    typeName: string;
    ghg_type: string;
    ghg_amount: number;
    ghg_amount_unit: string;
    number_of_products: number;
    percentage_of_released: number;

    constructor(data?: IGreenhouseData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.ghg_type = _data["ghg_type"];
            this.ghg_amount = _data["ghg_amount"];
            this.ghg_amount_unit = _data["ghg_amount_unit"];
            this.number_of_products = _data["number_of_products"];
            this.percentage_of_released = _data["percentage_of_released"];
        }
    }

    static fromJS(data: any): GreenhouseData {
        data = typeof data === 'object' ? data : {};
        let result = new GreenhouseData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["ghg_type"] = this.ghg_type;
        data["ghg_amount"] = this.ghg_amount;
        data["ghg_amount_unit"] = this.ghg_amount_unit;
        data["number_of_products"] = this.number_of_products;
        data["percentage_of_released"] = this.percentage_of_released;
        return data;
    }

    clone(): GreenhouseData {
        const json = this.toJSON();
        let result = new GreenhouseData();
        result.init(json);
        return result;
    }
}

export interface IGreenhouseData {
    id: number;
    typeName: string;
    ghg_type: string;
    ghg_amount: number;
    ghg_amount_unit: string;
    number_of_products: number;
    percentage_of_released: number;
}

export class DirectGreenhouse implements IDirectGreenhouse {
    greenhouseData: GreenhouseData[];

    constructor(data?: IDirectGreenhouse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.greenhouseData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["greenhouseData"])) {
                this.greenhouseData = [] as any;
                for (let item of _data["greenhouseData"])
                    this.greenhouseData.push(GreenhouseData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DirectGreenhouse {
        data = typeof data === 'object' ? data : {};
        let result = new DirectGreenhouse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.greenhouseData)) {
            data["greenhouseData"] = [];
            for (let item of this.greenhouseData)
                data["greenhouseData"].push(item.toJSON());
        }
        return data;
    }

    clone(): DirectGreenhouse {
        const json = this.toJSON();
        let result = new DirectGreenhouse();
        result.init(json);
        return result;
    }
}

export interface IDirectGreenhouse {
    greenhouseData: GreenhouseData[];
}

export class IndirectFuelData implements IIndirectFuelData {
    id: number;
    typeName: string;
    fuel_type: string;
    indir_fuel_lifetime: number;
    indir_fuel_percentage_of_lifetime: number;
    indir_fuel_number_of_sold: number;
    indir_fuel_consumption: number;
    indir_fuel_consumption_unit: string;

    constructor(data?: IIndirectFuelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.fuel_type = _data["fuel_type"];
            this.indir_fuel_lifetime = _data["indir_fuel_lifetime"];
            this.indir_fuel_percentage_of_lifetime = _data["indir_fuel_percentage_of_lifetime"];
            this.indir_fuel_number_of_sold = _data["indir_fuel_number_of_sold"];
            this.indir_fuel_consumption = _data["indir_fuel_consumption"];
            this.indir_fuel_consumption_unit = _data["indir_fuel_consumption_unit"];
        }
    }

    static fromJS(data: any): IndirectFuelData {
        data = typeof data === 'object' ? data : {};
        let result = new IndirectFuelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["fuel_type"] = this.fuel_type;
        data["indir_fuel_lifetime"] = this.indir_fuel_lifetime;
        data["indir_fuel_percentage_of_lifetime"] = this.indir_fuel_percentage_of_lifetime;
        data["indir_fuel_number_of_sold"] = this.indir_fuel_number_of_sold;
        data["indir_fuel_consumption"] = this.indir_fuel_consumption;
        data["indir_fuel_consumption_unit"] = this.indir_fuel_consumption_unit;
        return data;
    }

    clone(): IndirectFuelData {
        const json = this.toJSON();
        let result = new IndirectFuelData();
        result.init(json);
        return result;
    }
}

export interface IIndirectFuelData {
    id: number;
    typeName: string;
    fuel_type: string;
    indir_fuel_lifetime: number;
    indir_fuel_percentage_of_lifetime: number;
    indir_fuel_number_of_sold: number;
    indir_fuel_consumption: number;
    indir_fuel_consumption_unit: string;
}

export class IndirectElectricityData implements IIndirectElectricityData {
    id: number;
    typeName: string;
    indir_elec_lifetime: number;
    indir_elec_percentage_of_lifetime: number;
    indir_elec_number_of_sold: number;
    indir_elec_consumption: number;
    indir_elec_consumption_unit: string;

    constructor(data?: IIndirectElectricityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.indir_elec_lifetime = _data["indir_elec_lifetime"];
            this.indir_elec_percentage_of_lifetime = _data["indir_elec_percentage_of_lifetime"];
            this.indir_elec_number_of_sold = _data["indir_elec_number_of_sold"];
            this.indir_elec_consumption = _data["indir_elec_consumption"];
            this.indir_elec_consumption_unit = _data["indir_elec_consumption_unit"];
        }
    }

    static fromJS(data: any): IndirectElectricityData {
        data = typeof data === 'object' ? data : {};
        let result = new IndirectElectricityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["indir_elec_lifetime"] = this.indir_elec_lifetime;
        data["indir_elec_percentage_of_lifetime"] = this.indir_elec_percentage_of_lifetime;
        data["indir_elec_number_of_sold"] = this.indir_elec_number_of_sold;
        data["indir_elec_consumption"] = this.indir_elec_consumption;
        data["indir_elec_consumption_unit"] = this.indir_elec_consumption_unit;
        return data;
    }

    clone(): IndirectElectricityData {
        const json = this.toJSON();
        let result = new IndirectElectricityData();
        result.init(json);
        return result;
    }
}

export interface IIndirectElectricityData {
    id: number;
    typeName: string;
    indir_elec_lifetime: number;
    indir_elec_percentage_of_lifetime: number;
    indir_elec_number_of_sold: number;
    indir_elec_consumption: number;
    indir_elec_consumption_unit: string;
}

export class IndirectRefrigerantdata implements IIndirectRefrigerantdata {
    id: number;
    typeName: string;
    ref_type: string;
    indir_ref_lifetime: number;
    indir_ref_percentage_of_lifetime: number;
    indir_ref_number_of_sold: number;
    indir_ref_leakage: number;
    indir_ref_leakage_unit: string;

    constructor(data?: IIndirectRefrigerantdata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.ref_type = _data["ref_type"];
            this.indir_ref_lifetime = _data["indir_ref_lifetime"];
            this.indir_ref_percentage_of_lifetime = _data["indir_ref_percentage_of_lifetime"];
            this.indir_ref_number_of_sold = _data["indir_ref_number_of_sold"];
            this.indir_ref_leakage = _data["indir_ref_leakage"];
            this.indir_ref_leakage_unit = _data["indir_ref_leakage_unit"];
        }
    }

    static fromJS(data: any): IndirectRefrigerantdata {
        data = typeof data === 'object' ? data : {};
        let result = new IndirectRefrigerantdata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["ref_type"] = this.ref_type;
        data["indir_ref_lifetime"] = this.indir_ref_lifetime;
        data["indir_ref_percentage_of_lifetime"] = this.indir_ref_percentage_of_lifetime;
        data["indir_ref_number_of_sold"] = this.indir_ref_number_of_sold;
        data["indir_ref_leakage"] = this.indir_ref_leakage;
        data["indir_ref_leakage_unit"] = this.indir_ref_leakage_unit;
        return data;
    }

    clone(): IndirectRefrigerantdata {
        const json = this.toJSON();
        let result = new IndirectRefrigerantdata();
        result.init(json);
        return result;
    }
}

export interface IIndirectRefrigerantdata {
    id: number;
    typeName: string;
    ref_type: string;
    indir_ref_lifetime: number;
    indir_ref_percentage_of_lifetime: number;
    indir_ref_number_of_sold: number;
    indir_ref_leakage: number;
    indir_ref_leakage_unit: string;
}

export class IndirectGHGData implements IIndirectGHGData {
    id: number;
    typeName: string;
    indir_ghg_lifetime: number;
    ghg_type: string;
    indir_ghg_percentage_of_lifetime: number;
    indir_ghg_number_of_sold: number;
    indir_ghg_emit: number;
    indir_ghg_emit_unit: string;

    constructor(data?: IIndirectGHGData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.indir_ghg_lifetime = _data["indir_ghg_lifetime"];
            this.ghg_type = _data["ghg_type"];
            this.indir_ghg_percentage_of_lifetime = _data["indir_ghg_percentage_of_lifetime"];
            this.indir_ghg_number_of_sold = _data["indir_ghg_number_of_sold"];
            this.indir_ghg_emit = _data["indir_ghg_emit"];
            this.indir_ghg_emit_unit = _data["indir_ghg_emit_unit"];
        }
    }

    static fromJS(data: any): IndirectGHGData {
        data = typeof data === 'object' ? data : {};
        let result = new IndirectGHGData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["indir_ghg_lifetime"] = this.indir_ghg_lifetime;
        data["ghg_type"] = this.ghg_type;
        data["indir_ghg_percentage_of_lifetime"] = this.indir_ghg_percentage_of_lifetime;
        data["indir_ghg_number_of_sold"] = this.indir_ghg_number_of_sold;
        data["indir_ghg_emit"] = this.indir_ghg_emit;
        data["indir_ghg_emit_unit"] = this.indir_ghg_emit_unit;
        return data;
    }

    clone(): IndirectGHGData {
        const json = this.toJSON();
        let result = new IndirectGHGData();
        result.init(json);
        return result;
    }
}

export interface IIndirectGHGData {
    id: number;
    typeName: string;
    indir_ghg_lifetime: number;
    ghg_type: string;
    indir_ghg_percentage_of_lifetime: number;
    indir_ghg_number_of_sold: number;
    indir_ghg_emit: number;
    indir_ghg_emit_unit: string;
}

export class IndirectEnergy implements IIndirectEnergy {
    fuelData: IndirectFuelData[];
    electricityData: IndirectElectricityData[];
    refrigerantData: IndirectRefrigerantdata[];
    ghgData: IndirectGHGData[];

    constructor(data?: IIndirectEnergy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fuelData = [];
            this.electricityData = [];
            this.refrigerantData = [];
            this.ghgData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fuelData"])) {
                this.fuelData = [] as any;
                for (let item of _data["fuelData"])
                    this.fuelData.push(IndirectFuelData.fromJS(item));
            }
            if (Array.isArray(_data["electricityData"])) {
                this.electricityData = [] as any;
                for (let item of _data["electricityData"])
                    this.electricityData.push(IndirectElectricityData.fromJS(item));
            }
            if (Array.isArray(_data["refrigerantData"])) {
                this.refrigerantData = [] as any;
                for (let item of _data["refrigerantData"])
                    this.refrigerantData.push(IndirectRefrigerantdata.fromJS(item));
            }
            if (Array.isArray(_data["ghgData"])) {
                this.ghgData = [] as any;
                for (let item of _data["ghgData"])
                    this.ghgData.push(IndirectGHGData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IndirectEnergy {
        data = typeof data === 'object' ? data : {};
        let result = new IndirectEnergy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fuelData)) {
            data["fuelData"] = [];
            for (let item of this.fuelData)
                data["fuelData"].push(item.toJSON());
        }
        if (Array.isArray(this.electricityData)) {
            data["electricityData"] = [];
            for (let item of this.electricityData)
                data["electricityData"].push(item.toJSON());
        }
        if (Array.isArray(this.refrigerantData)) {
            data["refrigerantData"] = [];
            for (let item of this.refrigerantData)
                data["refrigerantData"].push(item.toJSON());
        }
        if (Array.isArray(this.ghgData)) {
            data["ghgData"] = [];
            for (let item of this.ghgData)
                data["ghgData"].push(item.toJSON());
        }
        return data;
    }

    clone(): IndirectEnergy {
        const json = this.toJSON();
        let result = new IndirectEnergy();
        result.init(json);
        return result;
    }
}

export interface IIndirectEnergy {
    fuelData: IndirectFuelData[];
    electricityData: IndirectElectricityData[];
    refrigerantData: IndirectRefrigerantdata[];
    ghgData: IndirectGHGData[];
}

export class IntermediateData implements IIntermediateData {
    id: number;
    typeName: string;
    product_type: string;
    intermediate_sold: number;
    intermediate_lifetime: number;
    intermediate_ef: number;
    intermediate_ef_unit: string;

    constructor(data?: IIntermediateData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.product_type = _data["product_type"];
            this.intermediate_sold = _data["intermediate_sold"];
            this.intermediate_lifetime = _data["intermediate_lifetime"];
            this.intermediate_ef = _data["intermediate_ef"];
            this.intermediate_ef_unit = _data["intermediate_ef_unit"];
        }
    }

    static fromJS(data: any): IntermediateData {
        data = typeof data === 'object' ? data : {};
        let result = new IntermediateData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["product_type"] = this.product_type;
        data["intermediate_sold"] = this.intermediate_sold;
        data["intermediate_lifetime"] = this.intermediate_lifetime;
        data["intermediate_ef"] = this.intermediate_ef;
        data["intermediate_ef_unit"] = this.intermediate_ef_unit;
        return data;
    }

    clone(): IntermediateData {
        const json = this.toJSON();
        let result = new IntermediateData();
        result.init(json);
        return result;
    }
}

export interface IIntermediateData {
    id: number;
    typeName: string;
    product_type: string;
    intermediate_sold: number;
    intermediate_lifetime: number;
    intermediate_ef: number;
    intermediate_ef_unit: string;
}

export class IntermediateProducts implements IIntermediateProducts {
    intermediateData: IntermediateData[];

    constructor(data?: IIntermediateProducts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.intermediateData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["intermediateData"])) {
                this.intermediateData = [] as any;
                for (let item of _data["intermediateData"])
                    this.intermediateData.push(IntermediateData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IntermediateProducts {
        data = typeof data === 'object' ? data : {};
        let result = new IntermediateProducts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.intermediateData)) {
            data["intermediateData"] = [];
            for (let item of this.intermediateData)
                data["intermediateData"].push(item.toJSON());
        }
        return data;
    }

    clone(): IntermediateProducts {
        const json = this.toJSON();
        let result = new IntermediateProducts();
        result.init(json);
        return result;
    }
}

export interface IIntermediateProducts {
    intermediateData: IntermediateData[];
}

export class CreateNetZeroUseOfSoldProductDto implements ICreateNetZeroUseOfSoldProductDto {
    month: number;
    year: number;
    method: CreateNetZeroUseOfSoldProductDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: CreateNetZeroUseOfSoldProductDtoActivityDataStatus;
    groupNo: string;
    directEnergy: DirectEnergy;
    directCombusted: DirectCombusted;
    directGreenhouse: DirectGreenhouse;
    indirectEnergy: IndirectEnergy;
    intermediateProducts: IntermediateProducts;

    constructor(data?: ICreateNetZeroUseOfSoldProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.directEnergy = new DirectEnergy();
            this.directCombusted = new DirectCombusted();
            this.directGreenhouse = new DirectGreenhouse();
            this.indirectEnergy = new IndirectEnergy();
            this.intermediateProducts = new IntermediateProducts();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.method = _data["method"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
            this.groupNo = _data["groupNo"];
            this.directEnergy = _data["directEnergy"] ? DirectEnergy.fromJS(_data["directEnergy"]) : new DirectEnergy();
            this.directCombusted = _data["directCombusted"] ? DirectCombusted.fromJS(_data["directCombusted"]) : new DirectCombusted();
            this.directGreenhouse = _data["directGreenhouse"] ? DirectGreenhouse.fromJS(_data["directGreenhouse"]) : new DirectGreenhouse();
            this.indirectEnergy = _data["indirectEnergy"] ? IndirectEnergy.fromJS(_data["indirectEnergy"]) : new IndirectEnergy();
            this.intermediateProducts = _data["intermediateProducts"] ? IntermediateProducts.fromJS(_data["intermediateProducts"]) : new IntermediateProducts();
        }
    }

    static fromJS(data: any): CreateNetZeroUseOfSoldProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNetZeroUseOfSoldProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["method"] = this.method;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        data["groupNo"] = this.groupNo;
        data["directEnergy"] = this.directEnergy ? this.directEnergy.toJSON() : <any>undefined;
        data["directCombusted"] = this.directCombusted ? this.directCombusted.toJSON() : <any>undefined;
        data["directGreenhouse"] = this.directGreenhouse ? this.directGreenhouse.toJSON() : <any>undefined;
        data["indirectEnergy"] = this.indirectEnergy ? this.indirectEnergy.toJSON() : <any>undefined;
        data["intermediateProducts"] = this.intermediateProducts ? this.intermediateProducts.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateNetZeroUseOfSoldProductDto {
        const json = this.toJSON();
        let result = new CreateNetZeroUseOfSoldProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreateNetZeroUseOfSoldProductDto {
    month: number;
    year: number;
    method: CreateNetZeroUseOfSoldProductDtoMethod;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: CreateNetZeroUseOfSoldProductDtoActivityDataStatus;
    groupNo: string;
    directEnergy: DirectEnergy;
    directCombusted: DirectCombusted;
    directGreenhouse: DirectGreenhouse;
    indirectEnergy: IndirectEnergy;
    intermediateProducts: IntermediateProducts;
}

export class GetManyNetZeroUseOfSoldProductActivityDataResponseDto implements IGetManyNetZeroUseOfSoldProductActivityDataResponseDto {
    data: NetZeroUseOfSoldProductActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyNetZeroUseOfSoldProductActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(NetZeroUseOfSoldProductActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyNetZeroUseOfSoldProductActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyNetZeroUseOfSoldProductActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyNetZeroUseOfSoldProductActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyNetZeroUseOfSoldProductActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyNetZeroUseOfSoldProductActivityDataResponseDto {
    data: NetZeroUseOfSoldProductActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class NetZeroUseOfSoldProductActivityData implements INetZeroUseOfSoldProductActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    month: number;
    groupNo: string;
    mode: NetZeroUseOfSoldProductActivityDataMode;
    typeName: NetZeroUseOfSoldProductActivityDataTypeName;
    fuel_type: string;
    ref_type: string;
    ghg_type: string;
    product_type: string;
    fuel_lifetime: number;
    fuel_number_of_sold: number;
    fuel_consumption: number;
    fuel_consumption_unit: string;
    elec_lifetime: number;
    elec_number_of_sold: number;
    elec_consumption: number;
    elec_consumption_unit: string;
    ref_lifetime: number;
    ref_number_of_sold: number;
    ref_leakage: number;
    ref_leakage_unit: string;
    total_quantity: number;
    total_quantity_unit: string;
    ghg_amount: number;
    ghg_amount_unit: string;
    number_of_products: number;
    percentage_of_released: number;
    indir_fuel_lifetime: number;
    indir_fuel_percentage_of_lifetime: number;
    indir_fuel_number_of_sold: number;
    indir_fuel_consumption: number;
    indir_fuel_consumption_unit: string;
    indir_elec_lifetime: number;
    indir_elec_percentage_of_lifetime: number;
    indir_elec_number_of_sold: number;
    indir_elec_consumption: number;
    indir_elec_consumption_unit: string;
    indir_ref_lifetime: number;
    indir_ref_percentage_of_lifetime: number;
    indir_ref_number_of_sold: number;
    indir_ref_leakage: number;
    indir_ref_leakage_unit: string;
    indir_ghg_lifetime: number;
    indir_ghg_percentage_of_lifetime: number;
    indir_ghg_number_of_sold: number;
    indir_ghg_emit: number;
    indir_ghg_emit_unit: string;
    intermediate_sold: number;
    intermediate_lifetime: number;
    intermediate_ef: number;
    intermediate_ef_unit: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroUseOfSoldProductActivityDataActivityDataStatus;

    constructor(data?: INetZeroUseOfSoldProductActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.groupNo = _data["groupNo"];
            this.mode = _data["mode"];
            this.typeName = _data["typeName"];
            this.fuel_type = _data["fuel_type"];
            this.ref_type = _data["ref_type"];
            this.ghg_type = _data["ghg_type"];
            this.product_type = _data["product_type"];
            this.fuel_lifetime = _data["fuel_lifetime"];
            this.fuel_number_of_sold = _data["fuel_number_of_sold"];
            this.fuel_consumption = _data["fuel_consumption"];
            this.fuel_consumption_unit = _data["fuel_consumption_unit"];
            this.elec_lifetime = _data["elec_lifetime"];
            this.elec_number_of_sold = _data["elec_number_of_sold"];
            this.elec_consumption = _data["elec_consumption"];
            this.elec_consumption_unit = _data["elec_consumption_unit"];
            this.ref_lifetime = _data["ref_lifetime"];
            this.ref_number_of_sold = _data["ref_number_of_sold"];
            this.ref_leakage = _data["ref_leakage"];
            this.ref_leakage_unit = _data["ref_leakage_unit"];
            this.total_quantity = _data["total_quantity"];
            this.total_quantity_unit = _data["total_quantity_unit"];
            this.ghg_amount = _data["ghg_amount"];
            this.ghg_amount_unit = _data["ghg_amount_unit"];
            this.number_of_products = _data["number_of_products"];
            this.percentage_of_released = _data["percentage_of_released"];
            this.indir_fuel_lifetime = _data["indir_fuel_lifetime"];
            this.indir_fuel_percentage_of_lifetime = _data["indir_fuel_percentage_of_lifetime"];
            this.indir_fuel_number_of_sold = _data["indir_fuel_number_of_sold"];
            this.indir_fuel_consumption = _data["indir_fuel_consumption"];
            this.indir_fuel_consumption_unit = _data["indir_fuel_consumption_unit"];
            this.indir_elec_lifetime = _data["indir_elec_lifetime"];
            this.indir_elec_percentage_of_lifetime = _data["indir_elec_percentage_of_lifetime"];
            this.indir_elec_number_of_sold = _data["indir_elec_number_of_sold"];
            this.indir_elec_consumption = _data["indir_elec_consumption"];
            this.indir_elec_consumption_unit = _data["indir_elec_consumption_unit"];
            this.indir_ref_lifetime = _data["indir_ref_lifetime"];
            this.indir_ref_percentage_of_lifetime = _data["indir_ref_percentage_of_lifetime"];
            this.indir_ref_number_of_sold = _data["indir_ref_number_of_sold"];
            this.indir_ref_leakage = _data["indir_ref_leakage"];
            this.indir_ref_leakage_unit = _data["indir_ref_leakage_unit"];
            this.indir_ghg_lifetime = _data["indir_ghg_lifetime"];
            this.indir_ghg_percentage_of_lifetime = _data["indir_ghg_percentage_of_lifetime"];
            this.indir_ghg_number_of_sold = _data["indir_ghg_number_of_sold"];
            this.indir_ghg_emit = _data["indir_ghg_emit"];
            this.indir_ghg_emit_unit = _data["indir_ghg_emit_unit"];
            this.intermediate_sold = _data["intermediate_sold"];
            this.intermediate_lifetime = _data["intermediate_lifetime"];
            this.intermediate_ef = _data["intermediate_ef"];
            this.intermediate_ef_unit = _data["intermediate_ef_unit"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): NetZeroUseOfSoldProductActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new NetZeroUseOfSoldProductActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["year"] = this.year;
        data["month"] = this.month;
        data["groupNo"] = this.groupNo;
        data["mode"] = this.mode;
        data["typeName"] = this.typeName;
        data["fuel_type"] = this.fuel_type;
        data["ref_type"] = this.ref_type;
        data["ghg_type"] = this.ghg_type;
        data["product_type"] = this.product_type;
        data["fuel_lifetime"] = this.fuel_lifetime;
        data["fuel_number_of_sold"] = this.fuel_number_of_sold;
        data["fuel_consumption"] = this.fuel_consumption;
        data["fuel_consumption_unit"] = this.fuel_consumption_unit;
        data["elec_lifetime"] = this.elec_lifetime;
        data["elec_number_of_sold"] = this.elec_number_of_sold;
        data["elec_consumption"] = this.elec_consumption;
        data["elec_consumption_unit"] = this.elec_consumption_unit;
        data["ref_lifetime"] = this.ref_lifetime;
        data["ref_number_of_sold"] = this.ref_number_of_sold;
        data["ref_leakage"] = this.ref_leakage;
        data["ref_leakage_unit"] = this.ref_leakage_unit;
        data["total_quantity"] = this.total_quantity;
        data["total_quantity_unit"] = this.total_quantity_unit;
        data["ghg_amount"] = this.ghg_amount;
        data["ghg_amount_unit"] = this.ghg_amount_unit;
        data["number_of_products"] = this.number_of_products;
        data["percentage_of_released"] = this.percentage_of_released;
        data["indir_fuel_lifetime"] = this.indir_fuel_lifetime;
        data["indir_fuel_percentage_of_lifetime"] = this.indir_fuel_percentage_of_lifetime;
        data["indir_fuel_number_of_sold"] = this.indir_fuel_number_of_sold;
        data["indir_fuel_consumption"] = this.indir_fuel_consumption;
        data["indir_fuel_consumption_unit"] = this.indir_fuel_consumption_unit;
        data["indir_elec_lifetime"] = this.indir_elec_lifetime;
        data["indir_elec_percentage_of_lifetime"] = this.indir_elec_percentage_of_lifetime;
        data["indir_elec_number_of_sold"] = this.indir_elec_number_of_sold;
        data["indir_elec_consumption"] = this.indir_elec_consumption;
        data["indir_elec_consumption_unit"] = this.indir_elec_consumption_unit;
        data["indir_ref_lifetime"] = this.indir_ref_lifetime;
        data["indir_ref_percentage_of_lifetime"] = this.indir_ref_percentage_of_lifetime;
        data["indir_ref_number_of_sold"] = this.indir_ref_number_of_sold;
        data["indir_ref_leakage"] = this.indir_ref_leakage;
        data["indir_ref_leakage_unit"] = this.indir_ref_leakage_unit;
        data["indir_ghg_lifetime"] = this.indir_ghg_lifetime;
        data["indir_ghg_percentage_of_lifetime"] = this.indir_ghg_percentage_of_lifetime;
        data["indir_ghg_number_of_sold"] = this.indir_ghg_number_of_sold;
        data["indir_ghg_emit"] = this.indir_ghg_emit;
        data["indir_ghg_emit_unit"] = this.indir_ghg_emit_unit;
        data["intermediate_sold"] = this.intermediate_sold;
        data["intermediate_lifetime"] = this.intermediate_lifetime;
        data["intermediate_ef"] = this.intermediate_ef;
        data["intermediate_ef_unit"] = this.intermediate_ef_unit;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): NetZeroUseOfSoldProductActivityData {
        const json = this.toJSON();
        let result = new NetZeroUseOfSoldProductActivityData();
        result.init(json);
        return result;
    }
}

export interface INetZeroUseOfSoldProductActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    year: number;
    month: number;
    groupNo: string;
    mode: NetZeroUseOfSoldProductActivityDataMode;
    typeName: NetZeroUseOfSoldProductActivityDataTypeName;
    fuel_type: string;
    ref_type: string;
    ghg_type: string;
    product_type: string;
    fuel_lifetime: number;
    fuel_number_of_sold: number;
    fuel_consumption: number;
    fuel_consumption_unit: string;
    elec_lifetime: number;
    elec_number_of_sold: number;
    elec_consumption: number;
    elec_consumption_unit: string;
    ref_lifetime: number;
    ref_number_of_sold: number;
    ref_leakage: number;
    ref_leakage_unit: string;
    total_quantity: number;
    total_quantity_unit: string;
    ghg_amount: number;
    ghg_amount_unit: string;
    number_of_products: number;
    percentage_of_released: number;
    indir_fuel_lifetime: number;
    indir_fuel_percentage_of_lifetime: number;
    indir_fuel_number_of_sold: number;
    indir_fuel_consumption: number;
    indir_fuel_consumption_unit: string;
    indir_elec_lifetime: number;
    indir_elec_percentage_of_lifetime: number;
    indir_elec_number_of_sold: number;
    indir_elec_consumption: number;
    indir_elec_consumption_unit: string;
    indir_ref_lifetime: number;
    indir_ref_percentage_of_lifetime: number;
    indir_ref_number_of_sold: number;
    indir_ref_leakage: number;
    indir_ref_leakage_unit: string;
    indir_ghg_lifetime: number;
    indir_ghg_percentage_of_lifetime: number;
    indir_ghg_number_of_sold: number;
    indir_ghg_emit: number;
    indir_ghg_emit_unit: string;
    intermediate_sold: number;
    intermediate_lifetime: number;
    intermediate_ef: number;
    intermediate_ef_unit: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: NetZeroUseOfSoldProductActivityDataActivityDataStatus;
}

export class CreateManyNetZeroUseOfSoldProductActivityDataDto implements ICreateManyNetZeroUseOfSoldProductActivityDataDto {
    bulk: NetZeroUseOfSoldProductActivityData[];

    constructor(data?: ICreateManyNetZeroUseOfSoldProductActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(NetZeroUseOfSoldProductActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyNetZeroUseOfSoldProductActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyNetZeroUseOfSoldProductActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyNetZeroUseOfSoldProductActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyNetZeroUseOfSoldProductActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyNetZeroUseOfSoldProductActivityDataDto {
    bulk: NetZeroUseOfSoldProductActivityData[];
}

export class CgBasedData implements ICgBasedData {
    id: number;
    type_of_cg: string;
    category: string;
    quantity: number | undefined;
    user_input_ef: number | undefined;
    user_input_ef_unit: string;
    quantity_unit: string;

    constructor(data?: ICgBasedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type_of_cg = _data["type_of_cg"];
            this.category = _data["category"];
            this.quantity = _data["quantity"];
            this.user_input_ef = _data["user_input_ef"];
            this.user_input_ef_unit = _data["user_input_ef_unit"];
            this.quantity_unit = _data["quantity_unit"];
        }
    }

    static fromJS(data: any): CgBasedData {
        data = typeof data === 'object' ? data : {};
        let result = new CgBasedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type_of_cg"] = this.type_of_cg;
        data["category"] = this.category;
        data["quantity"] = this.quantity;
        data["user_input_ef"] = this.user_input_ef;
        data["user_input_ef_unit"] = this.user_input_ef_unit;
        data["quantity_unit"] = this.quantity_unit;
        return data;
    }

    clone(): CgBasedData {
        const json = this.toJSON();
        let result = new CgBasedData();
        result.init(json);
        return result;
    }
}

export interface ICgBasedData {
    id: number;
    type_of_cg: string;
    category: string;
    quantity: number | undefined;
    user_input_ef: number | undefined;
    user_input_ef_unit: string;
    quantity_unit: string;
}

export class CapitalGoodsActivityDataDto implements ICapitalGoodsActivityDataDto {
    month: number;
    year: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    groupNo: string;
    method_data: CgBasedData[];

    constructor(data?: ICapitalGoodsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
            this.method_data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.groupNo = _data["groupNo"];
            if (Array.isArray(_data["method_data"])) {
                this.method_data = [] as any;
                for (let item of _data["method_data"])
                    this.method_data.push(CgBasedData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CapitalGoodsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CapitalGoodsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["groupNo"] = this.groupNo;
        if (Array.isArray(this.method_data)) {
            data["method_data"] = [];
            for (let item of this.method_data)
                data["method_data"].push(item.toJSON());
        }
        return data;
    }

    clone(): CapitalGoodsActivityDataDto {
        const json = this.toJSON();
        let result = new CapitalGoodsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICapitalGoodsActivityDataDto {
    month: number;
    year: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    groupNo: string;
    method_data: CgBasedData[];
}

export class GetManyCapitalGoodsActivityDataResponseDto implements IGetManyCapitalGoodsActivityDataResponseDto {
    data: CapitalGoodsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyCapitalGoodsActivityDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(CapitalGoodsActivityData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyCapitalGoodsActivityDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyCapitalGoodsActivityDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyCapitalGoodsActivityDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyCapitalGoodsActivityDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyCapitalGoodsActivityDataResponseDto {
    data: CapitalGoodsActivityData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class CapitalGoodsActivityData implements ICapitalGoodsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    type_of_cg: string;
    category: string;
    quantity: number;
    quantity_unit: string;
    user_input_ef: number;
    user_input_ef_unit: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: CapitalGoodsActivityDataActivityDataStatus;

    constructor(data?: ICapitalGoodsActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.type_of_cg = _data["type_of_cg"];
            this.category = _data["category"];
            this.quantity = _data["quantity"];
            this.quantity_unit = _data["quantity_unit"];
            this.user_input_ef = _data["user_input_ef"];
            this.user_input_ef_unit = _data["user_input_ef_unit"];
            this.emission = _data["emission"];
            this.groupNo = _data["groupNo"];
            this.e_sc_co2 = _data["e_sc_co2"];
            this.e_sc_ch4 = _data["e_sc_ch4"];
            this.e_sc_n2o = _data["e_sc_n2o"];
            this.e_sc = _data["e_sc"];
            this.mobile = _data["mobile"];
            this.stationary = _data["stationary"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.ownership = _data["ownership"];
            this.direct = _data["direct"];
            this.indirect = _data["indirect"];
            this.other = _data["other"];
            this.activityDataStatus = _data["activityDataStatus"];
        }
    }

    static fromJS(data: any): CapitalGoodsActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new CapitalGoodsActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["month"] = this.month;
        data["year"] = this.year;
        data["type_of_cg"] = this.type_of_cg;
        data["category"] = this.category;
        data["quantity"] = this.quantity;
        data["quantity_unit"] = this.quantity_unit;
        data["user_input_ef"] = this.user_input_ef;
        data["user_input_ef_unit"] = this.user_input_ef_unit;
        data["emission"] = this.emission;
        data["groupNo"] = this.groupNo;
        data["e_sc_co2"] = this.e_sc_co2;
        data["e_sc_ch4"] = this.e_sc_ch4;
        data["e_sc_n2o"] = this.e_sc_n2o;
        data["e_sc"] = this.e_sc;
        data["mobile"] = this.mobile;
        data["stationary"] = this.stationary;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["ownership"] = this.ownership;
        data["direct"] = this.direct;
        data["indirect"] = this.indirect;
        data["other"] = this.other;
        data["activityDataStatus"] = this.activityDataStatus;
        return data;
    }

    clone(): CapitalGoodsActivityData {
        const json = this.toJSON();
        let result = new CapitalGoodsActivityData();
        result.init(json);
        return result;
    }
}

export interface ICapitalGoodsActivityData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    month: number;
    year: number;
    type_of_cg: string;
    category: string;
    quantity: number;
    quantity_unit: string;
    user_input_ef: number;
    user_input_ef_unit: string;
    emission: number;
    groupNo: string;
    e_sc_co2: number;
    e_sc_ch4: number;
    e_sc_n2o: number;
    e_sc: number;
    mobile: boolean;
    stationary: boolean;
    user: User;
    unit: Unit;
    project: Project;
    ownership: string;
    direct: boolean;
    indirect: boolean;
    other: boolean;
    activityDataStatus: CapitalGoodsActivityDataActivityDataStatus;
}

export class CreateManyCapitalGoodsActivityDataDto implements ICreateManyCapitalGoodsActivityDataDto {
    bulk: CapitalGoodsActivityData[];

    constructor(data?: ICreateManyCapitalGoodsActivityDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(CapitalGoodsActivityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyCapitalGoodsActivityDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyCapitalGoodsActivityDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyCapitalGoodsActivityDataDto {
        const json = this.toJSON();
        let result = new CreateManyCapitalGoodsActivityDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyCapitalGoodsActivityDataDto {
    bulk: CapitalGoodsActivityData[];
}

export class ManyParameterDto implements IManyParameterDto {
    esList: EsList3[];

    constructor(data?: IManyParameterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.esList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["esList"])) {
                this.esList = [] as any;
                for (let item of _data["esList"])
                    this.esList.push(item);
            }
        }
    }

    static fromJS(data: any): ManyParameterDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManyParameterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.esList)) {
            data["esList"] = [];
            for (let item of this.esList)
                data["esList"].push(item);
        }
        return data;
    }

    clone(): ManyParameterDto {
        const json = this.toJSON();
        let result = new ManyParameterDto();
        result.init(json);
        return result;
    }
}

export interface IManyParameterDto {
    esList: EsList3[];
}

export class ManyParameterResDto implements IManyParameterResDto {
    es: ManyParameterResDtoEs;
    parameters: Parameter[];

    constructor(data?: IManyParameterResDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parameters = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.es = _data["es"];
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters.push(Parameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ManyParameterResDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManyParameterResDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["es"] = this.es;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        return data;
    }

    clone(): ManyParameterResDto {
        const json = this.toJSON();
        let result = new ManyParameterResDto();
        result.init(json);
        return result;
    }
}

export interface IManyParameterResDto {
    es: ManyParameterResDtoEs;
    parameters: Parameter[];
}

export class CreateManyParameterDto implements ICreateManyParameterDto {
    bulk: Parameter[];

    constructor(data?: ICreateManyParameterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Parameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyParameterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyParameterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyParameterDto {
        const json = this.toJSON();
        let result = new CreateManyParameterDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyParameterDto {
    bulk: Parameter[];
}

export class GenerateDto implements IGenerateDto {
    unitId: number;
    projectId: number;
    types: any[];
    versionName: string;

    constructor(data?: IGenerateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.types = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unitId = _data["unitId"];
            this.projectId = _data["projectId"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types.push(item);
            }
            this.versionName = _data["versionName"];
        }
    }

    static fromJS(data: any): GenerateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        data["projectId"] = this.projectId;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["versionName"] = this.versionName;
        return data;
    }

    clone(): GenerateDto {
        const json = this.toJSON();
        let result = new GenerateDto();
        result.init(json);
        return result;
    }
}

export interface IGenerateDto {
    unitId: number;
    projectId: number;
    types: any[];
    versionName: string;
}

export class ExicutiveSummeryGraphDto implements IExicutiveSummeryGraphDto {
    emissionType: any;
    totalGhgEmission: any;
    emissionSource: any;
    ghgEmission: any;

    constructor(data?: IExicutiveSummeryGraphDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emissionType = _data["emissionType"];
            this.totalGhgEmission = _data["totalGhgEmission"];
            this.emissionSource = _data["emissionSource"];
            this.ghgEmission = _data["ghgEmission"];
        }
    }

    static fromJS(data: any): ExicutiveSummeryGraphDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExicutiveSummeryGraphDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emissionType"] = this.emissionType;
        data["totalGhgEmission"] = this.totalGhgEmission;
        data["emissionSource"] = this.emissionSource;
        data["ghgEmission"] = this.ghgEmission;
        return data;
    }

    clone(): ExicutiveSummeryGraphDto {
        const json = this.toJSON();
        let result = new ExicutiveSummeryGraphDto();
        result.init(json);
        return result;
    }
}

export interface IExicutiveSummeryGraphDto {
    emissionType: any;
    totalGhgEmission: any;
    emissionSource: any;
    ghgEmission: any;
}

export class ResultGraphDto implements IResultGraphDto {
    directSource: any;
    directEmission: any;
    indirectSource: any;
    indirectEmission: any;

    constructor(data?: IResultGraphDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.directSource = _data["directSource"];
            this.directEmission = _data["directEmission"];
            this.indirectSource = _data["indirectSource"];
            this.indirectEmission = _data["indirectEmission"];
        }
    }

    static fromJS(data: any): ResultGraphDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultGraphDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["directSource"] = this.directSource;
        data["directEmission"] = this.directEmission;
        data["indirectSource"] = this.indirectSource;
        data["indirectEmission"] = this.indirectEmission;
        return data;
    }

    clone(): ResultGraphDto {
        const json = this.toJSON();
        let result = new ResultGraphDto();
        result.init(json);
        return result;
    }
}

export interface IResultGraphDto {
    directSource: any;
    directEmission: any;
    indirectSource: any;
    indirectEmission: any;
}

export class ComparisonGraphDto implements IComparisonGraphDto {
    year: any;
    directGhgEmission: any;
    emissionSourceDirect: any;
    emissionSourceIndirect: any;
    indirectGhgEmission: any;
    ghgDirectEmissionYear1: any;
    ghgDirectEmissionYear2: any;
    ghgDirectEmissionYear3: any;
    ghgDirectEmissionYear4: any;
    ghgIndirectEmissionYear1: any;
    ghgIndirectEmissionYear2: any;
    ghgIndirectEmissionYear3: any;
    ghgIndirectEmissionYear4: any;
    perCapitaEmission: any;
    emissionIntensity: any;

    constructor(data?: IComparisonGraphDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.directGhgEmission = _data["directGhgEmission"];
            this.emissionSourceDirect = _data["emissionSourceDirect"];
            this.emissionSourceIndirect = _data["emissionSourceIndirect"];
            this.indirectGhgEmission = _data["indirectGhgEmission"];
            this.ghgDirectEmissionYear1 = _data["ghgDirectEmissionYear1"];
            this.ghgDirectEmissionYear2 = _data["ghgDirectEmissionYear2"];
            this.ghgDirectEmissionYear3 = _data["ghgDirectEmissionYear3"];
            this.ghgDirectEmissionYear4 = _data["ghgDirectEmissionYear4"];
            this.ghgIndirectEmissionYear1 = _data["ghgIndirectEmissionYear1"];
            this.ghgIndirectEmissionYear2 = _data["ghgIndirectEmissionYear2"];
            this.ghgIndirectEmissionYear3 = _data["ghgIndirectEmissionYear3"];
            this.ghgIndirectEmissionYear4 = _data["ghgIndirectEmissionYear4"];
            this.perCapitaEmission = _data["perCapitaEmission"];
            this.emissionIntensity = _data["emissionIntensity"];
        }
    }

    static fromJS(data: any): ComparisonGraphDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComparisonGraphDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["directGhgEmission"] = this.directGhgEmission;
        data["emissionSourceDirect"] = this.emissionSourceDirect;
        data["emissionSourceIndirect"] = this.emissionSourceIndirect;
        data["indirectGhgEmission"] = this.indirectGhgEmission;
        data["ghgDirectEmissionYear1"] = this.ghgDirectEmissionYear1;
        data["ghgDirectEmissionYear2"] = this.ghgDirectEmissionYear2;
        data["ghgDirectEmissionYear3"] = this.ghgDirectEmissionYear3;
        data["ghgDirectEmissionYear4"] = this.ghgDirectEmissionYear4;
        data["ghgIndirectEmissionYear1"] = this.ghgIndirectEmissionYear1;
        data["ghgIndirectEmissionYear2"] = this.ghgIndirectEmissionYear2;
        data["ghgIndirectEmissionYear3"] = this.ghgIndirectEmissionYear3;
        data["ghgIndirectEmissionYear4"] = this.ghgIndirectEmissionYear4;
        data["perCapitaEmission"] = this.perCapitaEmission;
        data["emissionIntensity"] = this.emissionIntensity;
        return data;
    }

    clone(): ComparisonGraphDto {
        const json = this.toJSON();
        let result = new ComparisonGraphDto();
        result.init(json);
        return result;
    }
}

export interface IComparisonGraphDto {
    year: any;
    directGhgEmission: any;
    emissionSourceDirect: any;
    emissionSourceIndirect: any;
    indirectGhgEmission: any;
    ghgDirectEmissionYear1: any;
    ghgDirectEmissionYear2: any;
    ghgDirectEmissionYear3: any;
    ghgDirectEmissionYear4: any;
    ghgIndirectEmissionYear1: any;
    ghgIndirectEmissionYear2: any;
    ghgIndirectEmissionYear3: any;
    ghgIndirectEmissionYear4: any;
    perCapitaEmission: any;
    emissionIntensity: any;
}

export class GraphsDto implements IGraphsDto {
    exicutiveSummery: ExicutiveSummeryGraphDto;
    result: ResultGraphDto;
    comparison: ComparisonGraphDto;
    data: any;

    constructor(data?: IGraphsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.exicutiveSummery = new ExicutiveSummeryGraphDto();
            this.result = new ResultGraphDto();
            this.comparison = new ComparisonGraphDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exicutiveSummery = _data["exicutiveSummery"] ? ExicutiveSummeryGraphDto.fromJS(_data["exicutiveSummery"]) : new ExicutiveSummeryGraphDto();
            this.result = _data["result"] ? ResultGraphDto.fromJS(_data["result"]) : new ResultGraphDto();
            this.comparison = _data["comparison"] ? ComparisonGraphDto.fromJS(_data["comparison"]) : new ComparisonGraphDto();
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): GraphsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GraphsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exicutiveSummery"] = this.exicutiveSummery ? this.exicutiveSummery.toJSON() : <any>undefined;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["comparison"] = this.comparison ? this.comparison.toJSON() : <any>undefined;
        data["data"] = this.data;
        return data;
    }

    clone(): GraphsDto {
        const json = this.toJSON();
        let result = new GraphsDto();
        result.init(json);
        return result;
    }
}

export interface IGraphsDto {
    exicutiveSummery: ExicutiveSummeryGraphDto;
    result: ResultGraphDto;
    comparison: ComparisonGraphDto;
    data: any;
}

export class CreateManyReportDto implements ICreateManyReportDto {
    bulk: Report[];

    constructor(data?: ICreateManyReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Report.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyReportDto {
        const json = this.toJSON();
        let result = new CreateManyReportDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyReportDto {
    bulk: Report[];
}

export class GetManyReportHistoryResponseDto implements IGetManyReportHistoryResponseDto {
    data: ReportHistory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyReportHistoryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ReportHistory.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyReportHistoryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyReportHistoryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyReportHistoryResponseDto {
        const json = this.toJSON();
        let result = new GetManyReportHistoryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyReportHistoryResponseDto {
    data: ReportHistory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ReportHistory implements IReportHistory {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    reportName: string;
    generateReportName: string;
    savedLocation: string;
    thumbnail: string;
    unit: Unit;
    project: Project;
    versionName: string;

    constructor(data?: IReportHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.reportName = _data["reportName"];
            this.generateReportName = _data["generateReportName"];
            this.savedLocation = _data["savedLocation"];
            this.thumbnail = _data["thumbnail"];
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
            this.versionName = _data["versionName"];
        }
    }

    static fromJS(data: any): ReportHistory {
        data = typeof data === 'object' ? data : {};
        let result = new ReportHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["reportName"] = this.reportName;
        data["generateReportName"] = this.generateReportName;
        data["savedLocation"] = this.savedLocation;
        data["thumbnail"] = this.thumbnail;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["versionName"] = this.versionName;
        return data;
    }

    clone(): ReportHistory {
        const json = this.toJSON();
        let result = new ReportHistory();
        result.init(json);
        return result;
    }
}

export interface IReportHistory {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    reportName: string;
    generateReportName: string;
    savedLocation: string;
    thumbnail: string;
    unit: Unit;
    project: Project;
    versionName: string;
}

export class CreateManyReportHistoryDto implements ICreateManyReportHistoryDto {
    bulk: ReportHistory[];

    constructor(data?: ICreateManyReportHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ReportHistory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyReportHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyReportHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyReportHistoryDto {
        const json = this.toJSON();
        let result = new CreateManyReportHistoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyReportHistoryDto {
    bulk: ReportHistory[];
}

export class CreateManyUncertaintyDto implements ICreateManyUncertaintyDto {
    bulk: Uncertainty[];

    constructor(data?: ICreateManyUncertaintyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Uncertainty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUncertaintyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUncertaintyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyUncertaintyDto {
        const json = this.toJSON();
        let result = new CreateManyUncertaintyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUncertaintyDto {
    bulk: Uncertainty[];
}

export class GetManyAirPortsDisResponseDto implements IGetManyAirPortsDisResponseDto {
    data: AirPortsDis[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyAirPortsDisResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(AirPortsDis.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyAirPortsDisResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyAirPortsDisResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyAirPortsDisResponseDto {
        const json = this.toJSON();
        let result = new GetManyAirPortsDisResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyAirPortsDisResponseDto {
    data: AirPortsDis[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class AirPortsDis implements IAirPortsDis {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code1: string;
    code2: string;
    distance: number;

    constructor(data?: IAirPortsDis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.code1 = _data["code1"];
            this.code2 = _data["code2"];
            this.distance = _data["distance"];
        }
    }

    static fromJS(data: any): AirPortsDis {
        data = typeof data === 'object' ? data : {};
        let result = new AirPortsDis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["code1"] = this.code1;
        data["code2"] = this.code2;
        data["distance"] = this.distance;
        return data;
    }

    clone(): AirPortsDis {
        const json = this.toJSON();
        let result = new AirPortsDis();
        result.init(json);
        return result;
    }
}

export interface IAirPortsDis {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code1: string;
    code2: string;
    distance: number;
}

export class CreateManyAirPortsDisDto implements ICreateManyAirPortsDisDto {
    bulk: AirPortsDis[];

    constructor(data?: ICreateManyAirPortsDisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(AirPortsDis.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyAirPortsDisDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyAirPortsDisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyAirPortsDisDto {
        const json = this.toJSON();
        let result = new CreateManyAirPortsDisDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyAirPortsDisDto {
    bulk: AirPortsDis[];
}

export class GetManySeaPortsDisResponseDto implements IGetManySeaPortsDisResponseDto {
    data: SeaPortsDis[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManySeaPortsDisResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(SeaPortsDis.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManySeaPortsDisResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManySeaPortsDisResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManySeaPortsDisResponseDto {
        const json = this.toJSON();
        let result = new GetManySeaPortsDisResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManySeaPortsDisResponseDto {
    data: SeaPortsDis[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class SeaPortsDis implements ISeaPortsDis {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code1: string;
    code2: string;
    distance: number;

    constructor(data?: ISeaPortsDis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.code1 = _data["code1"];
            this.code2 = _data["code2"];
            this.distance = _data["distance"];
        }
    }

    static fromJS(data: any): SeaPortsDis {
        data = typeof data === 'object' ? data : {};
        let result = new SeaPortsDis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["code1"] = this.code1;
        data["code2"] = this.code2;
        data["distance"] = this.distance;
        return data;
    }

    clone(): SeaPortsDis {
        const json = this.toJSON();
        let result = new SeaPortsDis();
        result.init(json);
        return result;
    }
}

export interface ISeaPortsDis {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code1: string;
    code2: string;
    distance: number;
}

export class CreateManySeaPortsDisDto implements ICreateManySeaPortsDisDto {
    bulk: SeaPortsDis[];

    constructor(data?: ICreateManySeaPortsDisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(SeaPortsDis.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManySeaPortsDisDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManySeaPortsDisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManySeaPortsDisDto {
        const json = this.toJSON();
        let result = new CreateManySeaPortsDisDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManySeaPortsDisDto {
    bulk: SeaPortsDis[];
}

export class CreateManyAirPortDto implements ICreateManyAirPortDto {
    bulk: AirPort[];

    constructor(data?: ICreateManyAirPortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(AirPort.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyAirPortDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyAirPortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyAirPortDto {
        const json = this.toJSON();
        let result = new CreateManyAirPortDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyAirPortDto {
    bulk: AirPort[];
}

export class CreateManySeaPortDto implements ICreateManySeaPortDto {
    bulk: SeaPort[];

    constructor(data?: ICreateManySeaPortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(SeaPort.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManySeaPortDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManySeaPortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManySeaPortDto {
        const json = this.toJSON();
        let result = new CreateManySeaPortDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManySeaPortDto {
    bulk: SeaPort[];
}

export class CreateManyRailPortDto implements ICreateManyRailPortDto {
    bulk: RailPort[];

    constructor(data?: ICreateManyRailPortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(RailPort.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyRailPortDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyRailPortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyRailPortDto {
        const json = this.toJSON();
        let result = new CreateManyRailPortDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyRailPortDto {
    bulk: RailPort[];
}

export class GetManyPassengerAirPortResponseDto implements IGetManyPassengerAirPortResponseDto {
    data: PassengerAirPort[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPassengerAirPortResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PassengerAirPort.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPassengerAirPortResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPassengerAirPortResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyPassengerAirPortResponseDto {
        const json = this.toJSON();
        let result = new GetManyPassengerAirPortResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPassengerAirPortResponseDto {
    data: PassengerAirPort[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PassengerAirPort implements IPassengerAirPort {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    city_name: string;
    airport_code: string;

    constructor(data?: IPassengerAirPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.city_name = _data["city_name"];
            this.airport_code = _data["airport_code"];
        }
    }

    static fromJS(data: any): PassengerAirPort {
        data = typeof data === 'object' ? data : {};
        let result = new PassengerAirPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["city_name"] = this.city_name;
        data["airport_code"] = this.airport_code;
        return data;
    }

    clone(): PassengerAirPort {
        const json = this.toJSON();
        let result = new PassengerAirPort();
        result.init(json);
        return result;
    }
}

export interface IPassengerAirPort {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    city_name: string;
    airport_code: string;
}

export class CreateManyPassengerAirPortDto implements ICreateManyPassengerAirPortDto {
    bulk: PassengerAirPort[];

    constructor(data?: ICreateManyPassengerAirPortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PassengerAirPort.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPassengerAirPortDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPassengerAirPortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyPassengerAirPortDto {
        const json = this.toJSON();
        let result = new CreateManyPassengerAirPortDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPassengerAirPortDto {
    bulk: PassengerAirPort[];
}

export class GetManyMitigationResponseDto implements IGetManyMitigationResponseDto {
    data: Mitigation[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyMitigationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Mitigation.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyMitigationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyMitigationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyMitigationResponseDto {
        const json = this.toJSON();
        let result = new GetManyMitigationResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyMitigationResponseDto {
    data: Mitigation[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Mitigation implements IMitigation {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    title: string;
    descryption: string;
    unit: Unit;
    project: Project;

    constructor(data?: IMitigation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unit = new Unit();
            this.project = new Project();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.title = _data["title"];
            this.descryption = _data["descryption"];
            this.unit = _data["unit"] ? Unit.fromJS(_data["unit"]) : new Unit();
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : new Project();
        }
    }

    static fromJS(data: any): Mitigation {
        data = typeof data === 'object' ? data : {};
        let result = new Mitigation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["title"] = this.title;
        data["descryption"] = this.descryption;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data;
    }

    clone(): Mitigation {
        const json = this.toJSON();
        let result = new Mitigation();
        result.init(json);
        return result;
    }
}

export interface IMitigation {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    title: string;
    descryption: string;
    unit: Unit;
    project: Project;
}

export class CreateManyMitigationDto implements ICreateManyMitigationDto {
    bulk: Mitigation[];

    constructor(data?: ICreateManyMitigationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Mitigation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyMitigationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyMitigationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyMitigationDto {
        const json = this.toJSON();
        let result = new CreateManyMitigationDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyMitigationDto {
    bulk: Mitigation[];
}

export class CreateManyNextStepDto implements ICreateManyNextStepDto {
    bulk: NextStep[];

    constructor(data?: ICreateManyNextStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(NextStep.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyNextStepDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyNextStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyNextStepDto {
        const json = this.toJSON();
        let result = new CreateManyNextStepDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyNextStepDto {
    bulk: NextStep[];
}

export class CreateManyRecomendationDto implements ICreateManyRecomendationDto {
    bulk: Recomendation[];

    constructor(data?: ICreateManyRecomendationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Recomendation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyRecomendationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyRecomendationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyRecomendationDto {
        const json = this.toJSON();
        let result = new CreateManyRecomendationDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyRecomendationDto {
    bulk: Recomendation[];
}

export class CreateEmailDto implements ICreateEmailDto {
    name: string;
    email: string;
    phone: string;
    message: string;

    constructor(data?: ICreateEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreateEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["message"] = this.message;
        return data;
    }

    clone(): CreateEmailDto {
        const json = this.toJSON();
        let result = new CreateEmailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateEmailDto {
    name: string;
    email: string;
    phone: string;
    message: string;
}

export enum ProjectStatus {
    Initial = <any>"Initial",
    New = <any>"New",
    Payment_Pending = <any>"Payment Pending",
    Payment_Completed = <any>"Payment Completed",
    DataEntry = <any>"DataEntry",
    Data_Completed = <any>"Data Completed",
    Verification_Pending = <any>"Verification Pending",
    Evidence_Pending = <any>"Evidence Pending",
    Verified = <any>"Verified",
    Unverified = <any>"Unverified",
    Closed = <any>"Closed",
}

export enum ProjectUnitEmissionSourceTier {
    ONE = <any>"ONE",
    TWO = <any>"TWO",
    THREE = <any>"THREE",
}

export enum ProjectUnitEmissionSourceClasification {
    Direct = <any>"Direct",
    Indirect = <any>"Indirect",
    Other = <any>"Other",
    Any = <any>"Any",
}

export enum ProjectUnitEmissionSourceScope {
    ONE = <any>"ONE",
    TWO = <any>"TWO",
    THREE = <any>"THREE",
}

export enum IndustryType {
    M = <any>"M",
    S = <any>"S",
}

export enum UnitStatus {
    Initial = <any>"Initial",
    SIGNED = <any>"SIGNED",
    APPROVED = <any>"APPROVED",
    DATA_REQUESTED = <any>"DATA_REQUESTED",
}

export enum UnitDetailMessageMessageAction {
    SUBMITED = <any>"SUBMITED",
}

export enum BulckDeletDtoEs {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum ManyActivityDataDtoEs {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum EsList {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum EsList2 {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum ProgressDetailDtoEsCode {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum ActivityDataDownloadDtoEsCode {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum ElectricityActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum EmissionSourceOfProjectUnitTier {
    ONE = <any>"ONE",
    TWO = <any>"TWO",
    THREE = <any>"THREE",
}

export enum EmissionSourceOfProjectUnitScope {
    ONE = <any>"ONE",
    TWO = <any>"TWO",
    THREE = <any>"THREE",
}

export enum EmissionSourceOfProjectUnitClasification {
    Direct = <any>"Direct",
    Indirect = <any>"Indirect",
    Other = <any>"Other",
    Any = <any>"Any",
}

export enum PuesDataReqActivityDataOwenerShip {
    Own = <any>"Own",
    Hired = <any>"Hired",
    Rented = <any>"Rented",
    Other = <any>"Other",
}

export enum PuesDataReqDtoSourceName {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum PuesDataDtoClasification {
    Direct = <any>"Direct",
    Indirect = <any>"Indirect",
    Other = <any>"Other",
    Any = <any>"Any",
}

export enum PuesDataDtoTier {
    ONE = <any>"ONE",
    TWO = <any>"TWO",
    THREE = <any>"THREE",
}

export enum PuesDataDtoSourceType {
    M = <any>"M",
    S = <any>"S",
    B = <any>"B",
}

export enum TNDLossActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum GeneratorActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum FireExtinguisherActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum RefrigerantActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum WeldingEsActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum ForkliftsActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum BoilerActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum WasteWaterTreatmentActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum MunicipalWaterActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum EvidenceRequestEvidenceStatus {
    Pending = <any>"Pending",
    Uploaded = <any>"Uploaded",
    Approved = <any>"Approved",
    Rejected = <any>"Rejected",
    Returned = <any>"Returned",
}

export enum EvidenceRequestEsCode {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum GetRequestsDtoEsCode {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum GetRequestsDtoStatus {
    Pending = <any>"Pending",
    Uploaded = <any>"Uploaded",
    Approved = <any>"Approved",
    Rejected = <any>"Rejected",
    Returned = <any>"Returned",
}

export enum EsCodes {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum WasteDisposalActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum CookingGasActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum FreightAirActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum FreightRailActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum FreightRoadActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum FreightWaterActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum FreightOffroadActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum PassengerRoadActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum PassengerOffroadActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum PassengerRailActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum PassengerAirActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum PassengerWaterActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum BusinessTravelActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum OffroadMachineryOffroadActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum WasteDataWaste_activity {
    BIOLOGICAL_TREATMENT = <any>"BIOLOGICAL_TREATMENT",
    WASTE_INCINERATION = <any>"WASTE_INCINERATION",
    OPEN_BURNING = <any>"OPEN_BURNING",
    DOMESTIC_WASTEWATER = <any>"DOMESTIC_WASTEWATER",
    INDUSTRIAL_WASTEWATER = <any>"INDUSTRIAL_WASTEWATER",
    OTHER_ACTIVITIES_BASED_ON_DEFRA = <any>"OTHER_ACTIVITIES_BASED_ON_DEFRA",
    INCINERATION = <any>"INCINERATION",
}

export enum CreatePurchasedGoodsAndServiceDtoMethod {
    Supplier_Specific_Method = <any>"Supplier Specific Method",
    Hybrid_Method = <any>"Hybrid Method",
    Average_Data_Method = <any>"Average Data Method",
    Spend_Based_Method = <any>"Spend Based Method",
}

export enum CreatePurchasedGoodsAndServiceDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum PurchasedGoodsAndServicesActivityDataMode {
    Supplier_Specific_Method = <any>"Supplier Specific Method",
    Hybrid_Method = <any>"Hybrid Method",
    Average_Data_Method = <any>"Average Data Method",
    Spend_Based_Method = <any>"Spend Based Method",
}

export enum PurchasedGoodsAndServicesActivityDataWaste_activity {
    BIOLOGICAL_TREATMENT = <any>"BIOLOGICAL_TREATMENT",
    WASTE_INCINERATION = <any>"WASTE_INCINERATION",
    OPEN_BURNING = <any>"OPEN_BURNING",
    DOMESTIC_WASTEWATER = <any>"DOMESTIC_WASTEWATER",
    INDUSTRIAL_WASTEWATER = <any>"INDUSTRIAL_WASTEWATER",
    OTHER_ACTIVITIES_BASED_ON_DEFRA = <any>"OTHER_ACTIVITIES_BASED_ON_DEFRA",
    INCINERATION = <any>"INCINERATION",
}

export enum PurchasedGoodsAndServicesActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum WasteTypeSpecificWasteGeneratedInOperationsEmissionSourceDataSolid_or_water {
    Solid = <any>"solid",
    Water = <any>"water",
}

export enum WasteGeneratedInOperationsActivityDataDtoMethod {
    SupplierSpecific = <any>"supplier-specific",
    WasteTypeSpecific = <any>"waste-type-specific",
    AverageData = <any>"average-data",
}

export enum WasteGeneratedInOperationsActivityDataDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum WasteGeneratedInOperationsActivityDataMethod {
    SupplierSpecific = <any>"supplier-specific",
    WasteTypeSpecific = <any>"waste-type-specific",
    AverageData = <any>"average-data",
}

export enum WasteGeneratedInOperationsActivityDataSolid_or_water {
    Solid = <any>"solid",
    Water = <any>"water",
}

export enum WasteGeneratedInOperationsActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum FuelEnergyRelatedActivitiesActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum InvestmentsActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum NetZeroBusinessTravelActivityDataDtoMethod {
    FuelBase = <any>"fuel-base",
    DistanceBase = <any>"distance-base",
    SpendBase = <any>"spend-base",
}

export enum NetZeroBusinessTravelActivityDataDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum NetZeroBusinessTravelActivityDataMethod {
    FuelBase = <any>"fuel-base",
    DistanceBase = <any>"distance-base",
    SpendBase = <any>"spend-base",
}

export enum NetZeroBusinessTravelActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum NetZeroEmployeeCommutingActivityDataDtoMethod {
    FuelBase = <any>"fuel-base",
    DistanceBase = <any>"distance-base",
    AverageDataBase = <any>"average-data-base",
}

export enum NetZeroEmployeeCommutingActivityDataDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum NetZeroEmployeeCommutingActivityDataMethod {
    FuelBase = <any>"fuel-base",
    DistanceBase = <any>"distance-base",
    AverageDataBase = <any>"average-data-base",
}

export enum NetZeroEmployeeCommutingActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum EndOfLifeTreatmentOfSoldProductsActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum UpstreamLeasedAssetsActivityDataDtoActivityType {
    Fuel_asset_specific_method_data = <any>"fuel_asset_specific_method_data",
    Distance_lessor_specific_method_data = <any>"distance_lessor_specific_method_data",
    Spend_leased_buildings_method_data = <any>"spend_leased_buildings_method_data",
    Leased_assets_method_data = <any>"leased_assets_method_data",
}

export enum UpstreamLeasedAssetsActivityDataDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum UpstreamLeasedAssetsActivityDataActivityType {
    Fuel_asset_specific_method_data = <any>"fuel_asset_specific_method_data",
    Distance_lessor_specific_method_data = <any>"distance_lessor_specific_method_data",
    Spend_leased_buildings_method_data = <any>"spend_leased_buildings_method_data",
    Leased_assets_method_data = <any>"leased_assets_method_data",
}

export enum UpstreamLeasedAssetsActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum ProcessingOfSoldProductsActivityDataDtoActivityType {
    Site_specific_method_cO2 = <any>"site_specific_method_cO2",
    Average_data_method = <any>"average_data_method",
}

export enum ProcessingOfSoldProductsActivityDataDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum ProcessingOfSoldProductsActivityDataActivityType {
    Site_specific_method_cO2 = <any>"site_specific_method_cO2",
    Average_data_method = <any>"average_data_method",
}

export enum ProcessingOfSoldProductsActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum FranchisesActivityDataDtoMethod {
    SPECIFICMETHOD = <any>"SPECIFIC-METHOD",
    NOTSUBMETERED = <any>"NOT-SUB-METERED",
    SAMPLEGROUPS = <any>"SAMPLE-GROUPS",
    AVERAGEDATAMETHODFLOORSPACE = <any>"AVERAGE-DATA-METHOD-FLOOR-SPACE",
    AVERAGEDATAMETHODNOTFLOORSPACE = <any>"AVERAGE-DATA-METHOD-NOT-FLOOR-SPACE",
}

export enum FranchisesActivityDataDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum FranchisesActivityDataMethod {
    SPECIFICMETHOD = <any>"SPECIFIC-METHOD",
    NOTSUBMETERED = <any>"NOT-SUB-METERED",
    SAMPLEGROUPS = <any>"SAMPLE-GROUPS",
    AVERAGEDATAMETHODFLOORSPACE = <any>"AVERAGE-DATA-METHOD-FLOOR-SPACE",
    AVERAGEDATAMETHODNOTFLOORSPACE = <any>"AVERAGE-DATA-METHOD-NOT-FLOOR-SPACE",
}

export enum FranchisesActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum DownstreamLeasedAssetsActivityDataDtoMethod {
    Asset_specific_method_data = <any>"asset_specific_method_data",
    Lessor_specific_method_data = <any>"lessor_specific_method_data",
    Leased_buildings_method_data = <any>"leased_buildings_method_data",
    Leased_assets_method_data = <any>"leased_assets_method_data",
}

export enum DownstreamLeasedAssetsActivityDataDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum DownstreamLeasedAssetsActivityDataMethod {
    Asset_specific_method_data = <any>"asset_specific_method_data",
    Lessor_specific_method_data = <any>"lessor_specific_method_data",
    Leased_buildings_method_data = <any>"leased_buildings_method_data",
    Leased_assets_method_data = <any>"leased_assets_method_data",
}

export enum DownstreamLeasedAssetsActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum DownstreamTransportationActivityDataDtoMethod {
    FUELBASEMETHOD = <any>"FUEL-BASE-METHOD",
    DISTANCEBASEMETHOD = <any>"DISTANCE-BASE-METHOD",
    SPENDBASEMETHOD = <any>"SPEND-BASE-METHOD",
    SITESPECIFICMETHOD = <any>"SITE-SPECIFIC-METHOD",
    AVERAGEDATAMETHOD = <any>"AVERAGE-DATA-METHOD",
}

export enum DownstreamTransportationActivityDataDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum DownstreamTransportationActivityDataMethod {
    FUELBASEMETHOD = <any>"FUEL-BASE-METHOD",
    DISTANCEBASEMETHOD = <any>"DISTANCE-BASE-METHOD",
    SPENDBASEMETHOD = <any>"SPEND-BASE-METHOD",
    SITESPECIFICMETHOD = <any>"SITE-SPECIFIC-METHOD",
    AVERAGEDATAMETHOD = <any>"AVERAGE-DATA-METHOD",
}

export enum DownstreamTransportationActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum UpstreamTransportationActivityDataDtoMethod {
    FUELBASEMETHOD = <any>"FUEL-BASE-METHOD",
    DISTANCEBASEMETHOD = <any>"DISTANCE-BASE-METHOD",
    SPENDBASEMETHOD = <any>"SPEND-BASE-METHOD",
    SITESPECIFICMETHOD = <any>"SITE-SPECIFIC-METHOD",
    AVERAGEDATAMETHOD = <any>"AVERAGE-DATA-METHOD",
}

export enum UpstreamTransportationActivityDataDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum UpstreamTransportationActivityDataMethod {
    FUELBASEMETHOD = <any>"FUEL-BASE-METHOD",
    DISTANCEBASEMETHOD = <any>"DISTANCE-BASE-METHOD",
    SPENDBASEMETHOD = <any>"SPEND-BASE-METHOD",
    SITESPECIFICMETHOD = <any>"SITE-SPECIFIC-METHOD",
    AVERAGEDATAMETHOD = <any>"AVERAGE-DATA-METHOD",
}

export enum UpstreamTransportationActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum CreateNetZeroUseOfSoldProductDtoMethod {
    DIRECT_ENERGY = <any>"DIRECT_ENERGY",
    DIRECT_COMBUSTED = <any>"DIRECT_COMBUSTED",
    DIRECT_GREENHOUSE = <any>"DIRECT_GREENHOUSE",
    INDIRECT_ENERGY = <any>"INDIRECT_ENERGY",
    INTERMEDIATE_PRODUCTS = <any>"INTERMEDIATE_PRODUCTS",
}

export enum CreateNetZeroUseOfSoldProductDtoActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum NetZeroUseOfSoldProductActivityDataMode {
    DIRECT_ENERGY = <any>"DIRECT_ENERGY",
    DIRECT_COMBUSTED = <any>"DIRECT_COMBUSTED",
    DIRECT_GREENHOUSE = <any>"DIRECT_GREENHOUSE",
    INDIRECT_ENERGY = <any>"INDIRECT_ENERGY",
    INTERMEDIATE_PRODUCTS = <any>"INTERMEDIATE_PRODUCTS",
}

export enum NetZeroUseOfSoldProductActivityDataTypeName {
    Direct_fuel_consumption = <any>"Direct fuel consumption",
    Direct_electricity_consumption = <any>"Direct electricity consumption",
    Direct_refrigerant_leakage = <any>"Direct refrigerant leakage",
    Direct_combusted = <any>"Direct combusted",
    Direct_Greenhouse = <any>"Direct Greenhouse",
    Indirect_fuel_consumption = <any>"Indirect fuel consumption",
    Indirect_electricity_consumption = <any>"Indirect electricity consumption",
    Indirect_refrigerant_leakage = <any>"Indirect refrigerant leakage",
    Indirect_GHG_emitted = <any>"Indirect GHG emitted",
    Intermediate_products = <any>"Intermediate products",
}

export enum NetZeroUseOfSoldProductActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum CapitalGoodsActivityDataActivityDataStatus {
    Data_Entered = <any>"Data Entered",
    Evidence_Pending = <any>"Evidence Pending",
    Evidence_Approved = <any>"Evidence Approved",
}

export enum EsList3 {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export enum ManyParameterResDtoEs {
    Electricity = <any>"electricity",
    Generator = <any>"generator",
    Fire_extinguisher = <any>"fire_extinguisher",
    Refrigerant = <any>"refrigerant",
    Gas_biomass = <any>"gas_biomass",
    Welding_es = <any>"welding_es",
    Forklifts = <any>"forklifts",
    Boiler = <any>"boiler",
    Waste_water_treatment = <any>"waste_water_treatment",
    Municipal_water = <any>"municipal_water",
    Waste_disposal = <any>"waste_disposal",
    Cooking_gas = <any>"cooking_gas",
    Freight_air = <any>"freight_air",
    Freight_offroad = <any>"freight_offroad",
    Freight_rail = <any>"freight_rail",
    Freight_road = <any>"freight_road",
    Freight_water = <any>"freight_water",
    Passenger_air = <any>"passenger_air",
    Passenger_offroad = <any>"passenger_offroad",
    Passenger_rail = <any>"passenger_rail",
    Passenger_road = <any>"passenger_road",
    Passenger_water = <any>"passenger_water",
    Offroad_machinery_offroad = <any>"offroad_machinery_offroad",
    T_n_d_loss = <any>"t_n_d_loss",
    Business_travel = <any>"business_travel",
    Purchased_goods_and_services = <any>"purchased_goods_and_services",
    Capital_goods = <any>"capital_goods",
    Fuel_energy_related_activities = <any>"fuel_energy_related_activities",
    Upstream_transportation_and_distribution = <any>"upstream_transportation_and_distribution",
    Waste_generated_in_operations = <any>"waste_generated_in_operations",
    Net_zero_business_travel = <any>"net_zero_business_travel",
    Net_zero_employee_commuting = <any>"net_zero_employee_commuting",
    Upstream_leased_assets = <any>"upstream_leased_assets",
    Downstream_transportation_and_distribution = <any>"downstream_transportation_and_distribution",
    Processing_of_sold_products = <any>"processing_of_sold_products",
    Use_of_sold_products = <any>"use_of_sold_products",
    End_of_life_treatment_of_sold_products = <any>"end_of_life_treatment_of_sold_products",
    Downstream_leased_assets = <any>"downstream_leased_assets",
    Franchises = <any>"franchises",
    Investments = <any>"investments",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}