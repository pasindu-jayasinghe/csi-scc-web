/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const ES_API_BASE_URL = new InjectionToken<string>('ES_API_BASE_URL');

@Injectable()
export class AppControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ES_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getHello(): Observable<void> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHello(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHello(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetHello(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }
}

@Injectable()
export class EmissionControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ES_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    emissionCal(body: EmissionCalReqDto): Observable<void> {
        let url_ = this.baseUrl + "/emission/cal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmissionCal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmissionCal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEmissionCal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ES_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Create a single FuelFactor
     * @return Get create one base response
     */
    createOneBaseFuelFactorControllerFuelFactor(body: FuelFactor): Observable<FuelFactor> {
        let url_ = this.baseUrl + "/fuelfactor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFuelFactorControllerFuelFactor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFuelFactorControllerFuelFactor(<any>response_);
                } catch (e) {
                    return <Observable<FuelFactor>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelFactor>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseFuelFactorControllerFuelFactor(response: HttpResponseBase): Observable<FuelFactor> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FuelFactor.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve multiple FuelFactors
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFuelFactorControllerFuelFactor(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFuelFactorResponseDto> {
        let url_ = this.baseUrl + "/fuelfactor?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFuelFactorControllerFuelFactor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFuelFactorControllerFuelFactor(<any>response_);
                } catch (e) {
                    return <Observable<GetManyFuelFactorResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyFuelFactorResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseFuelFactorControllerFuelFactor(response: HttpResponseBase): Observable<GetManyFuelFactorResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFuelFactorResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve a single FuelFactor
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFuelFactorControllerFuelFactor(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FuelFactor> {
        let url_ = this.baseUrl + "/fuelfactor/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFuelFactorControllerFuelFactor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFuelFactorControllerFuelFactor(<any>response_);
                } catch (e) {
                    return <Observable<FuelFactor>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelFactor>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseFuelFactorControllerFuelFactor(response: HttpResponseBase): Observable<FuelFactor> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelFactor.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Update a single FuelFactor
     * @return Response
     */
    updateOneBaseFuelFactorControllerFuelFactor(id: number, body: FuelFactor): Observable<FuelFactor> {
        let url_ = this.baseUrl + "/fuelfactor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFuelFactorControllerFuelFactor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFuelFactorControllerFuelFactor(<any>response_);
                } catch (e) {
                    return <Observable<FuelFactor>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelFactor>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseFuelFactorControllerFuelFactor(response: HttpResponseBase): Observable<FuelFactor> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelFactor.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Replace a single FuelFactor
     * @return Response
     */
    replaceOneBaseFuelFactorControllerFuelFactor(id: number, body: FuelFactor): Observable<FuelFactor> {
        let url_ = this.baseUrl + "/fuelfactor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFuelFactorControllerFuelFactor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFuelFactorControllerFuelFactor(<any>response_);
                } catch (e) {
                    return <Observable<FuelFactor>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelFactor>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseFuelFactorControllerFuelFactor(response: HttpResponseBase): Observable<FuelFactor> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelFactor.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Delete a single FuelFactor
     * @return Delete one base response
     */
    deleteOneBaseFuelFactorControllerFuelFactor(id: number): Observable<void> {
        let url_ = this.baseUrl + "/fuelfactor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFuelFactorControllerFuelFactor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFuelFactorControllerFuelFactor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseFuelFactorControllerFuelFactor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create multiple FuelFactors
     * @return Get create many base response
     */
    createManyBaseFuelFactorControllerFuelFactor(body: CreateManyFuelFactorDto): Observable<FuelFactor[]> {
        let url_ = this.baseUrl + "/fuelfactor/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFuelFactorControllerFuelFactor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFuelFactorControllerFuelFactor(<any>response_);
                } catch (e) {
                    return <Observable<FuelFactor[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelFactor[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseFuelFactorControllerFuelFactor(response: HttpResponseBase): Observable<FuelFactor[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FuelFactor.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create a single Fuel
     * @return Get create one base response
     */
    createOneBaseFuelControllerFuel(body: Fuel): Observable<Fuel> {
        let url_ = this.baseUrl + "/fuel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFuelControllerFuel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFuelControllerFuel(<any>response_);
                } catch (e) {
                    return <Observable<Fuel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Fuel>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseFuelControllerFuel(response: HttpResponseBase): Observable<Fuel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Fuel.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve multiple Fuels
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFuelControllerFuel(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFuelResponseDto> {
        let url_ = this.baseUrl + "/fuel?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFuelControllerFuel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFuelControllerFuel(<any>response_);
                } catch (e) {
                    return <Observable<GetManyFuelResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyFuelResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseFuelControllerFuel(response: HttpResponseBase): Observable<GetManyFuelResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFuelResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve a single Fuel
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFuelControllerFuel(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Fuel> {
        let url_ = this.baseUrl + "/fuel/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFuelControllerFuel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFuelControllerFuel(<any>response_);
                } catch (e) {
                    return <Observable<Fuel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Fuel>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseFuelControllerFuel(response: HttpResponseBase): Observable<Fuel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Fuel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Update a single Fuel
     * @return Response
     */
    updateOneBaseFuelControllerFuel(id: number, body: Fuel): Observable<Fuel> {
        let url_ = this.baseUrl + "/fuel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFuelControllerFuel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFuelControllerFuel(<any>response_);
                } catch (e) {
                    return <Observable<Fuel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Fuel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseFuelControllerFuel(response: HttpResponseBase): Observable<Fuel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Fuel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Replace a single Fuel
     * @return Response
     */
    replaceOneBaseFuelControllerFuel(id: number, body: Fuel): Observable<Fuel> {
        let url_ = this.baseUrl + "/fuel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFuelControllerFuel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFuelControllerFuel(<any>response_);
                } catch (e) {
                    return <Observable<Fuel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Fuel>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseFuelControllerFuel(response: HttpResponseBase): Observable<Fuel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Fuel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Delete a single Fuel
     * @return Delete one base response
     */
    deleteOneBaseFuelControllerFuel(id: number): Observable<void> {
        let url_ = this.baseUrl + "/fuel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFuelControllerFuel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFuelControllerFuel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseFuelControllerFuel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create multiple Fuels
     * @return Get create many base response
     */
    createManyBaseFuelControllerFuel(body: CreateManyFuelDto): Observable<Fuel[]> {
        let url_ = this.baseUrl + "/fuel/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFuelControllerFuel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFuelControllerFuel(<any>response_);
                } catch (e) {
                    return <Observable<Fuel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Fuel[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseFuelControllerFuel(response: HttpResponseBase): Observable<Fuel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Fuel.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create a single FuelPrice
     * @return Get create one base response
     */
    createOneBaseFuelPriceControllerFuelPrice(body: FuelPrice): Observable<FuelPrice> {
        let url_ = this.baseUrl + "/fuelprice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFuelPriceControllerFuelPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFuelPriceControllerFuelPrice(<any>response_);
                } catch (e) {
                    return <Observable<FuelPrice>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelPrice>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseFuelPriceControllerFuelPrice(response: HttpResponseBase): Observable<FuelPrice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FuelPrice.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve multiple FuelPrices
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFuelPriceControllerFuelPrice(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFuelPriceResponseDto> {
        let url_ = this.baseUrl + "/fuelprice?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFuelPriceControllerFuelPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFuelPriceControllerFuelPrice(<any>response_);
                } catch (e) {
                    return <Observable<GetManyFuelPriceResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyFuelPriceResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseFuelPriceControllerFuelPrice(response: HttpResponseBase): Observable<GetManyFuelPriceResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFuelPriceResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve a single FuelPrice
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFuelPriceControllerFuelPrice(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FuelPrice> {
        let url_ = this.baseUrl + "/fuelprice/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFuelPriceControllerFuelPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFuelPriceControllerFuelPrice(<any>response_);
                } catch (e) {
                    return <Observable<FuelPrice>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelPrice>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseFuelPriceControllerFuelPrice(response: HttpResponseBase): Observable<FuelPrice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelPrice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Update a single FuelPrice
     * @return Response
     */
    updateOneBaseFuelPriceControllerFuelPrice(id: number, body: FuelPrice): Observable<FuelPrice> {
        let url_ = this.baseUrl + "/fuelprice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFuelPriceControllerFuelPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFuelPriceControllerFuelPrice(<any>response_);
                } catch (e) {
                    return <Observable<FuelPrice>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelPrice>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseFuelPriceControllerFuelPrice(response: HttpResponseBase): Observable<FuelPrice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelPrice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Replace a single FuelPrice
     * @return Response
     */
    replaceOneBaseFuelPriceControllerFuelPrice(id: number, body: FuelPrice): Observable<FuelPrice> {
        let url_ = this.baseUrl + "/fuelprice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFuelPriceControllerFuelPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFuelPriceControllerFuelPrice(<any>response_);
                } catch (e) {
                    return <Observable<FuelPrice>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelPrice>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseFuelPriceControllerFuelPrice(response: HttpResponseBase): Observable<FuelPrice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelPrice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Delete a single FuelPrice
     * @return Delete one base response
     */
    deleteOneBaseFuelPriceControllerFuelPrice(id: number): Observable<void> {
        let url_ = this.baseUrl + "/fuelprice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFuelPriceControllerFuelPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFuelPriceControllerFuelPrice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseFuelPriceControllerFuelPrice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create multiple FuelPrices
     * @return Get create many base response
     */
    createManyBaseFuelPriceControllerFuelPrice(body: CreateManyFuelPriceDto): Observable<FuelPrice[]> {
        let url_ = this.baseUrl + "/fuelprice/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFuelPriceControllerFuelPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFuelPriceControllerFuelPrice(<any>response_);
                } catch (e) {
                    return <Observable<FuelPrice[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelPrice[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseFuelPriceControllerFuelPrice(response: HttpResponseBase): Observable<FuelPrice[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FuelPrice.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create a single FuelSpecific
     * @return Get create one base response
     */
    createOneBaseFuelSepecificControllerFuelSpecific(body: FuelSpecific): Observable<FuelSpecific> {
        let url_ = this.baseUrl + "/fuelspecific";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFuelSepecificControllerFuelSpecific(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFuelSepecificControllerFuelSpecific(<any>response_);
                } catch (e) {
                    return <Observable<FuelSpecific>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelSpecific>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseFuelSepecificControllerFuelSpecific(response: HttpResponseBase): Observable<FuelSpecific> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FuelSpecific.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve multiple FuelSpecifics
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFuelSepecificControllerFuelSpecific(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFuelSpecificResponseDto> {
        let url_ = this.baseUrl + "/fuelspecific?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFuelSepecificControllerFuelSpecific(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFuelSepecificControllerFuelSpecific(<any>response_);
                } catch (e) {
                    return <Observable<GetManyFuelSpecificResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyFuelSpecificResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseFuelSepecificControllerFuelSpecific(response: HttpResponseBase): Observable<GetManyFuelSpecificResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFuelSpecificResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve a single FuelSpecific
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFuelSepecificControllerFuelSpecific(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FuelSpecific> {
        let url_ = this.baseUrl + "/fuelspecific/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFuelSepecificControllerFuelSpecific(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFuelSepecificControllerFuelSpecific(<any>response_);
                } catch (e) {
                    return <Observable<FuelSpecific>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelSpecific>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseFuelSepecificControllerFuelSpecific(response: HttpResponseBase): Observable<FuelSpecific> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelSpecific.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Update a single FuelSpecific
     * @return Response
     */
    updateOneBaseFuelSepecificControllerFuelSpecific(id: number, body: FuelSpecific): Observable<FuelSpecific> {
        let url_ = this.baseUrl + "/fuelspecific/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFuelSepecificControllerFuelSpecific(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFuelSepecificControllerFuelSpecific(<any>response_);
                } catch (e) {
                    return <Observable<FuelSpecific>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelSpecific>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseFuelSepecificControllerFuelSpecific(response: HttpResponseBase): Observable<FuelSpecific> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelSpecific.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Replace a single FuelSpecific
     * @return Response
     */
    replaceOneBaseFuelSepecificControllerFuelSpecific(id: number, body: FuelSpecific): Observable<FuelSpecific> {
        let url_ = this.baseUrl + "/fuelspecific/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFuelSepecificControllerFuelSpecific(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFuelSepecificControllerFuelSpecific(<any>response_);
                } catch (e) {
                    return <Observable<FuelSpecific>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelSpecific>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseFuelSepecificControllerFuelSpecific(response: HttpResponseBase): Observable<FuelSpecific> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FuelSpecific.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Delete a single FuelSpecific
     * @return Delete one base response
     */
    deleteOneBaseFuelSepecificControllerFuelSpecific(id: number): Observable<void> {
        let url_ = this.baseUrl + "/fuelspecific/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFuelSepecificControllerFuelSpecific(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFuelSepecificControllerFuelSpecific(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseFuelSepecificControllerFuelSpecific(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create multiple FuelSpecifics
     * @return Get create many base response
     */
    createManyBaseFuelSepecificControllerFuelSpecific(body: CreateManyFuelSpecificDto): Observable<FuelSpecific[]> {
        let url_ = this.baseUrl + "/fuelspecific/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFuelSepecificControllerFuelSpecific(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFuelSepecificControllerFuelSpecific(<any>response_);
                } catch (e) {
                    return <Observable<FuelSpecific[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FuelSpecific[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseFuelSepecificControllerFuelSpecific(response: HttpResponseBase): Observable<FuelSpecific[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FuelSpecific.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }
}

export class EmissionCalReqDto implements IEmissionCalReqDto {

    constructor(data?: IEmissionCalReqDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): EmissionCalReqDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmissionCalReqDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): EmissionCalReqDto {
        const json = this.toJSON();
        let result = new EmissionCalReqDto();
        result.init(json);
        return result;
    }
}

export interface IEmissionCalReqDto {
}

export class GetManyFuelFactorResponseDto implements IGetManyFuelFactorResponseDto {
    data: FuelFactor[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFuelFactorResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FuelFactor.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFuelFactorResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFuelFactorResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFuelFactorResponseDto {
        const json = this.toJSON();
        let result = new GetManyFuelFactorResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFuelFactorResponseDto {
    data: FuelFactor[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class FuelFactor implements IFuelFactor {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    source: string;
    industry: string;
    tier: string;
    countryCode: string;
    code: string;
    year: number;
    ch4_default: number;
    ch4__upper: number;
    ch4_lower: number;
    n20_default: number;
    n20__upper: number;
    n20_lower: number;
    co2_default: number;
    co2__upper: number;
    co2_lower: number;
    reference: string;

    constructor(data?: IFuelFactor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.source = _data["source"];
            this.industry = _data["industry"];
            this.tier = _data["tier"];
            this.countryCode = _data["countryCode"];
            this.code = _data["code"];
            this.year = _data["year"];
            this.ch4_default = _data["ch4_default"];
            this.ch4__upper = _data["ch4__upper"];
            this.ch4_lower = _data["ch4_lower"];
            this.n20_default = _data["n20_default"];
            this.n20__upper = _data["n20__upper"];
            this.n20_lower = _data["n20_lower"];
            this.co2_default = _data["co2_default"];
            this.co2__upper = _data["co2__upper"];
            this.co2_lower = _data["co2_lower"];
            this.reference = _data["reference"];
        }
    }

    static fromJS(data: any): FuelFactor {
        data = typeof data === 'object' ? data : {};
        let result = new FuelFactor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["source"] = this.source;
        data["industry"] = this.industry;
        data["tier"] = this.tier;
        data["countryCode"] = this.countryCode;
        data["code"] = this.code;
        data["year"] = this.year;
        data["ch4_default"] = this.ch4_default;
        data["ch4__upper"] = this.ch4__upper;
        data["ch4_lower"] = this.ch4_lower;
        data["n20_default"] = this.n20_default;
        data["n20__upper"] = this.n20__upper;
        data["n20_lower"] = this.n20_lower;
        data["co2_default"] = this.co2_default;
        data["co2__upper"] = this.co2__upper;
        data["co2_lower"] = this.co2_lower;
        data["reference"] = this.reference;
        return data;
    }

    clone(): FuelFactor {
        const json = this.toJSON();
        let result = new FuelFactor();
        result.init(json);
        return result;
    }
}

export interface IFuelFactor {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    source: string;
    industry: string;
    tier: string;
    countryCode: string;
    code: string;
    year: number;
    ch4_default: number;
    ch4__upper: number;
    ch4_lower: number;
    n20_default: number;
    n20__upper: number;
    n20_lower: number;
    co2_default: number;
    co2__upper: number;
    co2_lower: number;
    reference: string;
}

export class CreateManyFuelFactorDto implements ICreateManyFuelFactorDto {
    bulk: FuelFactor[];

    constructor(data?: ICreateManyFuelFactorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FuelFactor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFuelFactorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFuelFactorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFuelFactorDto {
        const json = this.toJSON();
        let result = new CreateManyFuelFactorDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFuelFactorDto {
    bulk: FuelFactor[];
}

export class GetManyFuelResponseDto implements IGetManyFuelResponseDto {
    data: Fuel[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFuelResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Fuel.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFuelResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFuelResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFuelResponseDto {
        const json = this.toJSON();
        let result = new GetManyFuelResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFuelResponseDto {
    data: Fuel[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Fuel implements IFuel {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;

    constructor(data?: IFuel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Fuel {
        data = typeof data === 'object' ? data : {};
        let result = new Fuel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }

    clone(): Fuel {
        const json = this.toJSON();
        let result = new Fuel();
        result.init(json);
        return result;
    }
}

export interface IFuel {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
}

export class CreateManyFuelDto implements ICreateManyFuelDto {
    bulk: Fuel[];

    constructor(data?: ICreateManyFuelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Fuel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFuelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFuelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFuelDto {
        const json = this.toJSON();
        let result = new CreateManyFuelDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFuelDto {
    bulk: Fuel[];
}

export class GetManyFuelPriceResponseDto implements IGetManyFuelPriceResponseDto {
    data: FuelPrice[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFuelPriceResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FuelPrice.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFuelPriceResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFuelPriceResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFuelPriceResponseDto {
        const json = this.toJSON();
        let result = new GetManyFuelPriceResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFuelPriceResponseDto {
    data: FuelPrice[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class FuelPrice implements IFuelPrice {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code: string;
    country: string;
    year: string;
    month: string;
    currency: string;
    price: number;

    constructor(data?: IFuelPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.code = _data["code"];
            this.country = _data["country"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.currency = _data["currency"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): FuelPrice {
        data = typeof data === 'object' ? data : {};
        let result = new FuelPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["code"] = this.code;
        data["country"] = this.country;
        data["year"] = this.year;
        data["month"] = this.month;
        data["currency"] = this.currency;
        data["price"] = this.price;
        return data;
    }

    clone(): FuelPrice {
        const json = this.toJSON();
        let result = new FuelPrice();
        result.init(json);
        return result;
    }
}

export interface IFuelPrice {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code: string;
    country: string;
    year: string;
    month: string;
    currency: string;
    price: number;
}

export class CreateManyFuelPriceDto implements ICreateManyFuelPriceDto {
    bulk: FuelPrice[];

    constructor(data?: ICreateManyFuelPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FuelPrice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFuelPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFuelPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFuelPriceDto {
        const json = this.toJSON();
        let result = new CreateManyFuelPriceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFuelPriceDto {
    bulk: FuelPrice[];
}

export class GetManyFuelSpecificResponseDto implements IGetManyFuelSpecificResponseDto {
    data: FuelSpecific[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyFuelSpecificResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FuelSpecific.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFuelSpecificResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFuelSpecificResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFuelSpecificResponseDto {
        const json = this.toJSON();
        let result = new GetManyFuelSpecificResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFuelSpecificResponseDto {
    data: FuelSpecific[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class FuelSpecific implements IFuelSpecific {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code: string;
    country: string;
    year: string;
    ncv: number;
    density: number;

    constructor(data?: IFuelSpecific) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.code = _data["code"];
            this.country = _data["country"];
            this.year = _data["year"];
            this.ncv = _data["ncv"];
            this.density = _data["density"];
        }
    }

    static fromJS(data: any): FuelSpecific {
        data = typeof data === 'object' ? data : {};
        let result = new FuelSpecific();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["code"] = this.code;
        data["country"] = this.country;
        data["year"] = this.year;
        data["ncv"] = this.ncv;
        data["density"] = this.density;
        return data;
    }

    clone(): FuelSpecific {
        const json = this.toJSON();
        let result = new FuelSpecific();
        result.init(json);
        return result;
    }
}

export interface IFuelSpecific {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code: string;
    country: string;
    year: string;
    ncv: number;
    density: number;
}

export class CreateManyFuelSpecificDto implements ICreateManyFuelSpecificDto {
    bulk: FuelSpecific[];

    constructor(data?: ICreateManyFuelSpecificDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(FuelSpecific.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyFuelSpecificDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyFuelSpecificDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyFuelSpecificDto {
        const json = this.toJSON();
        let result = new CreateManyFuelSpecificDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyFuelSpecificDto {
    bulk: FuelSpecific[];
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}